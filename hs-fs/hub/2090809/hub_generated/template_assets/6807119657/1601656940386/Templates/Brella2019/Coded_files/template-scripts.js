/**
 * THIS FILE WAS AUTOGENERATED
 */

/*! pace 1.0.0 */
(function(){var a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X=[].slice,Y={}.hasOwnProperty,Z=function(a,b){function c(){this.constructor=a}for(var d in b)Y.call(b,d)&&(a[d]=b[d]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a},$=[].indexOf||function(a){for(var b=0,c=this.length;c>b;b++)if(b in this&&this[b]===a)return b;return-1};for(u={catchupTime:100,initialRate:.03,minTime:250,ghostTime:100,maxProgressPerFrame:20,easeFactor:1.25,startOnPageLoad:!0,restartOnPushState:!0,restartOnRequestAfter:500,target:"body",elements:{checkInterval:100,selectors:["body"]},eventLag:{minSamples:10,sampleCount:3,lagThreshold:3},ajax:{trackMethods:["GET"],trackWebSockets:!0,ignoreURLs:[]}},C=function(){var a;return null!=(a="undefined"!=typeof performance&&null!==performance&&"function"==typeof performance.now?performance.now():void 0)?a:+new Date},E=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame,t=window.cancelAnimationFrame||window.mozCancelAnimationFrame,null==E&&(E=function(a){return setTimeout(a,50)},t=function(a){return clearTimeout(a)}),G=function(a){var b,c;return b=C(),(c=function(){var d;return d=C()-b,d>=33?(b=C(),a(d,function(){return E(c)})):setTimeout(c,33-d)})()},F=function(){var a,b,c;return c=arguments[0],b=arguments[1],a=3<=arguments.length?X.call(arguments,2):[],"function"==typeof c[b]?c[b].apply(c,a):c[b]},v=function(){var a,b,c,d,e,f,g;for(b=arguments[0],d=2<=arguments.length?X.call(arguments,1):[],f=0,g=d.length;g>f;f++)if(c=d[f])for(a in c)Y.call(c,a)&&(e=c[a],null!=b[a]&&"object"==typeof b[a]&&null!=e&&"object"==typeof e?v(b[a],e):b[a]=e);return b},q=function(a){var b,c,d,e,f;for(c=b=0,e=0,f=a.length;f>e;e++)d=a[e],c+=Math.abs(d),b++;return c/b},x=function(a,b){var c,d,e;if(null==a&&(a="options"),null==b&&(b=!0),e=document.querySelector("[data-pace-"+a+"]")){if(c=e.getAttribute("data-pace-"+a),!b)return c;try{return JSON.parse(c)}catch(f){return d=f,"undefined"!=typeof console&&null!==console?console.error("Error parsing inline pace options",d):void 0}}},g=function(){function a(){}return a.prototype.on=function(a,b,c,d){var e;return null==d&&(d=!1),null==this.bindings&&(this.bindings={}),null==(e=this.bindings)[a]&&(e[a]=[]),this.bindings[a].push({handler:b,ctx:c,once:d})},a.prototype.once=function(a,b,c){return this.on(a,b,c,!0)},a.prototype.off=function(a,b){var c,d,e;if(null!=(null!=(d=this.bindings)?d[a]:void 0)){if(null==b)return delete this.bindings[a];for(c=0,e=[];c<this.bindings[a].length;)e.push(this.bindings[a][c].handler===b?this.bindings[a].splice(c,1):c++);return e}},a.prototype.trigger=function(){var a,b,c,d,e,f,g,h,i;if(c=arguments[0],a=2<=arguments.length?X.call(arguments,1):[],null!=(g=this.bindings)?g[c]:void 0){for(e=0,i=[];e<this.bindings[c].length;)h=this.bindings[c][e],d=h.handler,b=h.ctx,f=h.once,d.apply(null!=b?b:this,a),i.push(f?this.bindings[c].splice(e,1):e++);return i}},a}(),j=window.Pace||{},window.Pace=j,v(j,g.prototype),D=j.options=v({},u,window.paceOptions,x()),U=["ajax","document","eventLag","elements"],Q=0,S=U.length;S>Q;Q++)K=U[Q],D[K]===!0&&(D[K]=u[K]);i=function(a){function b(){return V=b.__super__.constructor.apply(this,arguments)}return Z(b,a),b}(Error),b=function(){function a(){this.progress=0}return a.prototype.getElement=function(){var a;if(null==this.el){if(a=document.querySelector(D.target),!a)throw new i;this.el=document.createElement("div"),this.el.className="pace pace-active",document.body.className=document.body.className.replace(/pace-done/g,""),document.body.className+=" pace-running",this.el.innerHTML='<div class="pace-progress">\n  <div class="pace-progress-inner"></div>\n</div>\n<div class="pace-activity"></div>',null!=a.firstChild?a.insertBefore(this.el,a.firstChild):a.appendChild(this.el)}return this.el},a.prototype.finish=function(){var a;return a=this.getElement(),a.className=a.className.replace("pace-active",""),a.className+=" pace-inactive",document.body.className=document.body.className.replace("pace-running",""),document.body.className+=" pace-done"},a.prototype.update=function(a){return this.progress=a,this.render()},a.prototype.destroy=function(){try{this.getElement().parentNode.removeChild(this.getElement())}catch(a){i=a}return this.el=void 0},a.prototype.render=function(){var a,b,c,d,e,f,g;if(null==document.querySelector(D.target))return!1;for(a=this.getElement(),d="translate3d("+this.progress+"%, 0, 0)",g=["webkitTransform","msTransform","transform"],e=0,f=g.length;f>e;e++)b=g[e],a.children[0].style[b]=d;return(!this.lastRenderedProgress||this.lastRenderedProgress|0!==this.progress|0)&&(a.children[0].setAttribute("data-progress-text",""+(0|this.progress)+"%"),this.progress>=100?c="99":(c=this.progress<10?"0":"",c+=0|this.progress),a.children[0].setAttribute("data-progress",""+c)),this.lastRenderedProgress=this.progress},a.prototype.done=function(){return this.progress>=100},a}(),h=function(){function a(){this.bindings={}}return a.prototype.trigger=function(a,b){var c,d,e,f,g;if(null!=this.bindings[a]){for(f=this.bindings[a],g=[],d=0,e=f.length;e>d;d++)c=f[d],g.push(c.call(this,b));return g}},a.prototype.on=function(a,b){var c;return null==(c=this.bindings)[a]&&(c[a]=[]),this.bindings[a].push(b)},a}(),P=window.XMLHttpRequest,O=window.XDomainRequest,N=window.WebSocket,w=function(a,b){var c,d,e,f;f=[];for(d in b.prototype)try{e=b.prototype[d],f.push(null==a[d]&&"function"!=typeof e?a[d]=e:void 0)}catch(g){c=g}return f},A=[],j.ignore=function(){var a,b,c;return b=arguments[0],a=2<=arguments.length?X.call(arguments,1):[],A.unshift("ignore"),c=b.apply(null,a),A.shift(),c},j.track=function(){var a,b,c;return b=arguments[0],a=2<=arguments.length?X.call(arguments,1):[],A.unshift("track"),c=b.apply(null,a),A.shift(),c},J=function(a){var b;if(null==a&&(a="GET"),"track"===A[0])return"force";if(!A.length&&D.ajax){if("socket"===a&&D.ajax.trackWebSockets)return!0;if(b=a.toUpperCase(),$.call(D.ajax.trackMethods,b)>=0)return!0}return!1},k=function(a){function b(){var a,c=this;b.__super__.constructor.apply(this,arguments),a=function(a){var b;return b=a.open,a.open=function(d,e){return J(d)&&c.trigger("request",{type:d,url:e,request:a}),b.apply(a,arguments)}},window.XMLHttpRequest=function(b){var c;return c=new P(b),a(c),c};try{w(window.XMLHttpRequest,P)}catch(d){}if(null!=O){window.XDomainRequest=function(){var b;return b=new O,a(b),b};try{w(window.XDomainRequest,O)}catch(d){}}if(null!=N&&D.ajax.trackWebSockets){window.WebSocket=function(a,b){var d;return d=null!=b?new N(a,b):new N(a),J("socket")&&c.trigger("request",{type:"socket",url:a,protocols:b,request:d}),d};try{w(window.WebSocket,N)}catch(d){}}}return Z(b,a),b}(h),R=null,y=function(){return null==R&&(R=new k),R},I=function(a){var b,c,d,e;for(e=D.ajax.ignoreURLs,c=0,d=e.length;d>c;c++)if(b=e[c],"string"==typeof b){if(-1!==a.indexOf(b))return!0}else if(b.test(a))return!0;return!1},y().on("request",function(b){var c,d,e,f,g;return f=b.type,e=b.request,g=b.url,I(g)?void 0:j.running||D.restartOnRequestAfter===!1&&"force"!==J(f)?void 0:(d=arguments,c=D.restartOnRequestAfter||0,"boolean"==typeof c&&(c=0),setTimeout(function(){var b,c,g,h,i,k;if(b="socket"===f?e.readyState<2:0<(h=e.readyState)&&4>h){for(j.restart(),i=j.sources,k=[],c=0,g=i.length;g>c;c++){if(K=i[c],K instanceof a){K.watch.apply(K,d);break}k.push(void 0)}return k}},c))}),a=function(){function a(){var a=this;this.elements=[],y().on("request",function(){return a.watch.apply(a,arguments)})}return a.prototype.watch=function(a){var b,c,d,e;return d=a.type,b=a.request,e=a.url,I(e)?void 0:(c="socket"===d?new n(b):new o(b),this.elements.push(c))},a}(),o=function(){function a(a){var b,c,d,e,f,g,h=this;if(this.progress=0,null!=window.ProgressEvent)for(c=null,a.addEventListener("progress",function(a){return h.progress=a.lengthComputable?100*a.loaded/a.total:h.progress+(100-h.progress)/2},!1),g=["load","abort","timeout","error"],d=0,e=g.length;e>d;d++)b=g[d],a.addEventListener(b,function(){return h.progress=100},!1);else f=a.onreadystatechange,a.onreadystatechange=function(){var b;return 0===(b=a.readyState)||4===b?h.progress=100:3===a.readyState&&(h.progress=50),"function"==typeof f?f.apply(null,arguments):void 0}}return a}(),n=function(){function a(a){var b,c,d,e,f=this;for(this.progress=0,e=["error","open"],c=0,d=e.length;d>c;c++)b=e[c],a.addEventListener(b,function(){return f.progress=100},!1)}return a}(),d=function(){function a(a){var b,c,d,f;for(null==a&&(a={}),this.elements=[],null==a.selectors&&(a.selectors=[]),f=a.selectors,c=0,d=f.length;d>c;c++)b=f[c],this.elements.push(new e(b))}return a}(),e=function(){function a(a){this.selector=a,this.progress=0,this.check()}return a.prototype.check=function(){var a=this;return document.querySelector(this.selector)?this.done():setTimeout(function(){return a.check()},D.elements.checkInterval)},a.prototype.done=function(){return this.progress=100},a}(),c=function(){function a(){var a,b,c=this;this.progress=null!=(b=this.states[document.readyState])?b:100,a=document.onreadystatechange,document.onreadystatechange=function(){return null!=c.states[document.readyState]&&(c.progress=c.states[document.readyState]),"function"==typeof a?a.apply(null,arguments):void 0}}return a.prototype.states={loading:0,interactive:50,complete:100},a}(),f=function(){function a(){var a,b,c,d,e,f=this;this.progress=0,a=0,e=[],d=0,c=C(),b=setInterval(function(){var g;return g=C()-c-50,c=C(),e.push(g),e.length>D.eventLag.sampleCount&&e.shift(),a=q(e),++d>=D.eventLag.minSamples&&a<D.eventLag.lagThreshold?(f.progress=100,clearInterval(b)):f.progress=100*(3/(a+3))},50)}return a}(),m=function(){function a(a){this.source=a,this.last=this.sinceLastUpdate=0,this.rate=D.initialRate,this.catchup=0,this.progress=this.lastProgress=0,null!=this.source&&(this.progress=F(this.source,"progress"))}return a.prototype.tick=function(a,b){var c;return null==b&&(b=F(this.source,"progress")),b>=100&&(this.done=!0),b===this.last?this.sinceLastUpdate+=a:(this.sinceLastUpdate&&(this.rate=(b-this.last)/this.sinceLastUpdate),this.catchup=(b-this.progress)/D.catchupTime,this.sinceLastUpdate=0,this.last=b),b>this.progress&&(this.progress+=this.catchup*a),c=1-Math.pow(this.progress/100,D.easeFactor),this.progress+=c*this.rate*a,this.progress=Math.min(this.lastProgress+D.maxProgressPerFrame,this.progress),this.progress=Math.max(0,this.progress),this.progress=Math.min(100,this.progress),this.lastProgress=this.progress,this.progress},a}(),L=null,H=null,r=null,M=null,p=null,s=null,j.running=!1,z=function(){return D.restartOnPushState?j.restart():void 0},null!=window.history.pushState&&(T=window.history.pushState,window.history.pushState=function(){return z(),T.apply(window.history,arguments)}),null!=window.history.replaceState&&(W=window.history.replaceState,window.history.replaceState=function(){return z(),W.apply(window.history,arguments)}),l={ajax:a,elements:d,document:c,eventLag:f},(B=function(){var a,c,d,e,f,g,h,i;for(j.sources=L=[],g=["ajax","elements","document","eventLag"],c=0,e=g.length;e>c;c++)a=g[c],D[a]!==!1&&L.push(new l[a](D[a]));for(i=null!=(h=D.extraSources)?h:[],d=0,f=i.length;f>d;d++)K=i[d],L.push(new K(D));return j.bar=r=new b,H=[],M=new m})(),j.stop=function(){return j.trigger("stop"),j.running=!1,r.destroy(),s=!0,null!=p&&("function"==typeof t&&t(p),p=null),B()},j.restart=function(){return j.trigger("restart"),j.stop(),j.start()},j.go=function(){var a;return j.running=!0,r.render(),a=C(),s=!1,p=G(function(b,c){var d,e,f,g,h,i,k,l,n,o,p,q,t,u,v,w;for(l=100-r.progress,e=p=0,f=!0,i=q=0,u=L.length;u>q;i=++q)for(K=L[i],o=null!=H[i]?H[i]:H[i]=[],h=null!=(w=K.elements)?w:[K],k=t=0,v=h.length;v>t;k=++t)g=h[k],n=null!=o[k]?o[k]:o[k]=new m(g),f&=n.done,n.done||(e++,p+=n.tick(b));return d=p/e,r.update(M.tick(b,d)),r.done()||f||s?(r.update(100),j.trigger("done"),setTimeout(function(){return r.finish(),j.running=!1,j.trigger("hide")},Math.max(D.ghostTime,Math.max(D.minTime-(C()-a),0)))):c()})},j.start=function(a){v(D,a),j.running=!0;try{r.render()}catch(b){i=b}return document.querySelector(".pace")?(j.trigger("start"),j.go()):setTimeout(j.start,50)},"function"==typeof define&&define.amd?define(function(){return j}):"object"==typeof exports?module.exports=j:D.startOnPageLoad&&j.start()}).call(this);
!function(e,o){"object"==typeof exports&&"undefined"!=typeof module?module.exports=o():"function"==typeof define&&define.amd?define(o):e.MicroModal=o()}(this,function(){"use strict"
    var e=function(e,o){if(!(e instanceof o))throw new TypeError("Cannot call a class as a function")},o=function(){function e(e,o){for(var t=0;t<o.length;t++){var i=o[t]
        i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}return function(o,t,i){return t&&e(o.prototype,t),i&&e(o,i),o}}(),t=function(e){if(Array.isArray(e)){for(var o=0,t=Array(e.length);o<e.length;o++)t[o]=e[o]
        return t}return Array.from(e)}
    return function(){var i=["a[href]","area[href]",'input:not([disabled]):not([type="hidden"]):not([aria-hidden])',"select:not([disabled]):not([aria-hidden])","textarea:not([disabled]):not([aria-hidden])","button:not([disabled]):not([aria-hidden])","iframe","object","embed","[contenteditable]",'[tabindex]:not([tabindex^="-"])'],n=function(){function n(o){var i=o.targetModal,a=o.triggers,r=void 0===a?[]:a,s=o.onShow,l=void 0===s?function(){}:s,c=o.onClose,d=void 0===c?function(){}:c,u=o.openTrigger,f=void 0===u?"data-micromodal-trigger":u,h=o.closeTrigger,v=void 0===h?"data-micromodal-close":h,g=o.disableScroll,m=void 0!==g&&g,b=o.disableFocus,y=void 0!==b&&b,w=o.awaitCloseAnimation,k=void 0!==w&&w,p=o.debugMode,E=void 0!==p&&p
        e(this,n),this.modal=document.getElementById(i),this.config={debugMode:E,disableScroll:m,openTrigger:f,closeTrigger:v,onShow:l,onClose:d,awaitCloseAnimation:k,disableFocus:y},r.length>0&&this.registerTriggers.apply(this,t(r)),this.onClick=this.onClick.bind(this),this.onKeydown=this.onKeydown.bind(this)}return o(n,[{key:"registerTriggers",value:function(){for(var e=this,o=arguments.length,t=Array(o),i=0;i<o;i++)t[i]=arguments[i]
        t.forEach(function(o){o.addEventListener("click",function(){return e.showModal()})})}},{key:"showModal",value:function(){this.activeElement=document.activeElement,this.modal.setAttribute("aria-hidden","false"),this.modal.classList.add("is-open"),this.setFocusToFirstNode(),this.scrollBehaviour("disable"),this.addEventListeners(),this.config.onShow(this.modal)}},{key:"closeModal",value:function(){var e=this.modal
        this.modal.setAttribute("aria-hidden","true"),this.removeEventListeners(),this.scrollBehaviour("enable"),this.activeElement.focus(),this.config.onClose(this.modal),this.config.awaitCloseAnimation?this.modal.addEventListener("animationend",function o(){e.classList.remove("is-open"),e.removeEventListener("animationend",o,!1)},!1):e.classList.remove("is-open")}},{key:"scrollBehaviour",value:function(e){if(this.config.disableScroll){var o=document.querySelector("body")
        switch(e){case"enable":Object.assign(o.style,{overflow:"initial",height:"initial"})
            break
            case"disable":Object.assign(o.style,{overflow:"hidden",height:"100vh"})}}}},{key:"addEventListeners",value:function(){this.modal.addEventListener("touchstart",this.onClick),this.modal.addEventListener("click",this.onClick),document.addEventListener("keydown",this.onKeydown)}},{key:"removeEventListeners",value:function(){this.modal.removeEventListener("touchstart",this.onClick),this.modal.removeEventListener("click",this.onClick),document.removeEventListener("keydown",this.onKeydown)}},{key:"onClick",value:function(e){e.target.hasAttribute(this.config.closeTrigger)&&(this.closeModal(),e.preventDefault())}},{key:"onKeydown",value:function(e){27===e.keyCode&&this.closeModal(e),9===e.keyCode&&this.maintainFocus(e)}},{key:"getFocusableNodes",value:function(){var e=this.modal.querySelectorAll(i)
        return Object.keys(e).map(function(o){return e[o]})}},{key:"setFocusToFirstNode",value:function(){if(!this.config.disableFocus){var e=this.getFocusableNodes()
        e.length&&e[0].focus()}}},{key:"maintainFocus",value:function(e){var o=this.getFocusableNodes()
        if(this.modal.contains(document.activeElement)){var t=o.indexOf(document.activeElement)
            e.shiftKey&&0===t&&(o[o.length-1].focus(),e.preventDefault()),e.shiftKey||t!==o.length-1||(o[0].focus(),e.preventDefault())}else o[0].focus()}}]),n}(),a=null,r=function(e,o){var t=[]
        return e.forEach(function(e){var i=e.attributes[o].value
            void 0===t[i]&&(t[i]=[]),t[i].push(e)}),t},s=function(e){if(!document.getElementById(e))return console.warn("MicroModal v0.3.1: ❗Seems like you have missed %c'"+e+"'","background-color: #f8f9fa;color: #50596c;font-weight: bold;","ID somewhere in your code. Refer example below to resolve it."),console.warn("%cExample:","background-color: #f8f9fa;color: #50596c;font-weight: bold;",'<div class="modal" id="'+e+'"></div>'),!1},l=function(e){if(e.length<=0)return console.warn("MicroModal v0.3.1: ❗Please specify at least one %c'micromodal-trigger'","background-color: #f8f9fa;color: #50596c;font-weight: bold;","data attribute."),console.warn("%cExample:","background-color: #f8f9fa;color: #50596c;font-weight: bold;",'<a href="#" data-micromodal-trigger="my-modal"></a>'),!1},c=function(e,o){if(l(e),!o)return!0
        for(var t in o)s(t)
        return!0}
        return{init:function(e){var o=Object.assign({},{openTrigger:"data-micromodal-trigger"},e),i=[].concat(t(document.querySelectorAll("["+o.openTrigger+"]"))),a=r(i,o.openTrigger)
            if(!0!==o.debugMode||!1!==c(i,a))for(var s in a){var l=a[s]
                o.targetModal=s,o.triggers=[].concat(t(l)),new n(o)}},show:function(e,o){var t=o||{}
            t.targetModal=e,!0===t.debugMode&&!1===s(e)||(a=new n(t),a.showModal())},close:function(){a.closeModal()}}}()})
/*! npm.im/object-fit-images 3.2.4 */
var objectFitImages = (function () {
    'use strict';

    var OFI = 'bfred-it:object-fit-images';
    var propRegex = /(object-fit|object-position)\s*:\s*([-.\w\s%]+)/g;
    var testImg = typeof Image === 'undefined' ? {style: {'object-position': 1}} : new Image();
    var supportsObjectFit = 'object-fit' in testImg.style;
    var supportsObjectPosition = 'object-position' in testImg.style;
    var supportsOFI = 'background-size' in testImg.style;
    var supportsCurrentSrc = typeof testImg.currentSrc === 'string';
    var nativeGetAttribute = testImg.getAttribute;
    var nativeSetAttribute = testImg.setAttribute;
    var autoModeEnabled = false;

    function createPlaceholder(w, h) {
        return ("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='" + w + "' height='" + h + "'%3E%3C/svg%3E");
    }

    function polyfillCurrentSrc(el) {
        if (el.srcset && !supportsCurrentSrc && window.picturefill) {
            var pf = window.picturefill._;
            // parse srcset with picturefill where currentSrc isn't available
            if (!el[pf.ns] || !el[pf.ns].evaled) {
                // force synchronous srcset parsing
                pf.fillImg(el, {reselect: true});
            }

            if (!el[pf.ns].curSrc) {
                // force picturefill to parse srcset
                el[pf.ns].supported = false;
                pf.fillImg(el, {reselect: true});
            }

            // retrieve parsed currentSrc, if any
            el.currentSrc = el[pf.ns].curSrc || el.src;
        }
    }

    function getStyle(el) {
        var style = getComputedStyle(el).fontFamily;
        var parsed;
        var props = {};
        while ((parsed = propRegex.exec(style)) !== null) {
            props[parsed[1]] = parsed[2];
        }
        return props;
    }

    function setPlaceholder(img, width, height) {
        // Default: fill width, no height
        var placeholder = createPlaceholder(width || 1, height || 0);

        // Only set placeholder if it's different
        if (nativeGetAttribute.call(img, 'src') !== placeholder) {
            nativeSetAttribute.call(img, 'src', placeholder);
        }
    }

    function onImageReady(img, callback) {
        // naturalWidth is only available when the image headers are loaded,
        // this loop will poll it every 100ms.
        if (img.naturalWidth) {
            callback(img);
        } else {
            setTimeout(onImageReady, 100, img, callback);
        }
    }

    function fixOne(el) {
        var style = getStyle(el);
        var ofi = el[OFI];
        style['object-fit'] = style['object-fit'] || 'fill'; // default value

        // Avoid running where unnecessary, unless OFI had already done its deed
        if (!ofi.img) {
            // fill is the default behavior so no action is necessary
            if (style['object-fit'] === 'fill') {
                return;
            }

            // Where object-fit is supported and object-position isn't (Safari < 10)
            if (
                !ofi.skipTest && // unless user wants to apply regardless of browser support
                supportsObjectFit && // if browser already supports object-fit
                !style['object-position'] // unless object-position is used
            ) {
                return;
            }
        }

        // keep a clone in memory while resetting the original to a blank
        if (!ofi.img) {
            ofi.img = new Image(el.width, el.height);
            ofi.img.srcset = nativeGetAttribute.call(el, "data-ofi-srcset") || el.srcset;
            ofi.img.src = nativeGetAttribute.call(el, "data-ofi-src") || el.src;

            // preserve for any future cloneNode calls
            // https://github.com/bfred-it/object-fit-images/issues/53
            nativeSetAttribute.call(el, "data-ofi-src", el.src);
            if (el.srcset) {
                nativeSetAttribute.call(el, "data-ofi-srcset", el.srcset);
            }

            setPlaceholder(el, el.naturalWidth || el.width, el.naturalHeight || el.height);

            // remove srcset because it overrides src
            if (el.srcset) {
                el.srcset = '';
            }
            try {
                keepSrcUsable(el);
            } catch (err) {
                if (window.console) {
                    console.warn('https://bit.ly/ofi-old-browser');
                }
            }
        }

        polyfillCurrentSrc(ofi.img);

        el.style.backgroundImage = "url(\"" + ((ofi.img.currentSrc || ofi.img.src).replace(/"/g, '\\"')) + "\")";
        el.style.backgroundPosition = style['object-position'] || 'center';
        el.style.backgroundRepeat = 'no-repeat';
        el.style.backgroundOrigin = 'content-box';

        if (/scale-down/.test(style['object-fit'])) {
            onImageReady(ofi.img, function () {
                if (ofi.img.naturalWidth > el.width || ofi.img.naturalHeight > el.height) {
                    el.style.backgroundSize = 'contain';
                } else {
                    el.style.backgroundSize = 'auto';
                }
            });
        } else {
            el.style.backgroundSize = style['object-fit'].replace('none', 'auto').replace('fill', '100% 100%');
        }

        onImageReady(ofi.img, function (img) {
            setPlaceholder(el, img.naturalWidth, img.naturalHeight);
        });
    }

    function keepSrcUsable(el) {
        var descriptors = {
            get: function get(prop) {
                return el[OFI].img[prop ? prop : 'src'];
            },
            set: function set(value, prop) {
                el[OFI].img[prop ? prop : 'src'] = value;
                nativeSetAttribute.call(el, ("data-ofi-" + prop), value); // preserve for any future cloneNode
                fixOne(el);
                return value;
            }
        };
        Object.defineProperty(el, 'src', descriptors);
        Object.defineProperty(el, 'currentSrc', {
            get: function () { return descriptors.get('currentSrc'); }
        });
        Object.defineProperty(el, 'srcset', {
            get: function () { return descriptors.get('srcset'); },
            set: function (ss) { return descriptors.set(ss, 'srcset'); }
        });
    }

    function hijackAttributes() {
        function getOfiImageMaybe(el, name) {
            return el[OFI] && el[OFI].img && (name === 'src' || name === 'srcset') ? el[OFI].img : el;
        }
        if (!supportsObjectPosition) {
            HTMLImageElement.prototype.getAttribute = function (name) {
                return nativeGetAttribute.call(getOfiImageMaybe(this, name), name);
            };

            HTMLImageElement.prototype.setAttribute = function (name, value) {
                return nativeSetAttribute.call(getOfiImageMaybe(this, name), name, String(value));
            };
        }
    }

    function fix(imgs, opts) {
        var startAutoMode = !autoModeEnabled && !imgs;
        opts = opts || {};
        imgs = imgs || 'img';

        if ((supportsObjectPosition && !opts.skipTest) || !supportsOFI) {
            return false;
        }

        // use imgs as a selector or just select all images
        if (imgs === 'img') {
            imgs = document.getElementsByTagName('img');
        } else if (typeof imgs === 'string') {
            imgs = document.querySelectorAll(imgs);
        } else if (!('length' in imgs)) {
            imgs = [imgs];
        }

        // apply fix to all
        for (var i = 0; i < imgs.length; i++) {
            imgs[i][OFI] = imgs[i][OFI] || {
                    skipTest: opts.skipTest
                };
            fixOne(imgs[i]);
        }

        if (startAutoMode) {
            document.body.addEventListener('load', function (e) {
                if (e.target.tagName === 'IMG') {
                    fix(e.target, {
                        skipTest: opts.skipTest
                    });
                }
            }, true);
            autoModeEnabled = true;
            imgs = 'img'; // reset to a generic selector for watchMQ
        }

        // if requested, watch media queries for object-fit change
        if (opts.watchMQ) {
            window.addEventListener('resize', fix.bind(null, imgs, {
                skipTest: opts.skipTest
            }));
        }
    }

    fix.supportsObjectFit = supportsObjectFit;
    fix.supportsObjectPosition = supportsObjectPosition;

    hijackAttributes();

    return fix;

}());
/*!
 * ScrollMagic v2.0.7 (2019-05-07)
 * The javascript library for magical scroll interactions.
 * (c) 2019 Jan Paepke (@janpaepke)
 * Project Website: http://scrollmagic.io
 * 
 * @version 2.0.7
 * @license Dual licensed under MIT license and GPL.
 * @author Jan Paepke - e-mail@janpaepke.de
 *
 * @file ScrollMagic main library.
 */
/**
 * @namespace ScrollMagic
 */
(function (root, factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(factory);
	} else if (typeof exports === 'object') {
		// CommonJS
		module.exports = factory();
	} else {
		// Browser global
		root.ScrollMagic = factory();
	}
}(this, function () {
	"use strict";

	var ScrollMagic = function () {
		_util.log(2, '(COMPATIBILITY NOTICE) -> As of ScrollMagic 2.0.0 you need to use \'new ScrollMagic.Controller()\' to create a new controller instance. Use \'new ScrollMagic.Scene()\' to instance a scene.');
	};

	ScrollMagic.version = "2.0.7";

	// TODO: temporary workaround for chrome's scroll jitter bug
	window.addEventListener("mousewheel", function () {});

	// global const
	var PIN_SPACER_ATTRIBUTE = "data-scrollmagic-pin-spacer";

	/**
	 * The main class that is needed once per scroll container.
	 *
	 * @class
	 *
	 * @example
	 * // basic initialization
	 * var controller = new ScrollMagic.Controller();
	 *
	 * // passing options
	 * var controller = new ScrollMagic.Controller({container: "#myContainer", loglevel: 3});
	 *
	 * @param {object} [options] - An object containing one or more options for the controller.
	 * @param {(string|object)} [options.container=window] - A selector, DOM object that references the main container for scrolling.
	 * @param {boolean} [options.vertical=true] - Sets the scroll mode to vertical (`true`) or horizontal (`false`) scrolling.
	 * @param {object} [options.globalSceneOptions={}] - These options will be passed to every Scene that is added to the controller using the addScene method. For more information on Scene options see {@link ScrollMagic.Scene}.
	 * @param {number} [options.loglevel=2] Loglevel for debugging. Note that logging is disabled in the minified version of ScrollMagic.
											 ** `0` => silent
											 ** `1` => errors
											 ** `2` => errors, warnings
											 ** `3` => errors, warnings, debuginfo
	 * @param {boolean} [options.refreshInterval=100] - Some changes don't call events by default, like changing the container size or moving a scene trigger element.  
	 																										 This interval polls these parameters to fire the necessary events.  
	 																										 If you don't use custom containers, trigger elements or have static layouts, where the positions of the trigger elements don't change, you can set this to 0 disable interval checking and improve performance.
	 *
	 */
	ScrollMagic.Controller = function (options) {
		/*
		 * ----------------------------------------------------------------
		 * settings
		 * ----------------------------------------------------------------
		 */
		var
			NAMESPACE = 'ScrollMagic.Controller',
			SCROLL_DIRECTION_FORWARD = 'FORWARD',
			SCROLL_DIRECTION_REVERSE = 'REVERSE',
			SCROLL_DIRECTION_PAUSED = 'PAUSED',
			DEFAULT_OPTIONS = CONTROLLER_OPTIONS.defaults;

		/*
		 * ----------------------------------------------------------------
		 * private vars
		 * ----------------------------------------------------------------
		 */
		var
			Controller = this,
			_options = _util.extend({}, DEFAULT_OPTIONS, options),
			_sceneObjects = [],
			_updateScenesOnNextCycle = false, // can be boolean (true => all scenes) or an array of scenes to be updated
			_scrollPos = 0,
			_scrollDirection = SCROLL_DIRECTION_PAUSED,
			_isDocument = true,
			_viewPortSize = 0,
			_enabled = true,
			_updateTimeout,
			_refreshTimeout;

		/*
		 * ----------------------------------------------------------------
		 * private functions
		 * ----------------------------------------------------------------
		 */

		/**
		 * Internal constructor function of the ScrollMagic Controller
		 * @private
		 */
		var construct = function () {
			for (var key in _options) {
				if (!DEFAULT_OPTIONS.hasOwnProperty(key)) {
					log(2, "WARNING: Unknown option \"" + key + "\"");
					delete _options[key];
				}
			}
			_options.container = _util.get.elements(_options.container)[0];
			// check ScrollContainer
			if (!_options.container) {
				log(1, "ERROR creating object " + NAMESPACE + ": No valid scroll container supplied");
				throw NAMESPACE + " init failed."; // cancel
			}
			_isDocument = _options.container === window || _options.container === document.body || !document.body.contains(_options.container);
			// normalize to window
			if (_isDocument) {
				_options.container = window;
			}
			// update container size immediately
			_viewPortSize = getViewportSize();
			// set event handlers
			_options.container.addEventListener("resize", onChange);
			_options.container.addEventListener("scroll", onChange);

			var ri = parseInt(_options.refreshInterval, 10);
			_options.refreshInterval = _util.type.Number(ri) ? ri : DEFAULT_OPTIONS.refreshInterval;
			scheduleRefresh();

			log(3, "added new " + NAMESPACE + " controller (v" + ScrollMagic.version + ")");
		};

		/**
		 * Schedule the next execution of the refresh function
		 * @private
		 */
		var scheduleRefresh = function () {
			if (_options.refreshInterval > 0) {
				_refreshTimeout = window.setTimeout(refresh, _options.refreshInterval);
			}
		};

		/**
		 * Default function to get scroll pos - overwriteable using `Controller.scrollPos(newFunction)`
		 * @private
		 */
		var getScrollPos = function () {
			return _options.vertical ? _util.get.scrollTop(_options.container) : _util.get.scrollLeft(_options.container);
		};

		/**
		 * Returns the current viewport Size (width vor horizontal, height for vertical)
		 * @private
		 */
		var getViewportSize = function () {
			return _options.vertical ? _util.get.height(_options.container) : _util.get.width(_options.container);
		};

		/**
		 * Default function to set scroll pos - overwriteable using `Controller.scrollTo(newFunction)`
		 * Make available publicly for pinned mousewheel workaround.
		 * @private
		 */
		var setScrollPos = this._setScrollPos = function (pos) {
			if (_options.vertical) {
				if (_isDocument) {
					window.scrollTo(_util.get.scrollLeft(), pos);
				} else {
					_options.container.scrollTop = pos;
				}
			} else {
				if (_isDocument) {
					window.scrollTo(pos, _util.get.scrollTop());
				} else {
					_options.container.scrollLeft = pos;
				}
			}
		};

		/**
		 * Handle updates in cycles instead of on scroll (performance)
		 * @private
		 */
		var updateScenes = function () {
			if (_enabled && _updateScenesOnNextCycle) {
				// determine scenes to update
				var scenesToUpdate = _util.type.Array(_updateScenesOnNextCycle) ? _updateScenesOnNextCycle : _sceneObjects.slice(0);
				// reset scenes
				_updateScenesOnNextCycle = false;
				var oldScrollPos = _scrollPos;
				// update scroll pos now instead of onChange, as it might have changed since scheduling (i.e. in-browser smooth scroll)
				_scrollPos = Controller.scrollPos();
				var deltaScroll = _scrollPos - oldScrollPos;
				if (deltaScroll !== 0) { // scroll position changed?
					_scrollDirection = (deltaScroll > 0) ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_REVERSE;
				}
				// reverse order of scenes if scrolling reverse
				if (_scrollDirection === SCROLL_DIRECTION_REVERSE) {
					scenesToUpdate.reverse();
				}
				// update scenes
				scenesToUpdate.forEach(function (scene, index) {
					log(3, "updating Scene " + (index + 1) + "/" + scenesToUpdate.length + " (" + _sceneObjects.length + " total)");
					scene.update(true);
				});
				if (scenesToUpdate.length === 0 && _options.loglevel >= 3) {
					log(3, "updating 0 Scenes (nothing added to controller)");
				}
			}
		};

		/**
		 * Initializes rAF callback
		 * @private
		 */
		var debounceUpdate = function () {
			_updateTimeout = _util.rAF(updateScenes);
		};

		/**
		 * Handles Container changes
		 * @private
		 */
		var onChange = function (e) {
			log(3, "event fired causing an update:", e.type);
			if (e.type == "resize") {
				// resize
				_viewPortSize = getViewportSize();
				_scrollDirection = SCROLL_DIRECTION_PAUSED;
			}
			// schedule update
			if (_updateScenesOnNextCycle !== true) {
				_updateScenesOnNextCycle = true;
				debounceUpdate();
			}
		};

		var refresh = function () {
			if (!_isDocument) {
				// simulate resize event. Only works for viewport relevant param (performance)
				if (_viewPortSize != getViewportSize()) {
					var resizeEvent;
					try {
						resizeEvent = new Event('resize', {
							bubbles: false,
							cancelable: false
						});
					} catch (e) { // stupid IE
						resizeEvent = document.createEvent("Event");
						resizeEvent.initEvent("resize", false, false);
					}
					_options.container.dispatchEvent(resizeEvent);
				}
			}
			_sceneObjects.forEach(function (scene, index) { // refresh all scenes
				scene.refresh();
			});
			scheduleRefresh();
		};

		/**
		 * Send a debug message to the console.
		 * provided publicly with _log for plugins
		 * @private
		 *
		 * @param {number} loglevel - The loglevel required to initiate output for the message.
		 * @param {...mixed} output - One or more variables that should be passed to the console.
		 */
		var log = this._log = function (loglevel, output) {
			if (_options.loglevel >= loglevel) {
				Array.prototype.splice.call(arguments, 1, 0, "(" + NAMESPACE + ") ->");
				_util.log.apply(window, arguments);
			}
		};
		// for scenes we have getters for each option, but for the controller we don't, so we need to make it available externally for plugins
		this._options = _options;

		/**
		 * Sort scenes in ascending order of their start offset.
		 * @private
		 *
		 * @param {array} ScenesArray - an array of ScrollMagic Scenes that should be sorted
		 * @return {array} The sorted array of Scenes.
		 */
		var sortScenes = function (ScenesArray) {
			if (ScenesArray.length <= 1) {
				return ScenesArray;
			} else {
				var scenes = ScenesArray.slice(0);
				scenes.sort(function (a, b) {
					return a.scrollOffset() > b.scrollOffset() ? 1 : -1;
				});
				return scenes;
			}
		};

		/**
		 * ----------------------------------------------------------------
		 * public functions
		 * ----------------------------------------------------------------
		 */

		/**
		 * Add one ore more scene(s) to the controller.  
		 * This is the equivalent to `Scene.addTo(controller)`.
		 * @public
		 * @example
		 * // with a previously defined scene
		 * controller.addScene(scene);
		 *
		 * // with a newly created scene.
		 * controller.addScene(new ScrollMagic.Scene({duration : 0}));
		 *
		 * // adding multiple scenes
		 * controller.addScene([scene, scene2, new ScrollMagic.Scene({duration : 0})]);
		 *
		 * @param {(ScrollMagic.Scene|array)} newScene - ScrollMagic Scene or Array of Scenes to be added to the controller.
		 * @return {Controller} Parent object for chaining.
		 */
		this.addScene = function (newScene) {
			if (_util.type.Array(newScene)) {
				newScene.forEach(function (scene, index) {
					Controller.addScene(scene);
				});
			} else if (newScene instanceof ScrollMagic.Scene) {
				if (newScene.controller() !== Controller) {
					newScene.addTo(Controller);
				} else if (_sceneObjects.indexOf(newScene) < 0) {
					// new scene
					_sceneObjects.push(newScene); // add to array
					_sceneObjects = sortScenes(_sceneObjects); // sort
					newScene.on("shift.controller_sort", function () { // resort whenever scene moves
						_sceneObjects = sortScenes(_sceneObjects);
					});
					// insert Global defaults.
					for (var key in _options.globalSceneOptions) {
						if (newScene[key]) {
							newScene[key].call(newScene, _options.globalSceneOptions[key]);
						}
					}
					log(3, "adding Scene (now " + _sceneObjects.length + " total)");
				}
			} else {
				log(1, "ERROR: invalid argument supplied for '.addScene()'");
			}
			return Controller;
		};

		/**
		 * Remove one ore more scene(s) from the controller.  
		 * This is the equivalent to `Scene.remove()`.
		 * @public
		 * @example
		 * // remove a scene from the controller
		 * controller.removeScene(scene);
		 *
		 * // remove multiple scenes from the controller
		 * controller.removeScene([scene, scene2, scene3]);
		 *
		 * @param {(ScrollMagic.Scene|array)} Scene - ScrollMagic Scene or Array of Scenes to be removed from the controller.
		 * @returns {Controller} Parent object for chaining.
		 */
		this.removeScene = function (Scene) {
			if (_util.type.Array(Scene)) {
				Scene.forEach(function (scene, index) {
					Controller.removeScene(scene);
				});
			} else {
				var index = _sceneObjects.indexOf(Scene);
				if (index > -1) {
					Scene.off("shift.controller_sort");
					_sceneObjects.splice(index, 1);
					log(3, "removing Scene (now " + _sceneObjects.length + " left)");
					Scene.remove();
				}
			}
			return Controller;
		};

		/**
	 * Update one ore more scene(s) according to the scroll position of the container.  
	 * This is the equivalent to `Scene.update()`.  
	 * The update method calculates the scene's start and end position (based on the trigger element, trigger hook, duration and offset) and checks it against the current scroll position of the container.  
	 * It then updates the current scene state accordingly (or does nothing, if the state is already correct) – Pins will be set to their correct position and tweens will be updated to their correct progress.  
	 * _**Note:** This method gets called constantly whenever Controller detects a change. The only application for you is if you change something outside of the realm of ScrollMagic, like moving the trigger or changing tween parameters._
	 * @public
	 * @example
	 * // update a specific scene on next cycle
 	 * controller.updateScene(scene);
 	 *
	 * // update a specific scene immediately
	 * controller.updateScene(scene, true);
 	 *
	 * // update multiple scenes scene on next cycle
	 * controller.updateScene([scene1, scene2, scene3]);
	 *
	 * @param {ScrollMagic.Scene} Scene - ScrollMagic Scene or Array of Scenes that is/are supposed to be updated.
	 * @param {boolean} [immediately=false] - If `true` the update will be instant, if `false` it will wait until next update cycle.  
	 										  This is useful when changing multiple properties of the scene - this way it will only be updated once all new properties are set (updateScenes).
	 * @return {Controller} Parent object for chaining.
	 */
		this.updateScene = function (Scene, immediately) {
			if (_util.type.Array(Scene)) {
				Scene.forEach(function (scene, index) {
					Controller.updateScene(scene, immediately);
				});
			} else {
				if (immediately) {
					Scene.update(true);
				} else if (_updateScenesOnNextCycle !== true && Scene instanceof ScrollMagic.Scene) { // if _updateScenesOnNextCycle is true, all connected scenes are already scheduled for update
					// prep array for next update cycle
					_updateScenesOnNextCycle = _updateScenesOnNextCycle || [];
					if (_updateScenesOnNextCycle.indexOf(Scene) == -1) {
						_updateScenesOnNextCycle.push(Scene);
					}
					_updateScenesOnNextCycle = sortScenes(_updateScenesOnNextCycle); // sort
					debounceUpdate();
				}
			}
			return Controller;
		};

		/**
		 * Updates the controller params and calls updateScene on every scene, that is attached to the controller.  
		 * See `Controller.updateScene()` for more information about what this means.  
		 * In most cases you will not need this function, as it is called constantly, whenever ScrollMagic detects a state change event, like resize or scroll.  
		 * The only application for this method is when ScrollMagic fails to detect these events.  
		 * One application is with some external scroll libraries (like iScroll) that move an internal container to a negative offset instead of actually scrolling. In this case the update on the controller needs to be called whenever the child container's position changes.
		 * For this case there will also be the need to provide a custom function to calculate the correct scroll position. See `Controller.scrollPos()` for details.
		 * @public
		 * @example
		 * // update the controller on next cycle (saves performance due to elimination of redundant updates)
		 * controller.update();
		 *
		 * // update the controller immediately
		 * controller.update(true);
		 *
		 * @param {boolean} [immediately=false] - If `true` the update will be instant, if `false` it will wait until next update cycle (better performance)
		 * @return {Controller} Parent object for chaining.
		 */
		this.update = function (immediately) {
			onChange({
				type: "resize"
			}); // will update size and set _updateScenesOnNextCycle to true
			if (immediately) {
				updateScenes();
			}
			return Controller;
		};

		/**
		 * Scroll to a numeric scroll offset, a DOM element, the start of a scene or provide an alternate method for scrolling.  
		 * For vertical controllers it will change the top scroll offset and for horizontal applications it will change the left offset.
		 * @public
		 *
		 * @since 1.1.0
		 * @example
		 * // scroll to an offset of 100
		 * controller.scrollTo(100);
		 *
		 * // scroll to a DOM element
		 * controller.scrollTo("#anchor");
		 *
		 * // scroll to the beginning of a scene
		 * var scene = new ScrollMagic.Scene({offset: 200});
		 * controller.scrollTo(scene);
		 *
		 * // define a new scroll position modification function (jQuery animate instead of jump)
		 * controller.scrollTo(function (newScrollPos) {
		 *	$("html, body").animate({scrollTop: newScrollPos});
		 * });
		 * controller.scrollTo(100); // call as usual, but the new function will be used instead
		 *
		 * // define a new scroll function with an additional parameter
		 * controller.scrollTo(function (newScrollPos, message) {
		 *  console.log(message);
		 *	$(this).animate({scrollTop: newScrollPos});
		 * });
		 * // call as usual, but supply an extra parameter to the defined custom function
		 * controller.scrollTo(100, "my message");
		 *
		 * // define a new scroll function with an additional parameter containing multiple variables
		 * controller.scrollTo(function (newScrollPos, options) {
		 *  someGlobalVar = options.a + options.b;
		 *	$(this).animate({scrollTop: newScrollPos});
		 * });
		 * // call as usual, but supply an extra parameter containing multiple options
		 * controller.scrollTo(100, {a: 1, b: 2});
		 *
		 * // define a new scroll function with a callback supplied as an additional parameter
		 * controller.scrollTo(function (newScrollPos, callback) {
		 *	$(this).animate({scrollTop: newScrollPos}, 400, "swing", callback);
		 * });
		 * // call as usual, but supply an extra parameter, which is used as a callback in the previously defined custom scroll function
		 * controller.scrollTo(100, function() {
		 *	console.log("scroll has finished.");
		 * });
		 *
		 * @param {mixed} scrollTarget - The supplied argument can be one of these types:
		 * 1. `number` -> The container will scroll to this new scroll offset.
		 * 2. `string` or `object` -> Can be a selector or a DOM object.  
		 *  The container will scroll to the position of this element.
		 * 3. `ScrollMagic Scene` -> The container will scroll to the start of this scene.
		 * 4. `function` -> This function will be used for future scroll position modifications.  
		 *  This provides a way for you to change the behaviour of scrolling and adding new behaviour like animation. The function receives the new scroll position as a parameter and a reference to the container element using `this`.  
		 *  It may also optionally receive an optional additional parameter (see below)  
		 *  _**NOTE:**  
		 *  All other options will still work as expected, using the new function to scroll._
		 * @param {mixed} [additionalParameter] - If a custom scroll function was defined (see above 4.), you may want to supply additional parameters to it, when calling it. You can do this using this parameter – see examples for details. Please note, that this parameter will have no effect, if you use the default scrolling function.
		 * @returns {Controller} Parent object for chaining.
		 */
		this.scrollTo = function (scrollTarget, additionalParameter) {
			if (_util.type.Number(scrollTarget)) { // excecute
				setScrollPos.call(_options.container, scrollTarget, additionalParameter);
			} else if (scrollTarget instanceof ScrollMagic.Scene) { // scroll to scene
				if (scrollTarget.controller() === Controller) { // check if the controller is associated with this scene
					Controller.scrollTo(scrollTarget.scrollOffset(), additionalParameter);
				} else {
					log(2, "scrollTo(): The supplied scene does not belong to this controller. Scroll cancelled.", scrollTarget);
				}
			} else if (_util.type.Function(scrollTarget)) { // assign new scroll function
				setScrollPos = scrollTarget;
			} else { // scroll to element
				var elem = _util.get.elements(scrollTarget)[0];
				if (elem) {
					// if parent is pin spacer, use spacer position instead so correct start position is returned for pinned elements.
					while (elem.parentNode.hasAttribute(PIN_SPACER_ATTRIBUTE)) {
						elem = elem.parentNode;
					}

					var
						param = _options.vertical ? "top" : "left", // which param is of interest ?
						containerOffset = _util.get.offset(_options.container), // container position is needed because element offset is returned in relation to document, not in relation to container.
						elementOffset = _util.get.offset(elem);

					if (!_isDocument) { // container is not the document root, so substract scroll Position to get correct trigger element position relative to scrollcontent
						containerOffset[param] -= Controller.scrollPos();
					}

					Controller.scrollTo(elementOffset[param] - containerOffset[param], additionalParameter);
				} else {
					log(2, "scrollTo(): The supplied argument is invalid. Scroll cancelled.", scrollTarget);
				}
			}
			return Controller;
		};

		/**
		 * **Get** the current scrollPosition or **Set** a new method to calculate it.  
		 * -> **GET**:
		 * When used as a getter this function will return the current scroll position.  
		 * To get a cached value use Controller.info("scrollPos"), which will be updated in the update cycle.  
		 * For vertical controllers it will return the top scroll offset and for horizontal applications it will return the left offset.
		 *
		 * -> **SET**:
		 * When used as a setter this method prodes a way to permanently overwrite the controller's scroll position calculation.  
		 * A typical usecase is when the scroll position is not reflected by the containers scrollTop or scrollLeft values, but for example by the inner offset of a child container.  
		 * Moving a child container inside a parent is a commonly used method for several scrolling frameworks, including iScroll.  
		 * By providing an alternate calculation function you can make sure ScrollMagic receives the correct scroll position.  
		 * Please also bear in mind that your function should return y values for vertical scrolls an x for horizontals.
		 *
		 * To change the current scroll position please use `Controller.scrollTo()`.
		 * @public
		 *
		 * @example
		 * // get the current scroll Position
		 * var scrollPos = controller.scrollPos();
		 *
		 * // set a new scroll position calculation method
		 * controller.scrollPos(function () {
		 *	return this.info("vertical") ? -mychildcontainer.y : -mychildcontainer.x
		 * });
		 *
		 * @param {function} [scrollPosMethod] - The function to be used for the scroll position calculation of the container.
		 * @returns {(number|Controller)} Current scroll position or parent object for chaining.
		 */
		this.scrollPos = function (scrollPosMethod) {
			if (!arguments.length) { // get
				return getScrollPos.call(Controller);
			} else { // set
				if (_util.type.Function(scrollPosMethod)) {
					getScrollPos = scrollPosMethod;
				} else {
					log(2, "Provided value for method 'scrollPos' is not a function. To change the current scroll position use 'scrollTo()'.");
				}
			}
			return Controller;
		};

		/**
		 * **Get** all infos or one in particular about the controller.
		 * @public
		 * @example
		 * // returns the current scroll position (number)
		 * var scrollPos = controller.info("scrollPos");
		 *
		 * // returns all infos as an object
		 * var infos = controller.info();
		 *
		 * @param {string} [about] - If passed only this info will be returned instead of an object containing all.  
		 							 Valid options are:
		 							 ** `"size"` => the current viewport size of the container
		 							 ** `"vertical"` => true if vertical scrolling, otherwise false
		 							 ** `"scrollPos"` => the current scroll position
		 							 ** `"scrollDirection"` => the last known direction of the scroll
		 							 ** `"container"` => the container element
		 							 ** `"isDocument"` => true if container element is the document.
		 * @returns {(mixed|object)} The requested info(s).
		 */
		this.info = function (about) {
			var values = {
				size: _viewPortSize, // contains height or width (in regard to orientation);
				vertical: _options.vertical,
				scrollPos: _scrollPos,
				scrollDirection: _scrollDirection,
				container: _options.container,
				isDocument: _isDocument
			};
			if (!arguments.length) { // get all as an object
				return values;
			} else if (values[about] !== undefined) {
				return values[about];
			} else {
				log(1, "ERROR: option \"" + about + "\" is not available");
				return;
			}
		};

		/**
		 * **Get** or **Set** the current loglevel option value.
		 * @public
		 *
		 * @example
		 * // get the current value
		 * var loglevel = controller.loglevel();
		 *
		 * // set a new value
		 * controller.loglevel(3);
		 *
		 * @param {number} [newLoglevel] - The new loglevel setting of the Controller. `[0-3]`
		 * @returns {(number|Controller)} Current loglevel or parent object for chaining.
		 */
		this.loglevel = function (newLoglevel) {
			if (!arguments.length) { // get
				return _options.loglevel;
			} else if (_options.loglevel != newLoglevel) { // set
				_options.loglevel = newLoglevel;
			}
			return Controller;
		};

		/**
		 * **Get** or **Set** the current enabled state of the controller.  
		 * This can be used to disable all Scenes connected to the controller without destroying or removing them.
		 * @public
		 *
		 * @example
		 * // get the current value
		 * var enabled = controller.enabled();
		 *
		 * // disable the controller
		 * controller.enabled(false);
		 *
		 * @param {boolean} [newState] - The new enabled state of the controller `true` or `false`.
		 * @returns {(boolean|Controller)} Current enabled state or parent object for chaining.
		 */
		this.enabled = function (newState) {
			if (!arguments.length) { // get
				return _enabled;
			} else if (_enabled != newState) { // set
				_enabled = !!newState;
				Controller.updateScene(_sceneObjects, true);
			}
			return Controller;
		};

		/**
		 * Destroy the Controller, all Scenes and everything.
		 * @public
		 *
		 * @example
		 * // without resetting the scenes
		 * controller = controller.destroy();
		 *
		 * // with scene reset
		 * controller = controller.destroy(true);
		 *
		 * @param {boolean} [resetScenes=false] - If `true` the pins and tweens (if existent) of all scenes will be reset.
		 * @returns {null} Null to unset handler variables.
		 */
		this.destroy = function (resetScenes) {
			window.clearTimeout(_refreshTimeout);
			var i = _sceneObjects.length;
			while (i--) {
				_sceneObjects[i].destroy(resetScenes);
			}
			_options.container.removeEventListener("resize", onChange);
			_options.container.removeEventListener("scroll", onChange);
			_util.cAF(_updateTimeout);
			log(3, "destroyed " + NAMESPACE + " (reset: " + (resetScenes ? "true" : "false") + ")");
			return null;
		};

		// INIT
		construct();
		return Controller;
	};

	// store pagewide controller options
	var CONTROLLER_OPTIONS = {
		defaults: {
			container: window,
			vertical: true,
			globalSceneOptions: {},
			loglevel: 2,
			refreshInterval: 100
		}
	};
	/*
	 * method used to add an option to ScrollMagic Scenes.
	 */
	ScrollMagic.Controller.addOption = function (name, defaultValue) {
		CONTROLLER_OPTIONS.defaults[name] = defaultValue;
	};
	// instance extension function for plugins
	ScrollMagic.Controller.extend = function (extension) {
		var oldClass = this;
		ScrollMagic.Controller = function () {
			oldClass.apply(this, arguments);
			this.$super = _util.extend({}, this); // copy parent state
			return extension.apply(this, arguments) || this;
		};
		_util.extend(ScrollMagic.Controller, oldClass); // copy properties
		ScrollMagic.Controller.prototype = oldClass.prototype; // copy prototype
		ScrollMagic.Controller.prototype.constructor = ScrollMagic.Controller; // restore constructor
	};


	/**
	 * A Scene defines where the controller should react and how.
	 *
	 * @class
	 *
	 * @example
	 * // create a standard scene and add it to a controller
	 * new ScrollMagic.Scene()
	 *		.addTo(controller);
	 *
	 * // create a scene with custom options and assign a handler to it.
	 * var scene = new ScrollMagic.Scene({
	 * 		duration: 100,
	 *		offset: 200,
	 *		triggerHook: "onEnter",
	 *		reverse: false
	 * });
	 *
	 * @param {object} [options] - Options for the Scene. The options can be updated at any time.  
	 							   Instead of setting the options for each scene individually you can also set them globally in the controller as the controllers `globalSceneOptions` option. The object accepts the same properties as the ones below.  
	 							   When a scene is added to the controller the options defined using the Scene constructor will be overwritten by those set in `globalSceneOptions`.
	 * @param {(number|string|function)} [options.duration=0] - The duration of the scene. 
	 					Please see `Scene.duration()` for details.
	 * @param {number} [options.offset=0] - Offset Value for the Trigger Position. If no triggerElement is defined this will be the scroll distance from the start of the page, after which the scene will start.
	 * @param {(string|object)} [options.triggerElement=null] - Selector or DOM object that defines the start of the scene. If undefined the scene will start right at the start of the page (unless an offset is set).
	 * @param {(number|string)} [options.triggerHook="onCenter"] - Can be a number between 0 and 1 defining the position of the trigger Hook in relation to the viewport.  
	 															  Can also be defined using a string:
	 															  ** `"onEnter"` => `1`
	 															  ** `"onCenter"` => `0.5`
	 															  ** `"onLeave"` => `0`
	 * @param {boolean} [options.reverse=true] - Should the scene reverse, when scrolling up?
	 * @param {number} [options.loglevel=2] - Loglevel for debugging. Note that logging is disabled in the minified version of ScrollMagic.
	 										  ** `0` => silent
	 										  ** `1` => errors
	 										  ** `2` => errors, warnings
	 										  ** `3` => errors, warnings, debuginfo
	 * 
	 */
	ScrollMagic.Scene = function (options) {

		/*
		 * ----------------------------------------------------------------
		 * settings
		 * ----------------------------------------------------------------
		 */

		var
			NAMESPACE = 'ScrollMagic.Scene',
			SCENE_STATE_BEFORE = 'BEFORE',
			SCENE_STATE_DURING = 'DURING',
			SCENE_STATE_AFTER = 'AFTER',
			DEFAULT_OPTIONS = SCENE_OPTIONS.defaults;

		/*
		 * ----------------------------------------------------------------
		 * private vars
		 * ----------------------------------------------------------------
		 */

		var
			Scene = this,
			_options = _util.extend({}, DEFAULT_OPTIONS, options),
			_state = SCENE_STATE_BEFORE,
			_progress = 0,
			_scrollOffset = {
				start: 0,
				end: 0
			}, // reflects the controllers's scroll position for the start and end of the scene respectively
			_triggerPos = 0,
			_enabled = true,
			_durationUpdateMethod,
			_controller;

		/**
		 * Internal constructor function of the ScrollMagic Scene
		 * @private
		 */
		var construct = function () {
			for (var key in _options) { // check supplied options
				if (!DEFAULT_OPTIONS.hasOwnProperty(key)) {
					log(2, "WARNING: Unknown option \"" + key + "\"");
					delete _options[key];
				}
			}
			// add getters/setters for all possible options
			for (var optionName in DEFAULT_OPTIONS) {
				addSceneOption(optionName);
			}
			// validate all options
			validateOption();
		};

		/*
		 * ----------------------------------------------------------------
		 * Event Management
		 * ----------------------------------------------------------------
		 */

		var _listeners = {};
		/**
		 * Scene start event.  
		 * Fires whenever the scroll position its the starting point of the scene.  
		 * It will also fire when scrolling back up going over the start position of the scene. If you want something to happen only when scrolling down/right, use the scrollDirection parameter passed to the callback.
		 *
		 * For details on this event and the order in which it is fired, please review the {@link Scene.progress} method.
		 *
		 * @event ScrollMagic.Scene#start
		 *
		 * @example
		 * scene.on("start", function (event) {
		 * 	console.log("Hit start point of scene.");
		 * });
		 *
		 * @property {object} event - The event Object passed to each callback
		 * @property {string} event.type - The name of the event
		 * @property {Scene} event.target - The Scene object that triggered this event
		 * @property {number} event.progress - Reflects the current progress of the scene
		 * @property {string} event.state - The current state of the scene `"BEFORE"` or `"DURING"`
		 * @property {string} event.scrollDirection - Indicates which way we are scrolling `"PAUSED"`, `"FORWARD"` or `"REVERSE"`
		 */
		/**
		 * Scene end event.  
		 * Fires whenever the scroll position its the ending point of the scene.  
		 * It will also fire when scrolling back up from after the scene and going over its end position. If you want something to happen only when scrolling down/right, use the scrollDirection parameter passed to the callback.
		 *
		 * For details on this event and the order in which it is fired, please review the {@link Scene.progress} method.
		 *
		 * @event ScrollMagic.Scene#end
		 *
		 * @example
		 * scene.on("end", function (event) {
		 * 	console.log("Hit end point of scene.");
		 * });
		 *
		 * @property {object} event - The event Object passed to each callback
		 * @property {string} event.type - The name of the event
		 * @property {Scene} event.target - The Scene object that triggered this event
		 * @property {number} event.progress - Reflects the current progress of the scene
		 * @property {string} event.state - The current state of the scene `"DURING"` or `"AFTER"`
		 * @property {string} event.scrollDirection - Indicates which way we are scrolling `"PAUSED"`, `"FORWARD"` or `"REVERSE"`
		 */
		/**
		 * Scene enter event.  
		 * Fires whenever the scene enters the "DURING" state.  
		 * Keep in mind that it doesn't matter if the scene plays forward or backward: This event always fires when the scene enters its active scroll timeframe, regardless of the scroll-direction.
		 *
		 * For details on this event and the order in which it is fired, please review the {@link Scene.progress} method.
		 *
		 * @event ScrollMagic.Scene#enter
		 *
		 * @example
		 * scene.on("enter", function (event) {
		 * 	console.log("Scene entered.");
		 * });
		 *
		 * @property {object} event - The event Object passed to each callback
		 * @property {string} event.type - The name of the event
		 * @property {Scene} event.target - The Scene object that triggered this event
		 * @property {number} event.progress - Reflects the current progress of the scene
		 * @property {string} event.state - The current state of the scene - always `"DURING"`
		 * @property {string} event.scrollDirection - Indicates which way we are scrolling `"PAUSED"`, `"FORWARD"` or `"REVERSE"`
		 */
		/**
		 * Scene leave event.  
		 * Fires whenever the scene's state goes from "DURING" to either "BEFORE" or "AFTER".  
		 * Keep in mind that it doesn't matter if the scene plays forward or backward: This event always fires when the scene leaves its active scroll timeframe, regardless of the scroll-direction.
		 *
		 * For details on this event and the order in which it is fired, please review the {@link Scene.progress} method.
		 *
		 * @event ScrollMagic.Scene#leave
		 *
		 * @example
		 * scene.on("leave", function (event) {
		 * 	console.log("Scene left.");
		 * });
		 *
		 * @property {object} event - The event Object passed to each callback
		 * @property {string} event.type - The name of the event
		 * @property {Scene} event.target - The Scene object that triggered this event
		 * @property {number} event.progress - Reflects the current progress of the scene
		 * @property {string} event.state - The current state of the scene `"BEFORE"` or `"AFTER"`
		 * @property {string} event.scrollDirection - Indicates which way we are scrolling `"PAUSED"`, `"FORWARD"` or `"REVERSE"`
		 */
		/**
		 * Scene update event.  
		 * Fires whenever the scene is updated (but not necessarily changes the progress).
		 *
		 * @event ScrollMagic.Scene#update
		 *
		 * @example
		 * scene.on("update", function (event) {
		 * 	console.log("Scene updated.");
		 * });
		 *
		 * @property {object} event - The event Object passed to each callback
		 * @property {string} event.type - The name of the event
		 * @property {Scene} event.target - The Scene object that triggered this event
		 * @property {number} event.startPos - The starting position of the scene (in relation to the conainer)
		 * @property {number} event.endPos - The ending position of the scene (in relation to the conainer)
		 * @property {number} event.scrollPos - The current scroll position of the container
		 */
		/**
		 * Scene progress event.  
		 * Fires whenever the progress of the scene changes.
		 *
		 * For details on this event and the order in which it is fired, please review the {@link Scene.progress} method.
		 *
		 * @event ScrollMagic.Scene#progress
		 *
		 * @example
		 * scene.on("progress", function (event) {
		 * 	console.log("Scene progress changed to " + event.progress);
		 * });
		 *
		 * @property {object} event - The event Object passed to each callback
		 * @property {string} event.type - The name of the event
		 * @property {Scene} event.target - The Scene object that triggered this event
		 * @property {number} event.progress - Reflects the current progress of the scene
		 * @property {string} event.state - The current state of the scene `"BEFORE"`, `"DURING"` or `"AFTER"`
		 * @property {string} event.scrollDirection - Indicates which way we are scrolling `"PAUSED"`, `"FORWARD"` or `"REVERSE"`
		 */
		/**
		 * Scene change event.  
		 * Fires whenvever a property of the scene is changed.
		 *
		 * @event ScrollMagic.Scene#change
		 *
		 * @example
		 * scene.on("change", function (event) {
		 * 	console.log("Scene Property \"" + event.what + "\" changed to " + event.newval);
		 * });
		 *
		 * @property {object} event - The event Object passed to each callback
		 * @property {string} event.type - The name of the event
		 * @property {Scene} event.target - The Scene object that triggered this event
		 * @property {string} event.what - Indicates what value has been changed
		 * @property {mixed} event.newval - The new value of the changed property
		 */
		/**
		 * Scene shift event.  
		 * Fires whenvever the start or end **scroll offset** of the scene change.
		 * This happens explicitely, when one of these values change: `offset`, `duration` or `triggerHook`.
		 * It will fire implicitly when the `triggerElement` changes, if the new element has a different position (most cases).
		 * It will also fire implicitly when the size of the container changes and the triggerHook is anything other than `onLeave`.
		 *
		 * @event ScrollMagic.Scene#shift
		 * @since 1.1.0
		 *
		 * @example
		 * scene.on("shift", function (event) {
		 * 	console.log("Scene moved, because the " + event.reason + " has changed.)");
		 * });
		 *
		 * @property {object} event - The event Object passed to each callback
		 * @property {string} event.type - The name of the event
		 * @property {Scene} event.target - The Scene object that triggered this event
		 * @property {string} event.reason - Indicates why the scene has shifted
		 */
		/**
		 * Scene destroy event.  
		 * Fires whenvever the scene is destroyed.
		 * This can be used to tidy up custom behaviour used in events.
		 *
		 * @event ScrollMagic.Scene#destroy
		 * @since 1.1.0
		 *
		 * @example
		 * scene.on("enter", function (event) {
		 *        // add custom action
		 *        $("#my-elem").left("200");
		 *      })
		 *      .on("destroy", function (event) {
		 *        // reset my element to start position
		 *        if (event.reset) {
		 *          $("#my-elem").left("0");
		 *        }
		 *      });
		 *
		 * @property {object} event - The event Object passed to each callback
		 * @property {string} event.type - The name of the event
		 * @property {Scene} event.target - The Scene object that triggered this event
		 * @property {boolean} event.reset - Indicates if the destroy method was called with reset `true` or `false`.
		 */
		/**
		 * Scene add event.  
		 * Fires when the scene is added to a controller.
		 * This is mostly used by plugins to know that change might be due.
		 *
		 * @event ScrollMagic.Scene#add
		 * @since 2.0.0
		 *
		 * @example
		 * scene.on("add", function (event) {
		 * 	console.log('Scene was added to a new controller.');
		 * });
		 *
		 * @property {object} event - The event Object passed to each callback
		 * @property {string} event.type - The name of the event
		 * @property {Scene} event.target - The Scene object that triggered this event
		 * @property {boolean} event.controller - The controller object the scene was added to.
		 */
		/**
		 * Scene remove event.  
		 * Fires when the scene is removed from a controller.
		 * This is mostly used by plugins to know that change might be due.
		 *
		 * @event ScrollMagic.Scene#remove
		 * @since 2.0.0
		 *
		 * @example
		 * scene.on("remove", function (event) {
		 * 	console.log('Scene was removed from its controller.');
		 * });
		 *
		 * @property {object} event - The event Object passed to each callback
		 * @property {string} event.type - The name of the event
		 * @property {Scene} event.target - The Scene object that triggered this event
		 */

		/**
		 * Add one ore more event listener.  
		 * The callback function will be fired at the respective event, and an object containing relevant data will be passed to the callback.
		 * @method ScrollMagic.Scene#on
		 *
		 * @example
		 * function callback (event) {
		 * 		console.log("Event fired! (" + event.type + ")");
		 * }
		 * // add listeners
		 * scene.on("change update progress start end enter leave", callback);
		 *
		 * @param {string} names - The name or names of the event the callback should be attached to.
		 * @param {function} callback - A function that should be executed, when the event is dispatched. An event object will be passed to the callback.
		 * @returns {Scene} Parent object for chaining.
		 */
		this.on = function (names, callback) {
			if (_util.type.Function(callback)) {
				names = names.trim().split(' ');
				names.forEach(function (fullname) {
					var
						nameparts = fullname.split('.'),
						eventname = nameparts[0],
						namespace = nameparts[1];
					if (eventname != "*") { // disallow wildcards
						if (!_listeners[eventname]) {
							_listeners[eventname] = [];
						}
						_listeners[eventname].push({
							namespace: namespace || '',
							callback: callback
						});
					}
				});
			} else {
				log(1, "ERROR when calling '.on()': Supplied callback for '" + names + "' is not a valid function!");
			}
			return Scene;
		};

		/**
		 * Remove one or more event listener.
		 * @method ScrollMagic.Scene#off
		 *
		 * @example
		 * function callback (event) {
		 * 		console.log("Event fired! (" + event.type + ")");
		 * }
		 * // add listeners
		 * scene.on("change update", callback);
		 * // remove listeners
		 * scene.off("change update", callback);
		 *
		 * @param {string} names - The name or names of the event that should be removed.
		 * @param {function} [callback] - A specific callback function that should be removed. If none is passed all callbacks to the event listener will be removed.
		 * @returns {Scene} Parent object for chaining.
		 */
		this.off = function (names, callback) {
			if (!names) {
				log(1, "ERROR: Invalid event name supplied.");
				return Scene;
			}
			names = names.trim().split(' ');
			names.forEach(function (fullname, key) {
				var
					nameparts = fullname.split('.'),
					eventname = nameparts[0],
					namespace = nameparts[1] || '',
					removeList = eventname === '*' ? Object.keys(_listeners) : [eventname];
				removeList.forEach(function (remove) {
					var
						list = _listeners[remove] || [],
						i = list.length;
					while (i--) {
						var listener = list[i];
						if (listener && (namespace === listener.namespace || namespace === '*') && (!callback || callback == listener.callback)) {
							list.splice(i, 1);
						}
					}
					if (!list.length) {
						delete _listeners[remove];
					}
				});
			});
			return Scene;
		};

		/**
		 * Trigger an event.
		 * @method ScrollMagic.Scene#trigger
		 *
		 * @example
		 * this.trigger("change");
		 *
		 * @param {string} name - The name of the event that should be triggered.
		 * @param {object} [vars] - An object containing info that should be passed to the callback.
		 * @returns {Scene} Parent object for chaining.
		 */
		this.trigger = function (name, vars) {
			if (name) {
				var
					nameparts = name.trim().split('.'),
					eventname = nameparts[0],
					namespace = nameparts[1],
					listeners = _listeners[eventname];
				log(3, 'event fired:', eventname, vars ? "->" : '', vars || '');
				if (listeners) {
					listeners.forEach(function (listener, key) {
						if (!namespace || namespace === listener.namespace) {
							listener.callback.call(Scene, new ScrollMagic.Event(eventname, listener.namespace, Scene, vars));
						}
					});
				}
			} else {
				log(1, "ERROR: Invalid event name supplied.");
			}
			return Scene;
		};

		// set event listeners
		Scene
			.on("change.internal", function (e) {
				if (e.what !== "loglevel" && e.what !== "tweenChanges") { // no need for a scene update scene with these options...
					if (e.what === "triggerElement") {
						updateTriggerElementPosition();
					} else if (e.what === "reverse") { // the only property left that may have an impact on the current scene state. Everything else is handled by the shift event.
						Scene.update();
					}
				}
			})
			.on("shift.internal", function (e) {
				updateScrollOffset();
				Scene.update(); // update scene to reflect new position
			});

		/**
		 * Send a debug message to the console.
		 * @private
		 * but provided publicly with _log for plugins
		 *
		 * @param {number} loglevel - The loglevel required to initiate output for the message.
		 * @param {...mixed} output - One or more variables that should be passed to the console.
		 */
		var log = this._log = function (loglevel, output) {
			if (_options.loglevel >= loglevel) {
				Array.prototype.splice.call(arguments, 1, 0, "(" + NAMESPACE + ") ->");
				_util.log.apply(window, arguments);
			}
		};

		/**
		 * Add the scene to a controller.  
		 * This is the equivalent to `Controller.addScene(scene)`.
		 * @method ScrollMagic.Scene#addTo
		 *
		 * @example
		 * // add a scene to a ScrollMagic Controller
		 * scene.addTo(controller);
		 *
		 * @param {ScrollMagic.Controller} controller - The controller to which the scene should be added.
		 * @returns {Scene} Parent object for chaining.
		 */
		this.addTo = function (controller) {
			if (!(controller instanceof ScrollMagic.Controller)) {
				log(1, "ERROR: supplied argument of 'addTo()' is not a valid ScrollMagic Controller");
			} else if (_controller != controller) {
				// new controller
				if (_controller) { // was associated to a different controller before, so remove it...
					_controller.removeScene(Scene);
				}
				_controller = controller;
				validateOption();
				updateDuration(true);
				updateTriggerElementPosition(true);
				updateScrollOffset();
				_controller.info("container").addEventListener('resize', onContainerResize);
				controller.addScene(Scene);
				Scene.trigger("add", {
					controller: _controller
				});
				log(3, "added " + NAMESPACE + " to controller");
				Scene.update();
			}
			return Scene;
		};

		/**
		 * **Get** or **Set** the current enabled state of the scene.  
		 * This can be used to disable this scene without removing or destroying it.
		 * @method ScrollMagic.Scene#enabled
		 *
		 * @example
		 * // get the current value
		 * var enabled = scene.enabled();
		 *
		 * // disable the scene
		 * scene.enabled(false);
		 *
		 * @param {boolean} [newState] - The new enabled state of the scene `true` or `false`.
		 * @returns {(boolean|Scene)} Current enabled state or parent object for chaining.
		 */
		this.enabled = function (newState) {
			if (!arguments.length) { // get
				return _enabled;
			} else if (_enabled != newState) { // set
				_enabled = !!newState;
				Scene.update(true);
			}
			return Scene;
		};

		/**
		 * Remove the scene from the controller.  
		 * This is the equivalent to `Controller.removeScene(scene)`.
		 * The scene will not be updated anymore until you readd it to a controller.
		 * To remove the pin or the tween you need to call removeTween() or removePin() respectively.
		 * @method ScrollMagic.Scene#remove
		 * @example
		 * // remove the scene from its controller
		 * scene.remove();
		 *
		 * @returns {Scene} Parent object for chaining.
		 */
		this.remove = function () {
			if (_controller) {
				_controller.info("container").removeEventListener('resize', onContainerResize);
				var tmpParent = _controller;
				_controller = undefined;
				tmpParent.removeScene(Scene);
				Scene.trigger("remove");
				log(3, "removed " + NAMESPACE + " from controller");
			}
			return Scene;
		};

		/**
		 * Destroy the scene and everything.
		 * @method ScrollMagic.Scene#destroy
		 * @example
		 * // destroy the scene without resetting the pin and tween to their initial positions
		 * scene = scene.destroy();
		 *
		 * // destroy the scene and reset the pin and tween
		 * scene = scene.destroy(true);
		 *
		 * @param {boolean} [reset=false] - If `true` the pin and tween (if existent) will be reset.
		 * @returns {null} Null to unset handler variables.
		 */
		this.destroy = function (reset) {
			Scene.trigger("destroy", {
				reset: reset
			});
			Scene.remove();
			Scene.off("*.*");
			log(3, "destroyed " + NAMESPACE + " (reset: " + (reset ? "true" : "false") + ")");
			return null;
		};


		/**
		 * Updates the Scene to reflect the current state.  
		 * This is the equivalent to `Controller.updateScene(scene, immediately)`.  
		 * The update method calculates the scene's start and end position (based on the trigger element, trigger hook, duration and offset) and checks it against the current scroll position of the container.  
		 * It then updates the current scene state accordingly (or does nothing, if the state is already correct) – Pins will be set to their correct position and tweens will be updated to their correct progress.
		 * This means an update doesn't necessarily result in a progress change. The `progress` event will be fired if the progress has indeed changed between this update and the last.  
		 * _**NOTE:** This method gets called constantly whenever ScrollMagic detects a change. The only application for you is if you change something outside of the realm of ScrollMagic, like moving the trigger or changing tween parameters._
		 * @method ScrollMagic.Scene#update
		 * @example
		 * // update the scene on next tick
		 * scene.update();
		 *
		 * // update the scene immediately
		 * scene.update(true);
		 *
		 * @fires Scene.update
		 *
		 * @param {boolean} [immediately=false] - If `true` the update will be instant, if `false` it will wait until next update cycle (better performance).
		 * @returns {Scene} Parent object for chaining.
		 */
		this.update = function (immediately) {
			if (_controller) {
				if (immediately) {
					if (_controller.enabled() && _enabled) {
						var
							scrollPos = _controller.info("scrollPos"),
							newProgress;

						if (_options.duration > 0) {
							newProgress = (scrollPos - _scrollOffset.start) / (_scrollOffset.end - _scrollOffset.start);
						} else {
							newProgress = scrollPos >= _scrollOffset.start ? 1 : 0;
						}

						Scene.trigger("update", {
							startPos: _scrollOffset.start,
							endPos: _scrollOffset.end,
							scrollPos: scrollPos
						});

						Scene.progress(newProgress);
					} else if (_pin && _state === SCENE_STATE_DURING) {
						updatePinState(true); // unpin in position
					}
				} else {
					_controller.updateScene(Scene, false);
				}
			}
			return Scene;
		};

		/**
		 * Updates dynamic scene variables like the trigger element position or the duration.
		 * This method is automatically called in regular intervals from the controller. See {@link ScrollMagic.Controller} option `refreshInterval`.
		 * 
		 * You can call it to minimize lag, for example when you intentionally change the position of the triggerElement.
		 * If you don't it will simply be updated in the next refresh interval of the container, which is usually sufficient.
		 *
		 * @method ScrollMagic.Scene#refresh
		 * @since 1.1.0
		 * @example
		 * scene = new ScrollMagic.Scene({triggerElement: "#trigger"});
		 * 
		 * // change the position of the trigger
		 * $("#trigger").css("top", 500);
		 * // immediately let the scene know of this change
		 * scene.refresh();
		 *
		 * @fires {@link Scene.shift}, if the trigger element position or the duration changed
		 * @fires {@link Scene.change}, if the duration changed
		 *
		 * @returns {Scene} Parent object for chaining.
		 */
		this.refresh = function () {
			updateDuration();
			updateTriggerElementPosition();
			// update trigger element position
			return Scene;
		};

		/**
		 * **Get** or **Set** the scene's progress.  
		 * Usually it shouldn't be necessary to use this as a setter, as it is set automatically by scene.update().  
		 * The order in which the events are fired depends on the duration of the scene:
		 *  1. Scenes with `duration == 0`:  
		 *  Scenes that have no duration by definition have no ending. Thus the `end` event will never be fired.  
		 *  When the trigger position of the scene is passed the events are always fired in this order:  
		 *  `enter`, `start`, `progress` when scrolling forward  
		 *  and  
		 *  `progress`, `start`, `leave` when scrolling in reverse
		 *  2. Scenes with `duration > 0`:  
		 *  Scenes with a set duration have a defined start and end point.  
		 *  When scrolling past the start position of the scene it will fire these events in this order:  
		 *  `enter`, `start`, `progress`  
		 *  When continuing to scroll and passing the end point it will fire these events:  
		 *  `progress`, `end`, `leave`  
		 *  When reversing through the end point these events are fired:  
		 *  `enter`, `end`, `progress`  
		 *  And when continuing to scroll past the start position in reverse it will fire:  
		 *  `progress`, `start`, `leave`  
		 *  In between start and end the `progress` event will be called constantly, whenever the progress changes.
		 * 
		 * In short:  
		 * `enter` events will always trigger **before** the progress update and `leave` envents will trigger **after** the progress update.  
		 * `start` and `end` will always trigger at their respective position.
		 * 
		 * Please review the event descriptions for details on the events and the event object that is passed to the callback.
		 * 
		 * @method ScrollMagic.Scene#progress
		 * @example
		 * // get the current scene progress
		 * var progress = scene.progress();
		 *
		 * // set new scene progress
		 * scene.progress(0.3);
		 *
		 * @fires {@link Scene.enter}, when used as setter
		 * @fires {@link Scene.start}, when used as setter
		 * @fires {@link Scene.progress}, when used as setter
		 * @fires {@link Scene.end}, when used as setter
		 * @fires {@link Scene.leave}, when used as setter
		 *
		 * @param {number} [progress] - The new progress value of the scene `[0-1]`.
		 * @returns {number} `get` -  Current scene progress.
		 * @returns {Scene} `set` -  Parent object for chaining.
		 */
		this.progress = function (progress) {
			if (!arguments.length) { // get
				return _progress;
			} else { // set
				var
					doUpdate = false,
					oldState = _state,
					scrollDirection = _controller ? _controller.info("scrollDirection") : 'PAUSED',
					reverseOrForward = _options.reverse || progress >= _progress;
				if (_options.duration === 0) {
					// zero duration scenes
					doUpdate = _progress != progress;
					_progress = progress < 1 && reverseOrForward ? 0 : 1;
					_state = _progress === 0 ? SCENE_STATE_BEFORE : SCENE_STATE_DURING;
				} else {
					// scenes with start and end
					if (progress < 0 && _state !== SCENE_STATE_BEFORE && reverseOrForward) {
						// go back to initial state
						_progress = 0;
						_state = SCENE_STATE_BEFORE;
						doUpdate = true;
					} else if (progress >= 0 && progress < 1 && reverseOrForward) {
						_progress = progress;
						_state = SCENE_STATE_DURING;
						doUpdate = true;
					} else if (progress >= 1 && _state !== SCENE_STATE_AFTER) {
						_progress = 1;
						_state = SCENE_STATE_AFTER;
						doUpdate = true;
					} else if (_state === SCENE_STATE_DURING && !reverseOrForward) {
						updatePinState(); // in case we scrolled backwards mid-scene and reverse is disabled => update the pin position, so it doesn't move back as well.
					}
				}
				if (doUpdate) {
					// fire events
					var
						eventVars = {
							progress: _progress,
							state: _state,
							scrollDirection: scrollDirection
						},
						stateChanged = _state != oldState;

					var trigger = function (eventName) { // tmp helper to simplify code
						Scene.trigger(eventName, eventVars);
					};

					if (stateChanged) { // enter events
						if (oldState !== SCENE_STATE_DURING) {
							trigger("enter");
							trigger(oldState === SCENE_STATE_BEFORE ? "start" : "end");
						}
					}
					trigger("progress");
					if (stateChanged) { // leave events
						if (_state !== SCENE_STATE_DURING) {
							trigger(_state === SCENE_STATE_BEFORE ? "start" : "end");
							trigger("leave");
						}
					}
				}

				return Scene;
			}
		};


		/**
		 * Update the start and end scrollOffset of the container.
		 * The positions reflect what the controller's scroll position will be at the start and end respectively.
		 * Is called, when:
		 *   - Scene event "change" is called with: offset, triggerHook, duration 
		 *   - scroll container event "resize" is called
		 *   - the position of the triggerElement changes
		 *   - the controller changes -> addTo()
		 * @private
		 */
		var updateScrollOffset = function () {
			_scrollOffset = {
				start: _triggerPos + _options.offset
			};
			if (_controller && _options.triggerElement) {
				// take away triggerHook portion to get relative to top
				_scrollOffset.start -= _controller.info("size") * _options.triggerHook;
			}
			_scrollOffset.end = _scrollOffset.start + _options.duration;
		};

		/**
		 * Updates the duration if set to a dynamic function.
		 * This method is called when the scene is added to a controller and in regular intervals from the controller through scene.refresh().
		 * 
		 * @fires {@link Scene.change}, if the duration changed
		 * @fires {@link Scene.shift}, if the duration changed
		 *
		 * @param {boolean} [suppressEvents=false] - If true the shift event will be suppressed.
		 * @private
		 */
		var updateDuration = function (suppressEvents) {
			// update duration
			if (_durationUpdateMethod) {
				var varname = "duration";
				if (changeOption(varname, _durationUpdateMethod.call(Scene)) && !suppressEvents) { // set
					Scene.trigger("change", {
						what: varname,
						newval: _options[varname]
					});
					Scene.trigger("shift", {
						reason: varname
					});
				}
			}
		};

		/**
		 * Updates the position of the triggerElement, if present.
		 * This method is called ...
		 *  - ... when the triggerElement is changed
		 *  - ... when the scene is added to a (new) controller
		 *  - ... in regular intervals from the controller through scene.refresh().
		 * 
		 * @fires {@link Scene.shift}, if the position changed
		 *
		 * @param {boolean} [suppressEvents=false] - If true the shift event will be suppressed.
		 * @private
		 */
		var updateTriggerElementPosition = function (suppressEvents) {
			var
				elementPos = 0,
				telem = _options.triggerElement;
			if (_controller && (telem || _triggerPos > 0)) { // either an element exists or was removed and the triggerPos is still > 0
				if (telem) { // there currently a triggerElement set
					if (telem.parentNode) { // check if element is still attached to DOM
						var
							controllerInfo = _controller.info(),
							containerOffset = _util.get.offset(controllerInfo.container), // container position is needed because element offset is returned in relation to document, not in relation to container.
							param = controllerInfo.vertical ? "top" : "left"; // which param is of interest ?

						// if parent is spacer, use spacer position instead so correct start position is returned for pinned elements.
						while (telem.parentNode.hasAttribute(PIN_SPACER_ATTRIBUTE)) {
							telem = telem.parentNode;
						}

						var elementOffset = _util.get.offset(telem);

						if (!controllerInfo.isDocument) { // container is not the document root, so substract scroll Position to get correct trigger element position relative to scrollcontent
							containerOffset[param] -= _controller.scrollPos();
						}

						elementPos = elementOffset[param] - containerOffset[param];

					} else { // there was an element, but it was removed from DOM
						log(2, "WARNING: triggerElement was removed from DOM and will be reset to", undefined);
						Scene.triggerElement(undefined); // unset, so a change event is triggered
					}
				}

				var changed = elementPos != _triggerPos;
				_triggerPos = elementPos;
				if (changed && !suppressEvents) {
					Scene.trigger("shift", {
						reason: "triggerElementPosition"
					});
				}
			}
		};

		/**
		 * Trigger a shift event, when the container is resized and the triggerHook is > 1.
		 * @private
		 */
		var onContainerResize = function (e) {
			if (_options.triggerHook > 0) {
				Scene.trigger("shift", {
					reason: "containerResize"
				});
			}
		};


		var _validate = _util.extend(SCENE_OPTIONS.validate, {
			// validation for duration handled internally for reference to private var _durationMethod
			duration: function (val) {
				if (_util.type.String(val) && val.match(/^(\.|\d)*\d+%$/)) {
					// percentage value
					var perc = parseFloat(val) / 100;
					val = function () {
						return _controller ? _controller.info("size") * perc : 0;
					};
				}
				if (_util.type.Function(val)) {
					// function
					_durationUpdateMethod = val;
					try {
						val = parseFloat(_durationUpdateMethod.call(Scene));
					} catch (e) {
						val = -1; // will cause error below
					}
				}
				// val has to be float
				val = parseFloat(val);
				if (!_util.type.Number(val) || val < 0) {
					if (_durationUpdateMethod) {
						_durationUpdateMethod = undefined;
						throw ["Invalid return value of supplied function for option \"duration\":", val];
					} else {
						throw ["Invalid value for option \"duration\":", val];
					}
				}
				return val;
			}
		});

		/**
		 * Checks the validity of a specific or all options and reset to default if neccessary.
		 * @private
		 */
		var validateOption = function (check) {
			check = arguments.length ? [check] : Object.keys(_validate);
			check.forEach(function (optionName, key) {
				var value;
				if (_validate[optionName]) { // there is a validation method for this option
					try { // validate value
						value = _validate[optionName](_options[optionName]);
					} catch (e) { // validation failed -> reset to default
						value = DEFAULT_OPTIONS[optionName];
						var logMSG = _util.type.String(e) ? [e] : e;
						if (_util.type.Array(logMSG)) {
							logMSG[0] = "ERROR: " + logMSG[0];
							logMSG.unshift(1); // loglevel 1 for error msg
							log.apply(this, logMSG);
						} else {
							log(1, "ERROR: Problem executing validation callback for option '" + optionName + "':", e.message);
						}
					} finally {
						_options[optionName] = value;
					}
				}
			});
		};

		/**
		 * Helper used by the setter/getters for scene options
		 * @private
		 */
		var changeOption = function (varname, newval) {
			var
				changed = false,
				oldval = _options[varname];
			if (_options[varname] != newval) {
				_options[varname] = newval;
				validateOption(varname); // resets to default if necessary
				changed = oldval != _options[varname];
			}
			return changed;
		};

		// generate getters/setters for all options
		var addSceneOption = function (optionName) {
			if (!Scene[optionName]) {
				Scene[optionName] = function (newVal) {
					if (!arguments.length) { // get
						return _options[optionName];
					} else {
						if (optionName === "duration") { // new duration is set, so any previously set function must be unset
							_durationUpdateMethod = undefined;
						}
						if (changeOption(optionName, newVal)) { // set
							Scene.trigger("change", {
								what: optionName,
								newval: _options[optionName]
							});
							if (SCENE_OPTIONS.shifts.indexOf(optionName) > -1) {
								Scene.trigger("shift", {
									reason: optionName
								});
							}
						}
					}
					return Scene;
				};
			}
		};

		/**
		 * **Get** or **Set** the duration option value.
		 *
		 * As a **setter** it accepts three types of parameters:
		 * 1. `number`: Sets the duration of the scene to exactly this amount of pixels.  
		 *   This means the scene will last for exactly this amount of pixels scrolled. Sub-Pixels are also valid.
		 *   A value of `0` means that the scene is 'open end' and no end will be triggered. Pins will never unpin and animations will play independently of scroll progress.
		 * 2. `string`: Always updates the duration relative to parent scroll container.  
		 *   For example `"100%"` will keep the duration always exactly at the inner height of the scroll container.
		 *   When scrolling vertically the width is used for reference respectively.
		 * 3. `function`: The supplied function will be called to return the scene duration.
		 *   This is useful in setups where the duration depends on other elements who might change size. By supplying a function you can return a value instead of updating potentially multiple scene durations.  
		 *   The scene can be referenced inside the callback using `this`.
		 *   _**WARNING:** This is an easy way to kill performance, as the callback will be executed every time `Scene.refresh()` is called, which happens a lot. The interval is defined by the controller (see ScrollMagic.Controller option `refreshInterval`).  
		 *   It's recomended to avoid calculations within the function and use cached variables as return values.  
		 *   This counts double if you use the same function for multiple scenes._
		 *
		 * @method ScrollMagic.Scene#duration
		 * @example
		 * // get the current duration value
		 * var duration = scene.duration();
		 *
		 * // set a new duration
		 * scene.duration(300);
		 *
		 * // set duration responsively to container size
		 * scene.duration("100%");
		 *
		 * // use a function to randomize the duration for some reason.
		 * var durationValueCache;
		 * function durationCallback () {
		 *   return durationValueCache;
		 * }
		 * function updateDuration () {
		 *   durationValueCache = Math.random() * 100;
		 * }
		 * updateDuration(); // set to initial value
		 * scene.duration(durationCallback); // set duration callback
		 *
		 * @fires {@link Scene.change}, when used as setter
		 * @fires {@link Scene.shift}, when used as setter
		 * @param {(number|string|function)} [newDuration] - The new duration setting for the scene.
		 * @returns {number} `get` -  Current scene duration.
		 * @returns {Scene} `set` -  Parent object for chaining.
		 */

		/**
		 * **Get** or **Set** the offset option value.
		 * @method ScrollMagic.Scene#offset
		 * @example
		 * // get the current offset
		 * var offset = scene.offset();
		 *
		 * // set a new offset
		 * scene.offset(100);
		 *
		 * @fires {@link Scene.change}, when used as setter
		 * @fires {@link Scene.shift}, when used as setter
		 * @param {number} [newOffset] - The new offset of the scene.
		 * @returns {number} `get` -  Current scene offset.
		 * @returns {Scene} `set` -  Parent object for chaining.
		 */

		/**
		 * **Get** or **Set** the triggerElement option value.
		 * Does **not** fire `Scene.shift`, because changing the trigger Element doesn't necessarily mean the start position changes. This will be determined in `Scene.refresh()`, which is automatically triggered.
		 * @method ScrollMagic.Scene#triggerElement
		 * @example
		 * // get the current triggerElement
		 * var triggerElement = scene.triggerElement();
		 *
		 * // set a new triggerElement using a selector
		 * scene.triggerElement("#trigger");
		 * // set a new triggerElement using a DOM object
		 * scene.triggerElement(document.getElementById("trigger"));
		 *
		 * @fires {@link Scene.change}, when used as setter
		 * @param {(string|object)} [newTriggerElement] - The new trigger element for the scene.
		 * @returns {(string|object)} `get` -  Current triggerElement.
		 * @returns {Scene} `set` -  Parent object for chaining.
		 */

		/**
		 * **Get** or **Set** the triggerHook option value.
		 * @method ScrollMagic.Scene#triggerHook
		 * @example
		 * // get the current triggerHook value
		 * var triggerHook = scene.triggerHook();
		 *
		 * // set a new triggerHook using a string
		 * scene.triggerHook("onLeave");
		 * // set a new triggerHook using a number
		 * scene.triggerHook(0.7);
		 *
		 * @fires {@link Scene.change}, when used as setter
		 * @fires {@link Scene.shift}, when used as setter
		 * @param {(number|string)} [newTriggerHook] - The new triggerHook of the scene. See {@link Scene} parameter description for value options.
		 * @returns {number} `get` -  Current triggerHook (ALWAYS numerical).
		 * @returns {Scene} `set` -  Parent object for chaining.
		 */

		/**
		 * **Get** or **Set** the reverse option value.
		 * @method ScrollMagic.Scene#reverse
		 * @example
		 * // get the current reverse option
		 * var reverse = scene.reverse();
		 *
		 * // set new reverse option
		 * scene.reverse(false);
		 *
		 * @fires {@link Scene.change}, when used as setter
		 * @param {boolean} [newReverse] - The new reverse setting of the scene.
		 * @returns {boolean} `get` -  Current reverse option value.
		 * @returns {Scene} `set` -  Parent object for chaining.
		 */

		/**
		 * **Get** or **Set** the loglevel option value.
		 * @method ScrollMagic.Scene#loglevel
		 * @example
		 * // get the current loglevel
		 * var loglevel = scene.loglevel();
		 *
		 * // set new loglevel
		 * scene.loglevel(3);
		 *
		 * @fires {@link Scene.change}, when used as setter
		 * @param {number} [newLoglevel] - The new loglevel setting of the scene. `[0-3]`
		 * @returns {number} `get` -  Current loglevel.
		 * @returns {Scene} `set` -  Parent object for chaining.
		 */

		/**
		 * **Get** the associated controller.
		 * @method ScrollMagic.Scene#controller
		 * @example
		 * // get the controller of a scene
		 * var controller = scene.controller();
		 *
		 * @returns {ScrollMagic.Controller} Parent controller or `undefined`
		 */
		this.controller = function () {
			return _controller;
		};

		/**
		 * **Get** the current state.
		 * @method ScrollMagic.Scene#state
		 * @example
		 * // get the current state
		 * var state = scene.state();
		 *
		 * @returns {string} `"BEFORE"`, `"DURING"` or `"AFTER"`
		 */
		this.state = function () {
			return _state;
		};

		/**
		 * **Get** the current scroll offset for the start of the scene.  
		 * Mind, that the scrollOffset is related to the size of the container, if `triggerHook` is bigger than `0` (or `"onLeave"`).  
		 * This means, that resizing the container or changing the `triggerHook` will influence the scene's start offset.
		 * @method ScrollMagic.Scene#scrollOffset
		 * @example
		 * // get the current scroll offset for the start and end of the scene.
		 * var start = scene.scrollOffset();
		 * var end = scene.scrollOffset() + scene.duration();
		 * console.log("the scene starts at", start, "and ends at", end);
		 *
		 * @returns {number} The scroll offset (of the container) at which the scene will trigger. Y value for vertical and X value for horizontal scrolls.
		 */
		this.scrollOffset = function () {
			return _scrollOffset.start;
		};

		/**
		 * **Get** the trigger position of the scene (including the value of the `offset` option).  
		 * @method ScrollMagic.Scene#triggerPosition
		 * @example
		 * // get the scene's trigger position
		 * var triggerPosition = scene.triggerPosition();
		 *
		 * @returns {number} Start position of the scene. Top position value for vertical and left position value for horizontal scrolls.
		 */
		this.triggerPosition = function () {
			var pos = _options.offset; // the offset is the basis
			if (_controller) {
				// get the trigger position
				if (_options.triggerElement) {
					// Element as trigger
					pos += _triggerPos;
				} else {
					// return the height of the triggerHook to start at the beginning
					pos += _controller.info("size") * Scene.triggerHook();
				}
			}
			return pos;
		};


		var
			_pin,
			_pinOptions;

		Scene
			.on("shift.internal", function (e) {
				var durationChanged = e.reason === "duration";
				if ((_state === SCENE_STATE_AFTER && durationChanged) || (_state === SCENE_STATE_DURING && _options.duration === 0)) {
					// if [duration changed after a scene (inside scene progress updates pin position)] or [duration is 0, we are in pin phase and some other value changed].
					updatePinState();
				}
				if (durationChanged) {
					updatePinDimensions();
				}
			})
			.on("progress.internal", function (e) {
				updatePinState();
			})
			.on("add.internal", function (e) {
				updatePinDimensions();
			})
			.on("destroy.internal", function (e) {
				Scene.removePin(e.reset);
			});
		/**
		 * Update the pin state.
		 * @private
		 */
		var updatePinState = function (forceUnpin) {
			if (_pin && _controller) {
				var
					containerInfo = _controller.info(),
					pinTarget = _pinOptions.spacer.firstChild; // may be pin element or another spacer, if cascading pins

				if (!forceUnpin && _state === SCENE_STATE_DURING) { // during scene or if duration is 0 and we are past the trigger
					// pinned state
					if (_util.css(pinTarget, "position") != "fixed") {
						// change state before updating pin spacer (position changes due to fixed collapsing might occur.)
						_util.css(pinTarget, {
							"position": "fixed"
						});
						// update pin spacer
						updatePinDimensions();
					}

					var
						fixedPos = _util.get.offset(_pinOptions.spacer, true), // get viewport position of spacer
						scrollDistance = _options.reverse || _options.duration === 0 ?
						containerInfo.scrollPos - _scrollOffset.start // quicker
						:
						Math.round(_progress * _options.duration * 10) / 10; // if no reverse and during pin the position needs to be recalculated using the progress

					// add scrollDistance
					fixedPos[containerInfo.vertical ? "top" : "left"] += scrollDistance;

					// set new values
					_util.css(_pinOptions.spacer.firstChild, {
						top: fixedPos.top,
						left: fixedPos.left
					});
				} else {
					// unpinned state
					var
						newCSS = {
							position: _pinOptions.inFlow ? "relative" : "absolute",
							top: 0,
							left: 0
						},
						change = _util.css(pinTarget, "position") != newCSS.position;

					if (!_pinOptions.pushFollowers) {
						newCSS[containerInfo.vertical ? "top" : "left"] = _options.duration * _progress;
					} else if (_options.duration > 0) { // only concerns scenes with duration
						if (_state === SCENE_STATE_AFTER && parseFloat(_util.css(_pinOptions.spacer, "padding-top")) === 0) {
							change = true; // if in after state but havent updated spacer yet (jumped past pin)
						} else if (_state === SCENE_STATE_BEFORE && parseFloat(_util.css(_pinOptions.spacer, "padding-bottom")) === 0) { // before
							change = true; // jumped past fixed state upward direction
						}
					}
					// set new values
					_util.css(pinTarget, newCSS);
					if (change) {
						// update pin spacer if state changed
						updatePinDimensions();
					}
				}
			}
		};

		/**
		 * Update the pin spacer and/or element size.
		 * The size of the spacer needs to be updated whenever the duration of the scene changes, if it is to push down following elements.
		 * @private
		 */
		var updatePinDimensions = function () {
			if (_pin && _controller && _pinOptions.inFlow) { // no spacerresize, if original position is absolute
				var
					after = (_state === SCENE_STATE_AFTER),
					before = (_state === SCENE_STATE_BEFORE),
					during = (_state === SCENE_STATE_DURING),
					vertical = _controller.info("vertical"),
					pinTarget = _pinOptions.spacer.firstChild, // usually the pined element but can also be another spacer (cascaded pins)
					marginCollapse = _util.isMarginCollapseType(_util.css(_pinOptions.spacer, "display")),
					css = {};

				// set new size
				// if relsize: spacer -> pin | else: pin -> spacer
				if (_pinOptions.relSize.width || _pinOptions.relSize.autoFullWidth) {
					if (during) {
						_util.css(_pin, {
							"width": _util.get.width(_pinOptions.spacer)
						});
					} else {
						_util.css(_pin, {
							"width": "100%"
						});
					}
				} else {
					// minwidth is needed for cascaded pins.
					css["min-width"] = _util.get.width(vertical ? _pin : pinTarget, true, true);
					css.width = during ? css["min-width"] : "auto";
				}
				if (_pinOptions.relSize.height) {
					if (during) {
						// the only padding the spacer should ever include is the duration (if pushFollowers = true), so we need to substract that.
						_util.css(_pin, {
							"height": _util.get.height(_pinOptions.spacer) - (_pinOptions.pushFollowers ? _options.duration : 0)
						});
					} else {
						_util.css(_pin, {
							"height": "100%"
						});
					}
				} else {
					// margin is only included if it's a cascaded pin to resolve an IE9 bug
					css["min-height"] = _util.get.height(vertical ? pinTarget : _pin, true, !marginCollapse); // needed for cascading pins
					css.height = during ? css["min-height"] : "auto";
				}

				// add space for duration if pushFollowers is true
				if (_pinOptions.pushFollowers) {
					css["padding" + (vertical ? "Top" : "Left")] = _options.duration * _progress;
					css["padding" + (vertical ? "Bottom" : "Right")] = _options.duration * (1 - _progress);
				}
				_util.css(_pinOptions.spacer, css);
			}
		};

		/**
		 * Updates the Pin state (in certain scenarios)
		 * If the controller container is not the document and we are mid-pin-phase scrolling or resizing the main document can result to wrong pin positions.
		 * So this function is called on resize and scroll of the document.
		 * @private
		 */
		var updatePinInContainer = function () {
			if (_controller && _pin && _state === SCENE_STATE_DURING && !_controller.info("isDocument")) {
				updatePinState();
			}
		};

		/**
		 * Updates the Pin spacer size state (in certain scenarios)
		 * If container is resized during pin and relatively sized the size of the pin might need to be updated...
		 * So this function is called on resize of the container.
		 * @private
		 */
		var updateRelativePinSpacer = function () {
			if (_controller && _pin && // well, duh
				_state === SCENE_STATE_DURING && // element in pinned state?
				( // is width or height relatively sized, but not in relation to body? then we need to recalc.
					((_pinOptions.relSize.width || _pinOptions.relSize.autoFullWidth) && _util.get.width(window) != _util.get.width(_pinOptions.spacer.parentNode)) ||
					(_pinOptions.relSize.height && _util.get.height(window) != _util.get.height(_pinOptions.spacer.parentNode))
				)
			) {
				updatePinDimensions();
			}
		};

		/**
		 * Is called, when the mousewhel is used while over a pinned element inside a div container.
		 * If the scene is in fixed state scroll events would be counted towards the body. This forwards the event to the scroll container.
		 * @private
		 */
		var onMousewheelOverPin = function (e) {
			if (_controller && _pin && _state === SCENE_STATE_DURING && !_controller.info("isDocument")) { // in pin state
				e.preventDefault();
				_controller._setScrollPos(_controller.info("scrollPos") - ((e.wheelDelta || e[_controller.info("vertical") ? "wheelDeltaY" : "wheelDeltaX"]) / 3 || -e.detail * 30));
			}
		};

		/**
		 * Pin an element for the duration of the scene.
		 * If the scene duration is 0 the element will only be unpinned, if the user scrolls back past the start position.  
		 * Make sure only one pin is applied to an element at the same time.
		 * An element can be pinned multiple times, but only successively.
		 * _**NOTE:** The option `pushFollowers` has no effect, when the scene duration is 0._
		 * @method ScrollMagic.Scene#setPin
		 * @example
		 * // pin element and push all following elements down by the amount of the pin duration.
		 * scene.setPin("#pin");
		 *
		 * // pin element and keeping all following elements in their place. The pinned element will move past them.
		 * scene.setPin("#pin", {pushFollowers: false});
		 *
		 * @param {(string|object)} element - A Selector targeting an element or a DOM object that is supposed to be pinned.
		 * @param {object} [settings] - settings for the pin
		 * @param {boolean} [settings.pushFollowers=true] - If `true` following elements will be "pushed" down for the duration of the pin, if `false` the pinned element will just scroll past them.  
		 												   Ignored, when duration is `0`.
		 * @param {string} [settings.spacerClass="scrollmagic-pin-spacer"] - Classname of the pin spacer element, which is used to replace the element.
		 *
		 * @returns {Scene} Parent object for chaining.
		 */
		this.setPin = function (element, settings) {
			var
				defaultSettings = {
					pushFollowers: true,
					spacerClass: "scrollmagic-pin-spacer"
				};
			var pushFollowersActivelySet = settings && settings.hasOwnProperty('pushFollowers');
			settings = _util.extend({}, defaultSettings, settings);

			// validate Element
			element = _util.get.elements(element)[0];
			if (!element) {
				log(1, "ERROR calling method 'setPin()': Invalid pin element supplied.");
				return Scene; // cancel
			} else if (_util.css(element, "position") === "fixed") {
				log(1, "ERROR calling method 'setPin()': Pin does not work with elements that are positioned 'fixed'.");
				return Scene; // cancel
			}

			if (_pin) { // preexisting pin?
				if (_pin === element) {
					// same pin we already have -> do nothing
					return Scene; // cancel
				} else {
					// kill old pin
					Scene.removePin();
				}

			}
			_pin = element;

			var
				parentDisplay = _pin.parentNode.style.display,
				boundsParams = ["top", "left", "bottom", "right", "margin", "marginLeft", "marginRight", "marginTop", "marginBottom"];

			_pin.parentNode.style.display = 'none'; // hack start to force css to return stylesheet values instead of calculated px values.
			var
				inFlow = _util.css(_pin, "position") != "absolute",
				pinCSS = _util.css(_pin, boundsParams.concat(["display"])),
				sizeCSS = _util.css(_pin, ["width", "height"]);
			_pin.parentNode.style.display = parentDisplay; // hack end.

			if (!inFlow && settings.pushFollowers) {
				log(2, "WARNING: If the pinned element is positioned absolutely pushFollowers will be disabled.");
				settings.pushFollowers = false;
			}
			window.setTimeout(function () { // wait until all finished, because with responsive duration it will only be set after scene is added to controller
				if (_pin && _options.duration === 0 && pushFollowersActivelySet && settings.pushFollowers) {
					log(2, "WARNING: pushFollowers =", true, "has no effect, when scene duration is 0.");
				}
			}, 0);

			// create spacer and insert
			var
				spacer = _pin.parentNode.insertBefore(document.createElement('div'), _pin),
				spacerCSS = _util.extend(pinCSS, {
					position: inFlow ? "relative" : "absolute",
					boxSizing: "content-box",
					mozBoxSizing: "content-box",
					webkitBoxSizing: "content-box"
				});

			if (!inFlow) { // copy size if positioned absolutely, to work for bottom/right positioned elements.
				_util.extend(spacerCSS, _util.css(_pin, ["width", "height"]));
			}

			_util.css(spacer, spacerCSS);
			spacer.setAttribute(PIN_SPACER_ATTRIBUTE, "");
			_util.addClass(spacer, settings.spacerClass);

			// set the pin Options
			_pinOptions = {
				spacer: spacer,
				relSize: { // save if size is defined using % values. if so, handle spacer resize differently...
					width: sizeCSS.width.slice(-1) === "%",
					height: sizeCSS.height.slice(-1) === "%",
					autoFullWidth: sizeCSS.width === "auto" && inFlow && _util.isMarginCollapseType(pinCSS.display)
				},
				pushFollowers: settings.pushFollowers,
				inFlow: inFlow, // stores if the element takes up space in the document flow
			};

			if (!_pin.___origStyle) {
				_pin.___origStyle = {};
				var
					pinInlineCSS = _pin.style,
					copyStyles = boundsParams.concat(["width", "height", "position", "boxSizing", "mozBoxSizing", "webkitBoxSizing"]);
				copyStyles.forEach(function (val) {
					_pin.___origStyle[val] = pinInlineCSS[val] || "";
				});
			}

			// if relative size, transfer it to spacer and make pin calculate it...
			if (_pinOptions.relSize.width) {
				_util.css(spacer, {
					width: sizeCSS.width
				});
			}
			if (_pinOptions.relSize.height) {
				_util.css(spacer, {
					height: sizeCSS.height
				});
			}

			// now place the pin element inside the spacer	
			spacer.appendChild(_pin);
			// and set new css
			_util.css(_pin, {
				position: inFlow ? "relative" : "absolute",
				margin: "auto",
				top: "auto",
				left: "auto",
				bottom: "auto",
				right: "auto"
			});

			if (_pinOptions.relSize.width || _pinOptions.relSize.autoFullWidth) {
				_util.css(_pin, {
					boxSizing: "border-box",
					mozBoxSizing: "border-box",
					webkitBoxSizing: "border-box"
				});
			}

			// add listener to document to update pin position in case controller is not the document.
			window.addEventListener('scroll', updatePinInContainer);
			window.addEventListener('resize', updatePinInContainer);
			window.addEventListener('resize', updateRelativePinSpacer);
			// add mousewheel listener to catch scrolls over fixed elements
			_pin.addEventListener("mousewheel", onMousewheelOverPin);
			_pin.addEventListener("DOMMouseScroll", onMousewheelOverPin);

			log(3, "added pin");

			// finally update the pin to init
			updatePinState();

			return Scene;
		};

		/**
		 * Remove the pin from the scene.
		 * @method ScrollMagic.Scene#removePin
		 * @example
		 * // remove the pin from the scene without resetting it (the spacer is not removed)
		 * scene.removePin();
		 *
		 * // remove the pin from the scene and reset the pin element to its initial position (spacer is removed)
		 * scene.removePin(true);
		 *
		 * @param {boolean} [reset=false] - If `false` the spacer will not be removed and the element's position will not be reset.
		 * @returns {Scene} Parent object for chaining.
		 */
		this.removePin = function (reset) {
			if (_pin) {
				if (_state === SCENE_STATE_DURING) {
					updatePinState(true); // force unpin at position
				}
				if (reset || !_controller) { // if there's no controller no progress was made anyway...
					var pinTarget = _pinOptions.spacer.firstChild; // usually the pin element, but may be another spacer (cascaded pins)...
					if (pinTarget.hasAttribute(PIN_SPACER_ATTRIBUTE)) { // copy margins to child spacer
						var
							style = _pinOptions.spacer.style,
							values = ["margin", "marginLeft", "marginRight", "marginTop", "marginBottom"],
							margins = {};
						values.forEach(function (val) {
							margins[val] = style[val] || "";
						});
						_util.css(pinTarget, margins);
					}
					_pinOptions.spacer.parentNode.insertBefore(pinTarget, _pinOptions.spacer);
					_pinOptions.spacer.parentNode.removeChild(_pinOptions.spacer);
					if (!_pin.parentNode.hasAttribute(PIN_SPACER_ATTRIBUTE)) { // if it's the last pin for this element -> restore inline styles
						// TODO: only correctly set for first pin (when cascading) - how to fix?
						_util.css(_pin, _pin.___origStyle);
						delete _pin.___origStyle;
					}
				}
				window.removeEventListener('scroll', updatePinInContainer);
				window.removeEventListener('resize', updatePinInContainer);
				window.removeEventListener('resize', updateRelativePinSpacer);
				_pin.removeEventListener("mousewheel", onMousewheelOverPin);
				_pin.removeEventListener("DOMMouseScroll", onMousewheelOverPin);
				_pin = undefined;
				log(3, "removed pin (reset: " + (reset ? "true" : "false") + ")");
			}
			return Scene;
		};


		var
			_cssClasses,
			_cssClassElems = [];

		Scene
			.on("destroy.internal", function (e) {
				Scene.removeClassToggle(e.reset);
			});
		/**
		 * Define a css class modification while the scene is active.  
		 * When the scene triggers the classes will be added to the supplied element and removed, when the scene is over.
		 * If the scene duration is 0 the classes will only be removed if the user scrolls back past the start position.
		 * @method ScrollMagic.Scene#setClassToggle
		 * @example
		 * // add the class 'myclass' to the element with the id 'my-elem' for the duration of the scene
		 * scene.setClassToggle("#my-elem", "myclass");
		 *
		 * // add multiple classes to multiple elements defined by the selector '.classChange'
		 * scene.setClassToggle(".classChange", "class1 class2 class3");
		 *
		 * @param {(string|object)} element - A Selector targeting one or more elements or a DOM object that is supposed to be modified.
		 * @param {string} classes - One or more Classnames (separated by space) that should be added to the element during the scene.
		 *
		 * @returns {Scene} Parent object for chaining.
		 */
		this.setClassToggle = function (element, classes) {
			var elems = _util.get.elements(element);
			if (elems.length === 0 || !_util.type.String(classes)) {
				log(1, "ERROR calling method 'setClassToggle()': Invalid " + (elems.length === 0 ? "element" : "classes") + " supplied.");
				return Scene;
			}
			if (_cssClassElems.length > 0) {
				// remove old ones
				Scene.removeClassToggle();
			}
			_cssClasses = classes;
			_cssClassElems = elems;
			Scene.on("enter.internal_class leave.internal_class", function (e) {
				var toggle = e.type === "enter" ? _util.addClass : _util.removeClass;
				_cssClassElems.forEach(function (elem, key) {
					toggle(elem, _cssClasses);
				});
			});
			return Scene;
		};

		/**
		 * Remove the class binding from the scene.
		 * @method ScrollMagic.Scene#removeClassToggle
		 * @example
		 * // remove class binding from the scene without reset
		 * scene.removeClassToggle();
		 *
		 * // remove class binding and remove the changes it caused
		 * scene.removeClassToggle(true);
		 *
		 * @param {boolean} [reset=false] - If `false` and the classes are currently active, they will remain on the element. If `true` they will be removed.
		 * @returns {Scene} Parent object for chaining.
		 */
		this.removeClassToggle = function (reset) {
			if (reset) {
				_cssClassElems.forEach(function (elem, key) {
					_util.removeClass(elem, _cssClasses);
				});
			}
			Scene.off("start.internal_class end.internal_class");
			_cssClasses = undefined;
			_cssClassElems = [];
			return Scene;
		};

		// INIT
		construct();
		return Scene;
	};

	// store pagewide scene options
	var SCENE_OPTIONS = {
		defaults: {
			duration: 0,
			offset: 0,
			triggerElement: undefined,
			triggerHook: 0.5,
			reverse: true,
			loglevel: 2
		},
		validate: {
			offset: function (val) {
				val = parseFloat(val);
				if (!_util.type.Number(val)) {
					throw ["Invalid value for option \"offset\":", val];
				}
				return val;
			},
			triggerElement: function (val) {
				val = val || undefined;
				if (val) {
					var elem = _util.get.elements(val)[0];
					if (elem && elem.parentNode) {
						val = elem;
					} else {
						throw ["Element defined in option \"triggerElement\" was not found:", val];
					}
				}
				return val;
			},
			triggerHook: function (val) {
				var translate = {
					"onCenter": 0.5,
					"onEnter": 1,
					"onLeave": 0
				};
				if (_util.type.Number(val)) {
					val = Math.max(0, Math.min(parseFloat(val), 1)); //  make sure its betweeen 0 and 1
				} else if (val in translate) {
					val = translate[val];
				} else {
					throw ["Invalid value for option \"triggerHook\": ", val];
				}
				return val;
			},
			reverse: function (val) {
				return !!val; // force boolean
			},
			loglevel: function (val) {
				val = parseInt(val);
				if (!_util.type.Number(val) || val < 0 || val > 3) {
					throw ["Invalid value for option \"loglevel\":", val];
				}
				return val;
			}
		}, // holder for  validation methods. duration validation is handled in 'getters-setters.js'
		shifts: ["duration", "offset", "triggerHook"], // list of options that trigger a `shift` event
	};
	/*
	 * method used to add an option to ScrollMagic Scenes.
	 * TODO: DOC (private for dev)
	 */
	ScrollMagic.Scene.addOption = function (name, defaultValue, validationCallback, shifts) {
		if (!(name in SCENE_OPTIONS.defaults)) {
			SCENE_OPTIONS.defaults[name] = defaultValue;
			SCENE_OPTIONS.validate[name] = validationCallback;
			if (shifts) {
				SCENE_OPTIONS.shifts.push(name);
			}
		} else {
			ScrollMagic._util.log(1, "[static] ScrollMagic.Scene -> Cannot add Scene option '" + name + "', because it already exists.");
		}
	};
	// instance extension function for plugins
	// TODO: DOC (private for dev)
	ScrollMagic.Scene.extend = function (extension) {
		var oldClass = this;
		ScrollMagic.Scene = function () {
			oldClass.apply(this, arguments);
			this.$super = _util.extend({}, this); // copy parent state
			return extension.apply(this, arguments) || this;
		};
		_util.extend(ScrollMagic.Scene, oldClass); // copy properties
		ScrollMagic.Scene.prototype = oldClass.prototype; // copy prototype
		ScrollMagic.Scene.prototype.constructor = ScrollMagic.Scene; // restore constructor
	};



	/**
	 * TODO: DOCS (private for dev)
	 * @class
	 * @private
	 */

	ScrollMagic.Event = function (type, namespace, target, vars) {
		vars = vars || {};
		for (var key in vars) {
			this[key] = vars[key];
		}
		this.type = type;
		this.target = this.currentTarget = target;
		this.namespace = namespace || '';
		this.timeStamp = this.timestamp = Date.now();
		return this;
	};

	/*
	 * TODO: DOCS (private for dev)
	 */

	var _util = ScrollMagic._util = (function (window) {
		var U = {},
			i;

		/**
		 * ------------------------------
		 * internal helpers
		 * ------------------------------
		 */

		// parse float and fall back to 0.
		var floatval = function (number) {
			return parseFloat(number) || 0;
		};
		// get current style IE safe (otherwise IE would return calculated values for 'auto')
		var _getComputedStyle = function (elem) {
			return elem.currentStyle ? elem.currentStyle : window.getComputedStyle(elem);
		};

		// get element dimension (width or height)
		var _dimension = function (which, elem, outer, includeMargin) {
			elem = (elem === document) ? window : elem;
			if (elem === window) {
				includeMargin = false;
			} else if (!_type.DomElement(elem)) {
				return 0;
			}
			which = which.charAt(0).toUpperCase() + which.substr(1).toLowerCase();
			var dimension = (outer ? elem['offset' + which] || elem['outer' + which] : elem['client' + which] || elem['inner' + which]) || 0;
			if (outer && includeMargin) {
				var style = _getComputedStyle(elem);
				dimension += which === 'Height' ? floatval(style.marginTop) + floatval(style.marginBottom) : floatval(style.marginLeft) + floatval(style.marginRight);
			}
			return dimension;
		};
		// converts 'margin-top' into 'marginTop'
		var _camelCase = function (str) {
			return str.replace(/^[^a-z]+([a-z])/g, '$1').replace(/-([a-z])/g, function (g) {
				return g[1].toUpperCase();
			});
		};

		/**
		 * ------------------------------
		 * external helpers
		 * ------------------------------
		 */

		// extend obj – same as jQuery.extend({}, objA, objB)
		U.extend = function (obj) {
			obj = obj || {};
			for (i = 1; i < arguments.length; i++) {
				if (!arguments[i]) {
					continue;
				}
				for (var key in arguments[i]) {
					if (arguments[i].hasOwnProperty(key)) {
						obj[key] = arguments[i][key];
					}
				}
			}
			return obj;
		};

		// check if a css display type results in margin-collapse or not
		U.isMarginCollapseType = function (str) {
			return ["block", "flex", "list-item", "table", "-webkit-box"].indexOf(str) > -1;
		};

		// implementation of requestAnimationFrame
		// based on https://gist.github.com/paulirish/1579671
		var
			lastTime = 0,
			vendors = ['ms', 'moz', 'webkit', 'o'];
		var _requestAnimationFrame = window.requestAnimationFrame;
		var _cancelAnimationFrame = window.cancelAnimationFrame;
		// try vendor prefixes if the above doesn't work
		for (i = 0; !_requestAnimationFrame && i < vendors.length; ++i) {
			_requestAnimationFrame = window[vendors[i] + 'RequestAnimationFrame'];
			_cancelAnimationFrame = window[vendors[i] + 'CancelAnimationFrame'] || window[vendors[i] + 'CancelRequestAnimationFrame'];
		}

		// fallbacks
		if (!_requestAnimationFrame) {
			_requestAnimationFrame = function (callback) {
				var
					currTime = new Date().getTime(),
					timeToCall = Math.max(0, 16 - (currTime - lastTime)),
					id = window.setTimeout(function () {
						callback(currTime + timeToCall);
					}, timeToCall);
				lastTime = currTime + timeToCall;
				return id;
			};
		}
		if (!_cancelAnimationFrame) {
			_cancelAnimationFrame = function (id) {
				window.clearTimeout(id);
			};
		}
		U.rAF = _requestAnimationFrame.bind(window);
		U.cAF = _cancelAnimationFrame.bind(window);

		var
			loglevels = ["error", "warn", "log"],
			console = window.console || {};

		console.log = console.log || function () {}; // no console log, well - do nothing then...
		// make sure methods for all levels exist.
		for (i = 0; i < loglevels.length; i++) {
			var method = loglevels[i];
			if (!console[method]) {
				console[method] = console.log; // prefer .log over nothing
			}
		}
		U.log = function (loglevel) {
			if (loglevel > loglevels.length || loglevel <= 0) loglevel = loglevels.length;
			var now = new Date(),
				time = ("0" + now.getHours()).slice(-2) + ":" + ("0" + now.getMinutes()).slice(-2) + ":" + ("0" + now.getSeconds()).slice(-2) + ":" + ("00" + now.getMilliseconds()).slice(-3),
				method = loglevels[loglevel - 1],
				args = Array.prototype.splice.call(arguments, 1),
				func = Function.prototype.bind.call(console[method], console);
			args.unshift(time);
			func.apply(console, args);
		};

		/**
		 * ------------------------------
		 * type testing
		 * ------------------------------
		 */

		var _type = U.type = function (v) {
			return Object.prototype.toString.call(v).replace(/^\[object (.+)\]$/, "$1").toLowerCase();
		};
		_type.String = function (v) {
			return _type(v) === 'string';
		};
		_type.Function = function (v) {
			return _type(v) === 'function';
		};
		_type.Array = function (v) {
			return Array.isArray(v);
		};
		_type.Number = function (v) {
			return !_type.Array(v) && (v - parseFloat(v) + 1) >= 0;
		};
		_type.DomElement = function (o) {
			return (
				typeof HTMLElement === "object" || typeof HTMLElement === "function" ? o instanceof HTMLElement || o instanceof SVGElement : //DOM2
				o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string"
			);
		};

		/**
		 * ------------------------------
		 * DOM Element info
		 * ------------------------------
		 */
		// always returns a list of matching DOM elements, from a selector, a DOM element or an list of elements or even an array of selectors
		var _get = U.get = {};
		_get.elements = function (selector) {
			var arr = [];
			if (_type.String(selector)) {
				try {
					selector = document.querySelectorAll(selector);
				} catch (e) { // invalid selector
					return arr;
				}
			}
			if (_type(selector) === 'nodelist' || _type.Array(selector) || selector instanceof NodeList) {
				for (var i = 0, ref = arr.length = selector.length; i < ref; i++) { // list of elements
					var elem = selector[i];
					arr[i] = _type.DomElement(elem) ? elem : _get.elements(elem); // if not an element, try to resolve recursively
				}
			} else if (_type.DomElement(selector) || selector === document || selector === window) {
				arr = [selector]; // only the element
			}
			return arr;
		};
		// get scroll top value
		_get.scrollTop = function (elem) {
			return (elem && typeof elem.scrollTop === 'number') ? elem.scrollTop : window.pageYOffset || 0;
		};
		// get scroll left value
		_get.scrollLeft = function (elem) {
			return (elem && typeof elem.scrollLeft === 'number') ? elem.scrollLeft : window.pageXOffset || 0;
		};
		// get element height
		_get.width = function (elem, outer, includeMargin) {
			return _dimension('width', elem, outer, includeMargin);
		};
		// get element width
		_get.height = function (elem, outer, includeMargin) {
			return _dimension('height', elem, outer, includeMargin);
		};

		// get element position (optionally relative to viewport)
		_get.offset = function (elem, relativeToViewport) {
			var offset = {
				top: 0,
				left: 0
			};
			if (elem && elem.getBoundingClientRect) { // check if available
				var rect = elem.getBoundingClientRect();
				offset.top = rect.top;
				offset.left = rect.left;
				if (!relativeToViewport) { // clientRect is by default relative to viewport...
					offset.top += _get.scrollTop();
					offset.left += _get.scrollLeft();
				}
			}
			return offset;
		};

		/**
		 * ------------------------------
		 * DOM Element manipulation
		 * ------------------------------
		 */

		U.addClass = function (elem, classname) {
			if (classname) {
				if (elem.classList)
					elem.classList.add(classname);
				else
					elem.className += ' ' + classname;
			}
		};
		U.removeClass = function (elem, classname) {
			if (classname) {
				if (elem.classList)
					elem.classList.remove(classname);
				else
					elem.className = elem.className.replace(new RegExp('(^|\\b)' + classname.split(' ').join('|') + '(\\b|$)', 'gi'), ' ');
			}
		};
		// if options is string -> returns css value
		// if options is array -> returns object with css value pairs
		// if options is object -> set new css values
		U.css = function (elem, options) {
			if (_type.String(options)) {
				return _getComputedStyle(elem)[_camelCase(options)];
			} else if (_type.Array(options)) {
				var
					obj = {},
					style = _getComputedStyle(elem);
				options.forEach(function (option, key) {
					obj[option] = style[_camelCase(option)];
				});
				return obj;
			} else {
				for (var option in options) {
					var val = options[option];
					if (val == parseFloat(val)) { // assume pixel for seemingly numerical values
						val += 'px';
					}
					elem.style[_camelCase(option)] = val;
				}
			}
		};

		return U;
	}(window || {}));


	ScrollMagic.Scene.prototype.addIndicators = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling addIndicators() due to missing Plugin \'debug.addIndicators\'. Please make sure to include plugins/debug.addIndicators.js');
		return this;
	}
	ScrollMagic.Scene.prototype.removeIndicators = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling removeIndicators() due to missing Plugin \'debug.addIndicators\'. Please make sure to include plugins/debug.addIndicators.js');
		return this;
	}
	ScrollMagic.Scene.prototype.setTween = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling setTween() due to missing Plugin \'animation.gsap\'. Please make sure to include plugins/animation.gsap.js');
		return this;
	}
	ScrollMagic.Scene.prototype.removeTween = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling removeTween() due to missing Plugin \'animation.gsap\'. Please make sure to include plugins/animation.gsap.js');
		return this;
	}
	ScrollMagic.Scene.prototype.setVelocity = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling setVelocity() due to missing Plugin \'animation.velocity\'. Please make sure to include plugins/animation.velocity.js');
		return this;
	}
	ScrollMagic.Scene.prototype.removeVelocity = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling removeVelocity() due to missing Plugin \'animation.velocity\'. Please make sure to include plugins/animation.velocity.js');
		return this;
	}

	return ScrollMagic;
}));
/*
 _ _      _       _
 ___| (_) ___| | __  (_)___
 / __| | |/ __| |/ /  | / __|
 \__ \ | | (__|   < _ | \__ \
 |___/_|_|\___|_|\_(_)/ |___/
 |__/

 Version: 1.8.0
 Author: Ken Wheeler
 Website: http://kenwheeler.github.io
 Docs: http://kenwheeler.github.io/slick
 Repo: http://github.com/kenwheeler/slick
 Issues: http://github.com/kenwheeler/slick/issues

 */
/* global window, document, define, jQuery, setInterval, clearInterval */
;(function(factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        define(['jquery'], factory);
    } else if (typeof exports !== 'undefined') {
        module.exports = factory(require('jquery'));
    } else {
        factory(jQuery);
    }

}(function($) {
    'use strict';
    var Slick = window.Slick || {};

    Slick = (function() {

        var instanceUid = 0;

        function Slick(element, settings) {

            var _ = this, dataSettings;

            _.defaults = {
                accessibility: true,
                adaptiveHeight: false,
                appendArrows: $(element),
                appendDots: $(element),
                arrows: true,
                asNavFor: null,
                prevArrow: '<button class="slick-prev" aria-label="Previous" type="button">Previous</button>',
                nextArrow: '<button class="slick-next" aria-label="Next" type="button">Next</button>',
                autoplay: false,
                autoplaySpeed: 3000,
                centerMode: false,
                centerPadding: '50px',
                cssEase: 'ease',
                customPaging: function(slider, i) {
                    return $('<button type="button" />').text(i + 1);
                },
                dots: false,
                dotsClass: 'slick-dots',
                draggable: true,
                easing: 'linear',
                edgeFriction: 0.35,
                fade: false,
                focusOnSelect: false,
                focusOnChange: false,
                infinite: true,
                initialSlide: 0,
                lazyLoad: 'ondemand',
                mobileFirst: false,
                pauseOnHover: true,
                pauseOnFocus: true,
                pauseOnDotsHover: false,
                respondTo: 'window',
                responsive: null,
                rows: 1,
                rtl: false,
                slide: '',
                slidesPerRow: 1,
                slidesToShow: 1,
                slidesToScroll: 1,
                speed: 500,
                swipe: true,
                swipeToSlide: false,
                touchMove: true,
                touchThreshold: 5,
                useCSS: true,
                useTransform: true,
                variableWidth: false,
                vertical: false,
                verticalSwiping: false,
                waitForAnimate: true,
                zIndex: 1000
            };

            _.initials = {
                animating: false,
                dragging: false,
                autoPlayTimer: null,
                currentDirection: 0,
                currentLeft: null,
                currentSlide: 0,
                direction: 1,
                $dots: null,
                listWidth: null,
                listHeight: null,
                loadIndex: 0,
                $nextArrow: null,
                $prevArrow: null,
                scrolling: false,
                slideCount: null,
                slideWidth: null,
                $slideTrack: null,
                $slides: null,
                sliding: false,
                slideOffset: 0,
                swipeLeft: null,
                swiping: false,
                $list: null,
                touchObject: {},
                transformsEnabled: false,
                unslicked: false
            };

            $.extend(_, _.initials);

            _.activeBreakpoint = null;
            _.animType = null;
            _.animProp = null;
            _.breakpoints = [];
            _.breakpointSettings = [];
            _.cssTransitions = false;
            _.focussed = false;
            _.interrupted = false;
            _.hidden = 'hidden';
            _.paused = true;
            _.positionProp = null;
            _.respondTo = null;
            _.rowCount = 1;
            _.shouldClick = true;
            _.$slider = $(element);
            _.$slidesCache = null;
            _.transformType = null;
            _.transitionType = null;
            _.visibilityChange = 'visibilitychange';
            _.windowWidth = 0;
            _.windowTimer = null;

            dataSettings = $(element).data('slick') || {};

            _.options = $.extend({}, _.defaults, settings, dataSettings);

            _.currentSlide = _.options.initialSlide;

            _.originalSettings = _.options;

            if (typeof document.mozHidden !== 'undefined') {
                _.hidden = 'mozHidden';
                _.visibilityChange = 'mozvisibilitychange';
            } else if (typeof document.webkitHidden !== 'undefined') {
                _.hidden = 'webkitHidden';
                _.visibilityChange = 'webkitvisibilitychange';
            }

            _.autoPlay = $.proxy(_.autoPlay, _);
            _.autoPlayClear = $.proxy(_.autoPlayClear, _);
            _.autoPlayIterator = $.proxy(_.autoPlayIterator, _);
            _.changeSlide = $.proxy(_.changeSlide, _);
            _.clickHandler = $.proxy(_.clickHandler, _);
            _.selectHandler = $.proxy(_.selectHandler, _);
            _.setPosition = $.proxy(_.setPosition, _);
            _.swipeHandler = $.proxy(_.swipeHandler, _);
            _.dragHandler = $.proxy(_.dragHandler, _);
            _.keyHandler = $.proxy(_.keyHandler, _);

            _.instanceUid = instanceUid++;

            // A simple way to check for HTML strings
            // Strict HTML recognition (must start with <)
            // Extracted from jQuery v1.11 source
            _.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/;


            _.registerBreakpoints();
            _.init(true);

        }

        return Slick;

    }());

    Slick.prototype.activateADA = function() {
        var _ = this;

        _.$slideTrack.find('.slick-active').attr({
            'aria-hidden': 'false'
        }).find('a, input, button, select').attr({
            'tabindex': '0'
        });

    };

    Slick.prototype.addSlide = Slick.prototype.slickAdd = function(markup, index, addBefore) {

        var _ = this;

        if (typeof(index) === 'boolean') {
            addBefore = index;
            index = null;
        } else if (index < 0 || (index >= _.slideCount)) {
            return false;
        }

        _.unload();

        if (typeof(index) === 'number') {
            if (index === 0 && _.$slides.length === 0) {
                $(markup).appendTo(_.$slideTrack);
            } else if (addBefore) {
                $(markup).insertBefore(_.$slides.eq(index));
            } else {
                $(markup).insertAfter(_.$slides.eq(index));
            }
        } else {
            if (addBefore === true) {
                $(markup).prependTo(_.$slideTrack);
            } else {
                $(markup).appendTo(_.$slideTrack);
            }
        }

        _.$slides = _.$slideTrack.children(this.options.slide);

        _.$slideTrack.children(this.options.slide).detach();

        _.$slideTrack.append(_.$slides);

        _.$slides.each(function(index, element) {
            $(element).attr('data-slick-index', index);
        });

        _.$slidesCache = _.$slides;

        _.reinit();

    };

    Slick.prototype.animateHeight = function() {
        var _ = this;
        if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
            _.$list.animate({
                height: targetHeight
            }, _.options.speed);
        }
    };

    Slick.prototype.animateSlide = function(targetLeft, callback) {

        var animProps = {},
            _ = this;

        _.animateHeight();

        if (_.options.rtl === true && _.options.vertical === false) {
            targetLeft = -targetLeft;
        }
        if (_.transformsEnabled === false) {
            if (_.options.vertical === false) {
                _.$slideTrack.animate({
                    left: targetLeft
                }, _.options.speed, _.options.easing, callback);
            } else {
                _.$slideTrack.animate({
                    top: targetLeft
                }, _.options.speed, _.options.easing, callback);
            }

        } else {

            if (_.cssTransitions === false) {
                if (_.options.rtl === true) {
                    _.currentLeft = -(_.currentLeft);
                }
                $({
                    animStart: _.currentLeft
                }).animate({
                    animStart: targetLeft
                }, {
                    duration: _.options.speed,
                    easing: _.options.easing,
                    step: function(now) {
                        now = Math.ceil(now);
                        if (_.options.vertical === false) {
                            animProps[_.animType] = 'translate(' +
                                now + 'px, 0px)';
                            _.$slideTrack.css(animProps);
                        } else {
                            animProps[_.animType] = 'translate(0px,' +
                                now + 'px)';
                            _.$slideTrack.css(animProps);
                        }
                    },
                    complete: function() {
                        if (callback) {
                            callback.call();
                        }
                    }
                });

            } else {

                _.applyTransition();
                targetLeft = Math.ceil(targetLeft);

                if (_.options.vertical === false) {
                    animProps[_.animType] = 'translate3d(' + targetLeft + 'px, 0px, 0px)';
                } else {
                    animProps[_.animType] = 'translate3d(0px,' + targetLeft + 'px, 0px)';
                }
                _.$slideTrack.css(animProps);

                if (callback) {
                    setTimeout(function() {

                        _.disableTransition();

                        callback.call();
                    }, _.options.speed);
                }

            }

        }

    };

    Slick.prototype.getNavTarget = function() {

        var _ = this,
            asNavFor = _.options.asNavFor;

        if ( asNavFor && asNavFor !== null ) {
            asNavFor = $(asNavFor).not(_.$slider);
        }

        return asNavFor;

    };

    Slick.prototype.asNavFor = function(index) {

        var _ = this,
            asNavFor = _.getNavTarget();

        if ( asNavFor !== null && typeof asNavFor === 'object' ) {
            asNavFor.each(function() {
                var target = $(this).slick('getSlick');
                if(!target.unslicked) {
                    target.slideHandler(index, true);
                }
            });
        }

    };

    Slick.prototype.applyTransition = function(slide) {

        var _ = this,
            transition = {};

        if (_.options.fade === false) {
            transition[_.transitionType] = _.transformType + ' ' + _.options.speed + 'ms ' + _.options.cssEase;
        } else {
            transition[_.transitionType] = 'opacity ' + _.options.speed + 'ms ' + _.options.cssEase;
        }

        if (_.options.fade === false) {
            _.$slideTrack.css(transition);
        } else {
            _.$slides.eq(slide).css(transition);
        }

    };

    Slick.prototype.autoPlay = function() {

        var _ = this;

        _.autoPlayClear();

        if ( _.slideCount > _.options.slidesToShow ) {
            _.autoPlayTimer = setInterval( _.autoPlayIterator, _.options.autoplaySpeed );
        }

    };

    Slick.prototype.autoPlayClear = function() {

        var _ = this;

        if (_.autoPlayTimer) {
            clearInterval(_.autoPlayTimer);
        }

    };

    Slick.prototype.autoPlayIterator = function() {

        var _ = this,
            slideTo = _.currentSlide + _.options.slidesToScroll;

        if ( !_.paused && !_.interrupted && !_.focussed ) {

            if ( _.options.infinite === false ) {

                if ( _.direction === 1 && ( _.currentSlide + 1 ) === ( _.slideCount - 1 )) {
                    _.direction = 0;
                }

                else if ( _.direction === 0 ) {

                    slideTo = _.currentSlide - _.options.slidesToScroll;

                    if ( _.currentSlide - 1 === 0 ) {
                        _.direction = 1;
                    }

                }

            }

            _.slideHandler( slideTo );

        }

    };

    Slick.prototype.buildArrows = function() {

        var _ = this;

        if (_.options.arrows === true ) {

            _.$prevArrow = $(_.options.prevArrow).addClass('slick-arrow');
            _.$nextArrow = $(_.options.nextArrow).addClass('slick-arrow');

            if( _.slideCount > _.options.slidesToShow ) {

                _.$prevArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');
                _.$nextArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');

                if (_.htmlExpr.test(_.options.prevArrow)) {
                    _.$prevArrow.prependTo(_.options.appendArrows);
                }

                if (_.htmlExpr.test(_.options.nextArrow)) {
                    _.$nextArrow.appendTo(_.options.appendArrows);
                }

                if (_.options.infinite !== true) {
                    _.$prevArrow
                        .addClass('slick-disabled')
                        .attr('aria-disabled', 'true');
                }

            } else {

                _.$prevArrow.add( _.$nextArrow )

                    .addClass('slick-hidden')
                    .attr({
                        'aria-disabled': 'true',
                        'tabindex': '-1'
                    });

            }

        }

    };

    Slick.prototype.buildDots = function() {

        var _ = this,
            i, dot;

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

            _.$slider.addClass('slick-dotted');

            dot = $('<ul />').addClass(_.options.dotsClass);

            for (i = 0; i <= _.getDotCount(); i += 1) {
                dot.append($('<li />').append(_.options.customPaging.call(this, _, i)));
            }

            _.$dots = dot.appendTo(_.options.appendDots);

            _.$dots.find('li').first().addClass('slick-active');

        }

    };

    Slick.prototype.buildOut = function() {

        var _ = this;

        _.$slides =
            _.$slider
                .children( _.options.slide + ':not(.slick-cloned)')
                .addClass('slick-slide');

        _.slideCount = _.$slides.length;

        _.$slides.each(function(index, element) {
            $(element)
                .attr('data-slick-index', index)
                .data('originalStyling', $(element).attr('style') || '');
        });

        _.$slider.addClass('slick-slider');

        _.$slideTrack = (_.slideCount === 0) ?
            $('<div class="slick-track"/>').appendTo(_.$slider) :
            _.$slides.wrapAll('<div class="slick-track"/>').parent();

        _.$list = _.$slideTrack.wrap(
            '<div class="slick-list"/>').parent();
        _.$slideTrack.css('opacity', 0);

        if (_.options.centerMode === true || _.options.swipeToSlide === true) {
            _.options.slidesToScroll = 1;
        }

        $('img[data-lazy]', _.$slider).not('[src]').addClass('slick-loading');

        _.setupInfinite();

        _.buildArrows();

        _.buildDots();

        _.updateDots();


        _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);

        if (_.options.draggable === true) {
            _.$list.addClass('draggable');
        }

    };

    Slick.prototype.buildRows = function() {

        var _ = this, a, b, c, newSlides, numOfSlides, originalSlides,slidesPerSection;

        newSlides = document.createDocumentFragment();
        originalSlides = _.$slider.children();

        if(_.options.rows > 0) {

            slidesPerSection = _.options.slidesPerRow * _.options.rows;
            numOfSlides = Math.ceil(
                originalSlides.length / slidesPerSection
            );

            for(a = 0; a < numOfSlides; a++){
                var slide = document.createElement('div');
                for(b = 0; b < _.options.rows; b++) {
                    var row = document.createElement('div');
                    for(c = 0; c < _.options.slidesPerRow; c++) {
                        var target = (a * slidesPerSection + ((b * _.options.slidesPerRow) + c));
                        if (originalSlides.get(target)) {
                            row.appendChild(originalSlides.get(target));
                        }
                    }
                    slide.appendChild(row);
                }
                newSlides.appendChild(slide);
            }

            _.$slider.empty().append(newSlides);
            _.$slider.children().children().children()
                .css({
                    'width':(100 / _.options.slidesPerRow) + '%',
                    'display': 'inline-block'
                });

        }

    };

    Slick.prototype.checkResponsive = function(initial, forceUpdate) {

        var _ = this,
            breakpoint, targetBreakpoint, respondToWidth, triggerBreakpoint = false;
        var sliderWidth = _.$slider.width();
        var windowWidth = window.innerWidth || $(window).width();

        if (_.respondTo === 'window') {
            respondToWidth = windowWidth;
        } else if (_.respondTo === 'slider') {
            respondToWidth = sliderWidth;
        } else if (_.respondTo === 'min') {
            respondToWidth = Math.min(windowWidth, sliderWidth);
        }

        if ( _.options.responsive &&
            _.options.responsive.length &&
            _.options.responsive !== null) {

            targetBreakpoint = null;

            for (breakpoint in _.breakpoints) {
                if (_.breakpoints.hasOwnProperty(breakpoint)) {
                    if (_.originalSettings.mobileFirst === false) {
                        if (respondToWidth < _.breakpoints[breakpoint]) {
                            targetBreakpoint = _.breakpoints[breakpoint];
                        }
                    } else {
                        if (respondToWidth > _.breakpoints[breakpoint]) {
                            targetBreakpoint = _.breakpoints[breakpoint];
                        }
                    }
                }
            }

            if (targetBreakpoint !== null) {
                if (_.activeBreakpoint !== null) {
                    if (targetBreakpoint !== _.activeBreakpoint || forceUpdate) {
                        _.activeBreakpoint =
                            targetBreakpoint;
                        if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
                            _.unslick(targetBreakpoint);
                        } else {
                            _.options = $.extend({}, _.originalSettings,
                                _.breakpointSettings[
                                    targetBreakpoint]);
                            if (initial === true) {
                                _.currentSlide = _.options.initialSlide;
                            }
                            _.refresh(initial);
                        }
                        triggerBreakpoint = targetBreakpoint;
                    }
                } else {
                    _.activeBreakpoint = targetBreakpoint;
                    if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
                        _.unslick(targetBreakpoint);
                    } else {
                        _.options = $.extend({}, _.originalSettings,
                            _.breakpointSettings[
                                targetBreakpoint]);
                        if (initial === true) {
                            _.currentSlide = _.options.initialSlide;
                        }
                        _.refresh(initial);
                    }
                    triggerBreakpoint = targetBreakpoint;
                }
            } else {
                if (_.activeBreakpoint !== null) {
                    _.activeBreakpoint = null;
                    _.options = _.originalSettings;
                    if (initial === true) {
                        _.currentSlide = _.options.initialSlide;
                    }
                    _.refresh(initial);
                    triggerBreakpoint = targetBreakpoint;
                }
            }

            // only trigger breakpoints during an actual break. not on initialize.
            if( !initial && triggerBreakpoint !== false ) {
                _.$slider.trigger('breakpoint', [_, triggerBreakpoint]);
            }
        }

    };

    Slick.prototype.changeSlide = function(event, dontAnimate) {

        var _ = this,
            $target = $(event.currentTarget),
            indexOffset, slideOffset, unevenOffset;

        // If target is a link, prevent default action.
        if($target.is('a')) {
            event.preventDefault();
        }

        // If target is not the <li> element (ie: a child), find the <li>.
        if(!$target.is('li')) {
            $target = $target.closest('li');
        }

        unevenOffset = (_.slideCount % _.options.slidesToScroll !== 0);
        indexOffset = unevenOffset ? 0 : (_.slideCount - _.currentSlide) % _.options.slidesToScroll;

        switch (event.data.message) {

            case 'previous':
                slideOffset = indexOffset === 0 ? _.options.slidesToScroll : _.options.slidesToShow - indexOffset;
                if (_.slideCount > _.options.slidesToShow) {
                    _.slideHandler(_.currentSlide - slideOffset, false, dontAnimate);
                }
                break;

            case 'next':
                slideOffset = indexOffset === 0 ? _.options.slidesToScroll : indexOffset;
                if (_.slideCount > _.options.slidesToShow) {
                    _.slideHandler(_.currentSlide + slideOffset, false, dontAnimate);
                }
                break;

            case 'index':
                var index = event.data.index === 0 ? 0 :
                    event.data.index || $target.index() * _.options.slidesToScroll;

                _.slideHandler(_.checkNavigable(index), false, dontAnimate);
                $target.children().trigger('focus');
                break;

            default:
                return;
        }

    };

    Slick.prototype.checkNavigable = function(index) {

        var _ = this,
            navigables, prevNavigable;

        navigables = _.getNavigableIndexes();
        prevNavigable = 0;
        if (index > navigables[navigables.length - 1]) {
            index = navigables[navigables.length - 1];
        } else {
            for (var n in navigables) {
                if (index < navigables[n]) {
                    index = prevNavigable;
                    break;
                }
                prevNavigable = navigables[n];
            }
        }

        return index;
    };

    Slick.prototype.cleanUpEvents = function() {

        var _ = this;

        if (_.options.dots && _.$dots !== null) {

            $('li', _.$dots)
                .off('click.slick', _.changeSlide)
                .off('mouseenter.slick', $.proxy(_.interrupt, _, true))
                .off('mouseleave.slick', $.proxy(_.interrupt, _, false));

            if (_.options.accessibility === true) {
                _.$dots.off('keydown.slick', _.keyHandler);
            }
        }

        _.$slider.off('focus.slick blur.slick');

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow && _.$prevArrow.off('click.slick', _.changeSlide);
            _.$nextArrow && _.$nextArrow.off('click.slick', _.changeSlide);

            if (_.options.accessibility === true) {
                _.$prevArrow && _.$prevArrow.off('keydown.slick', _.keyHandler);
                _.$nextArrow && _.$nextArrow.off('keydown.slick', _.keyHandler);
            }
        }

        _.$list.off('touchstart.slick mousedown.slick', _.swipeHandler);
        _.$list.off('touchmove.slick mousemove.slick', _.swipeHandler);
        _.$list.off('touchend.slick mouseup.slick', _.swipeHandler);
        _.$list.off('touchcancel.slick mouseleave.slick', _.swipeHandler);

        _.$list.off('click.slick', _.clickHandler);

        $(document).off(_.visibilityChange, _.visibility);

        _.cleanUpSlideEvents();

        if (_.options.accessibility === true) {
            _.$list.off('keydown.slick', _.keyHandler);
        }

        if (_.options.focusOnSelect === true) {
            $(_.$slideTrack).children().off('click.slick', _.selectHandler);
        }

        $(window).off('orientationchange.slick.slick-' + _.instanceUid, _.orientationChange);

        $(window).off('resize.slick.slick-' + _.instanceUid, _.resize);

        $('[draggable!=true]', _.$slideTrack).off('dragstart', _.preventDefault);

        $(window).off('load.slick.slick-' + _.instanceUid, _.setPosition);

    };

    Slick.prototype.cleanUpSlideEvents = function() {

        var _ = this;

        _.$list.off('mouseenter.slick', $.proxy(_.interrupt, _, true));
        _.$list.off('mouseleave.slick', $.proxy(_.interrupt, _, false));

    };

    Slick.prototype.cleanUpRows = function() {

        var _ = this, originalSlides;

        if(_.options.rows > 0) {
            originalSlides = _.$slides.children().children();
            originalSlides.removeAttr('style');
            _.$slider.empty().append(originalSlides);
        }

    };

    Slick.prototype.clickHandler = function(event) {

        var _ = this;

        if (_.shouldClick === false) {
            event.stopImmediatePropagation();
            event.stopPropagation();
            event.preventDefault();
        }

    };

    Slick.prototype.destroy = function(refresh) {

        var _ = this;

        _.autoPlayClear();

        _.touchObject = {};

        _.cleanUpEvents();

        $('.slick-cloned', _.$slider).detach();

        if (_.$dots) {
            _.$dots.remove();
        }

        if ( _.$prevArrow && _.$prevArrow.length ) {

            _.$prevArrow
                .removeClass('slick-disabled slick-arrow slick-hidden')
                .removeAttr('aria-hidden aria-disabled tabindex')
                .css('display','');

            if ( _.htmlExpr.test( _.options.prevArrow )) {
                _.$prevArrow.remove();
            }
        }

        if ( _.$nextArrow && _.$nextArrow.length ) {

            _.$nextArrow
                .removeClass('slick-disabled slick-arrow slick-hidden')
                .removeAttr('aria-hidden aria-disabled tabindex')
                .css('display','');

            if ( _.htmlExpr.test( _.options.nextArrow )) {
                _.$nextArrow.remove();
            }
        }


        if (_.$slides) {

            _.$slides
                .removeClass('slick-slide slick-active slick-center slick-visible slick-current')
                .removeAttr('aria-hidden')
                .removeAttr('data-slick-index')
                .each(function(){
                    $(this).attr('style', $(this).data('originalStyling'));
                });

            _.$slideTrack.children(this.options.slide).detach();

            _.$slideTrack.detach();

            _.$list.detach();

            _.$slider.append(_.$slides);
        }

        _.cleanUpRows();

        _.$slider.removeClass('slick-slider');
        _.$slider.removeClass('slick-initialized');
        _.$slider.removeClass('slick-dotted');

        _.unslicked = true;

        if(!refresh) {
            _.$slider.trigger('destroy', [_]);
        }

    };

    Slick.prototype.disableTransition = function(slide) {

        var _ = this,
            transition = {};

        transition[_.transitionType] = '';

        if (_.options.fade === false) {
            _.$slideTrack.css(transition);
        } else {
            _.$slides.eq(slide).css(transition);
        }

    };

    Slick.prototype.fadeSlide = function(slideIndex, callback) {

        var _ = this;

        if (_.cssTransitions === false) {

            _.$slides.eq(slideIndex).css({
                zIndex: _.options.zIndex
            });

            _.$slides.eq(slideIndex).animate({
                opacity: 1
            }, _.options.speed, _.options.easing, callback);

        } else {

            _.applyTransition(slideIndex);

            _.$slides.eq(slideIndex).css({
                opacity: 1,
                zIndex: _.options.zIndex
            });

            if (callback) {
                setTimeout(function() {

                    _.disableTransition(slideIndex);

                    callback.call();
                }, _.options.speed);
            }

        }

    };

    Slick.prototype.fadeSlideOut = function(slideIndex) {

        var _ = this;

        if (_.cssTransitions === false) {

            _.$slides.eq(slideIndex).animate({
                opacity: 0,
                zIndex: _.options.zIndex - 2
            }, _.options.speed, _.options.easing);

        } else {

            _.applyTransition(slideIndex);

            _.$slides.eq(slideIndex).css({
                opacity: 0,
                zIndex: _.options.zIndex - 2
            });

        }

    };

    Slick.prototype.filterSlides = Slick.prototype.slickFilter = function(filter) {

        var _ = this;

        if (filter !== null) {

            _.$slidesCache = _.$slides;

            _.unload();

            _.$slideTrack.children(this.options.slide).detach();

            _.$slidesCache.filter(filter).appendTo(_.$slideTrack);

            _.reinit();

        }

    };

    Slick.prototype.focusHandler = function() {

        var _ = this;

        _.$slider
            .off('focus.slick blur.slick')
            .on('focus.slick blur.slick', '*', function(event) {

                event.stopImmediatePropagation();
                var $sf = $(this);

                setTimeout(function() {

                    if( _.options.pauseOnFocus ) {
                        _.focussed = $sf.is(':focus');
                        _.autoPlay();
                    }

                }, 0);

            });
    };

    Slick.prototype.getCurrent = Slick.prototype.slickCurrentSlide = function() {

        var _ = this;
        return _.currentSlide;

    };

    Slick.prototype.getDotCount = function() {

        var _ = this;

        var breakPoint = 0;
        var counter = 0;
        var pagerQty = 0;

        if (_.options.infinite === true) {
            if (_.slideCount <= _.options.slidesToShow) {
                ++pagerQty;
            } else {
                while (breakPoint < _.slideCount) {
                    ++pagerQty;
                    breakPoint = counter + _.options.slidesToScroll;
                    counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
                }
            }
        } else if (_.options.centerMode === true) {
            pagerQty = _.slideCount;
        } else if(!_.options.asNavFor) {
            pagerQty = 1 + Math.ceil((_.slideCount - _.options.slidesToShow) / _.options.slidesToScroll);
        }else {
            while (breakPoint < _.slideCount) {
                ++pagerQty;
                breakPoint = counter + _.options.slidesToScroll;
                counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
            }
        }

        return pagerQty - 1;

    };

    Slick.prototype.getLeft = function(slideIndex) {

        var _ = this,
            targetLeft,
            verticalHeight,
            verticalOffset = 0,
            targetSlide,
            coef;

        _.slideOffset = 0;
        verticalHeight = _.$slides.first().outerHeight(true);

        if (_.options.infinite === true) {
            if (_.slideCount > _.options.slidesToShow) {
                _.slideOffset = (_.slideWidth * _.options.slidesToShow) * -1;
                coef = -1

                if (_.options.vertical === true && _.options.centerMode === true) {
                    if (_.options.slidesToShow === 2) {
                        coef = -1.5;
                    } else if (_.options.slidesToShow === 1) {
                        coef = -2
                    }
                }
                verticalOffset = (verticalHeight * _.options.slidesToShow) * coef;
            }
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                if (slideIndex + _.options.slidesToScroll > _.slideCount && _.slideCount > _.options.slidesToShow) {
                    if (slideIndex > _.slideCount) {
                        _.slideOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * _.slideWidth) * -1;
                        verticalOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * verticalHeight) * -1;
                    } else {
                        _.slideOffset = ((_.slideCount % _.options.slidesToScroll) * _.slideWidth) * -1;
                        verticalOffset = ((_.slideCount % _.options.slidesToScroll) * verticalHeight) * -1;
                    }
                }
            }
        } else {
            if (slideIndex + _.options.slidesToShow > _.slideCount) {
                _.slideOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * _.slideWidth;
                verticalOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * verticalHeight;
            }
        }

        if (_.slideCount <= _.options.slidesToShow) {
            _.slideOffset = 0;
            verticalOffset = 0;
        }

        if (_.options.centerMode === true && _.slideCount <= _.options.slidesToShow) {
            _.slideOffset = ((_.slideWidth * Math.floor(_.options.slidesToShow)) / 2) - ((_.slideWidth * _.slideCount) / 2);
        } else if (_.options.centerMode === true && _.options.infinite === true) {
            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2) - _.slideWidth;
        } else if (_.options.centerMode === true) {
            _.slideOffset = 0;
            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2);
        }

        if (_.options.vertical === false) {
            targetLeft = ((slideIndex * _.slideWidth) * -1) + _.slideOffset;
        } else {
            targetLeft = ((slideIndex * verticalHeight) * -1) + verticalOffset;
        }

        if (_.options.variableWidth === true) {

            if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
                targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
            } else {
                targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow);
            }

            if (_.options.rtl === true) {
                if (targetSlide[0]) {
                    targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
                } else {
                    targetLeft =  0;
                }
            } else {
                targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
            }

            if (_.options.centerMode === true) {
                if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
                    targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
                } else {
                    targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow + 1);
                }

                if (_.options.rtl === true) {
                    if (targetSlide[0]) {
                        targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
                    } else {
                        targetLeft =  0;
                    }
                } else {
                    targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
                }

                targetLeft += (_.$list.width() - targetSlide.outerWidth()) / 2;
            }
        }

        return targetLeft;

    };

    Slick.prototype.getOption = Slick.prototype.slickGetOption = function(option) {

        var _ = this;

        return _.options[option];

    };

    Slick.prototype.getNavigableIndexes = function() {

        var _ = this,
            breakPoint = 0,
            counter = 0,
            indexes = [],
            max;

        if (_.options.infinite === false) {
            max = _.slideCount;
        } else {
            breakPoint = _.options.slidesToScroll * -1;
            counter = _.options.slidesToScroll * -1;
            max = _.slideCount * 2;
        }

        while (breakPoint < max) {
            indexes.push(breakPoint);
            breakPoint = counter + _.options.slidesToScroll;
            counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
        }

        return indexes;

    };

    Slick.prototype.getSlick = function() {

        return this;

    };

    Slick.prototype.getSlideCount = function() {

        var _ = this,
            slidesTraversed, swipedSlide, centerOffset;

        centerOffset = _.options.centerMode === true ? _.slideWidth * Math.floor(_.options.slidesToShow / 2) : 0;

        if (_.options.swipeToSlide === true) {
            _.$slideTrack.find('.slick-slide').each(function(index, slide) {
                if (slide.offsetLeft - centerOffset + ($(slide).outerWidth() / 2) > (_.swipeLeft * -1)) {
                    swipedSlide = slide;
                    return false;
                }
            });

            slidesTraversed = Math.abs($(swipedSlide).attr('data-slick-index') - _.currentSlide) || 1;

            return slidesTraversed;

        } else {
            return _.options.slidesToScroll;
        }

    };

    Slick.prototype.goTo = Slick.prototype.slickGoTo = function(slide, dontAnimate) {

        var _ = this;

        _.changeSlide({
            data: {
                message: 'index',
                index: parseInt(slide)
            }
        }, dontAnimate);

    };

    Slick.prototype.init = function(creation) {

        var _ = this;

        if (!$(_.$slider).hasClass('slick-initialized')) {

            $(_.$slider).addClass('slick-initialized');

            _.buildRows();
            _.buildOut();
            _.setProps();
            _.startLoad();
            _.loadSlider();
            _.initializeEvents();
            _.updateArrows();
            _.updateDots();
            _.checkResponsive(true);
            _.focusHandler();

        }

        if (creation) {
            _.$slider.trigger('init', [_]);
        }

        if (_.options.accessibility === true) {
            _.initADA();
        }

        if ( _.options.autoplay ) {

            _.paused = false;
            _.autoPlay();

        }

    };

    Slick.prototype.initADA = function() {
        var _ = this,
            numDotGroups = Math.ceil(_.slideCount / _.options.slidesToShow),
            tabControlIndexes = _.getNavigableIndexes().filter(function(val) {
                return (val >= 0) && (val < _.slideCount);
            });

        _.$slides.add(_.$slideTrack.find('.slick-cloned')).attr({
            'aria-hidden': 'true',
            'tabindex': '-1'
        }).find('a, input, button, select').attr({
            'tabindex': '-1'
        });

        if (_.$dots !== null) {
            _.$slides.not(_.$slideTrack.find('.slick-cloned')).each(function(i) {
                var slideControlIndex = tabControlIndexes.indexOf(i);

                $(this).attr({
                    'role': 'tabpanel',
                    'id': 'slick-slide' + _.instanceUid + i,
                    'tabindex': -1
                });

                if (slideControlIndex !== -1) {
                    var ariaButtonControl = 'slick-slide-control' + _.instanceUid + slideControlIndex
                    if ($('#' + ariaButtonControl).length) {
                        $(this).attr({
                            'aria-describedby': ariaButtonControl
                        });
                    }
                }
            });

            _.$dots.attr('role', 'tablist').find('li').each(function(i) {
                var mappedSlideIndex = tabControlIndexes[i];

                $(this).attr({
                    'role': 'presentation'
                });

                $(this).find('button').first().attr({
                    'role': 'tab',
                    'id': 'slick-slide-control' + _.instanceUid + i,
                    'aria-controls': 'slick-slide' + _.instanceUid + mappedSlideIndex,
                    'aria-label': (i + 1) + ' of ' + numDotGroups,
                    'aria-selected': null,
                    'tabindex': '-1'
                });

            }).eq(_.currentSlide).find('button').attr({
                'aria-selected': 'true',
                'tabindex': '0'
            }).end();
        }

        for (var i=_.currentSlide, max=i+_.options.slidesToShow; i < max; i++) {
            if (_.options.focusOnChange) {
                _.$slides.eq(i).attr({'tabindex': '0'});
            } else {
                _.$slides.eq(i).removeAttr('tabindex');
            }
        }

        _.activateADA();

    };

    Slick.prototype.initArrowEvents = function() {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow
                .off('click.slick')
                .on('click.slick', {
                    message: 'previous'
                }, _.changeSlide);
            _.$nextArrow
                .off('click.slick')
                .on('click.slick', {
                    message: 'next'
                }, _.changeSlide);

            if (_.options.accessibility === true) {
                _.$prevArrow.on('keydown.slick', _.keyHandler);
                _.$nextArrow.on('keydown.slick', _.keyHandler);
            }
        }

    };

    Slick.prototype.initDotEvents = function() {

        var _ = this;

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
            $('li', _.$dots).on('click.slick', {
                message: 'index'
            }, _.changeSlide);

            if (_.options.accessibility === true) {
                _.$dots.on('keydown.slick', _.keyHandler);
            }
        }

        if (_.options.dots === true && _.options.pauseOnDotsHover === true && _.slideCount > _.options.slidesToShow) {

            $('li', _.$dots)
                .on('mouseenter.slick', $.proxy(_.interrupt, _, true))
                .on('mouseleave.slick', $.proxy(_.interrupt, _, false));

        }

    };

    Slick.prototype.initSlideEvents = function() {

        var _ = this;

        if ( _.options.pauseOnHover ) {

            _.$list.on('mouseenter.slick', $.proxy(_.interrupt, _, true));
            _.$list.on('mouseleave.slick', $.proxy(_.interrupt, _, false));

        }

    };

    Slick.prototype.initializeEvents = function() {

        var _ = this;

        _.initArrowEvents();

        _.initDotEvents();
        _.initSlideEvents();

        _.$list.on('touchstart.slick mousedown.slick', {
            action: 'start'
        }, _.swipeHandler);
        _.$list.on('touchmove.slick mousemove.slick', {
            action: 'move'
        }, _.swipeHandler);
        _.$list.on('touchend.slick mouseup.slick', {
            action: 'end'
        }, _.swipeHandler);
        _.$list.on('touchcancel.slick mouseleave.slick', {
            action: 'end'
        }, _.swipeHandler);

        _.$list.on('click.slick', _.clickHandler);

        $(document).on(_.visibilityChange, $.proxy(_.visibility, _));

        if (_.options.accessibility === true) {
            _.$list.on('keydown.slick', _.keyHandler);
        }

        if (_.options.focusOnSelect === true) {
            $(_.$slideTrack).children().on('click.slick', _.selectHandler);
        }

        $(window).on('orientationchange.slick.slick-' + _.instanceUid, $.proxy(_.orientationChange, _));

        $(window).on('resize.slick.slick-' + _.instanceUid, $.proxy(_.resize, _));

        $('[draggable!=true]', _.$slideTrack).on('dragstart', _.preventDefault);

        $(window).on('load.slick.slick-' + _.instanceUid, _.setPosition);
        $(_.setPosition);

    };

    Slick.prototype.initUI = function() {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

            _.$prevArrow.show();
            _.$nextArrow.show();

        }

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

            _.$dots.show();

        }

    };

    Slick.prototype.keyHandler = function(event) {

        var _ = this;
        //Dont slide if the cursor is inside the form fields and arrow keys are pressed
        if(!event.target.tagName.match('TEXTAREA|INPUT|SELECT')) {
            if (event.keyCode === 37 && _.options.accessibility === true) {
                _.changeSlide({
                    data: {
                        message: _.options.rtl === true ? 'next' :  'previous'
                    }
                });
            } else if (event.keyCode === 39 && _.options.accessibility === true) {
                _.changeSlide({
                    data: {
                        message: _.options.rtl === true ? 'previous' : 'next'
                    }
                });
            }
        }

    };

    Slick.prototype.lazyLoad = function() {

        var _ = this,
            loadRange, cloneRange, rangeStart, rangeEnd;

        function loadImages(imagesScope) {

            $('img[data-lazy]', imagesScope).each(function() {

                var image = $(this),
                    imageSource = $(this).attr('data-lazy'),
                    imageSrcSet = $(this).attr('data-srcset'),
                    imageSizes  = $(this).attr('data-sizes') || _.$slider.attr('data-sizes'),
                    imageToLoad = document.createElement('img');

                imageToLoad.onload = function() {

                    image
                        .animate({ opacity: 0 }, 100, function() {

                            if (imageSrcSet) {
                                image
                                    .attr('srcset', imageSrcSet );

                                if (imageSizes) {
                                    image
                                        .attr('sizes', imageSizes );
                                }
                            }

                            image
                                .attr('src', imageSource)
                                .animate({ opacity: 1 }, 200, function() {
                                    image
                                        .removeAttr('data-lazy data-srcset data-sizes')
                                        .removeClass('slick-loading');
                                });
                            _.$slider.trigger('lazyLoaded', [_, image, imageSource]);
                        });

                };

                imageToLoad.onerror = function() {

                    image
                        .removeAttr( 'data-lazy' )
                        .removeClass( 'slick-loading' )
                        .addClass( 'slick-lazyload-error' );

                    _.$slider.trigger('lazyLoadError', [ _, image, imageSource ]);

                };

                imageToLoad.src = imageSource;

            });

        }

        if (_.options.centerMode === true) {
            if (_.options.infinite === true) {
                rangeStart = _.currentSlide + (_.options.slidesToShow / 2 + 1);
                rangeEnd = rangeStart + _.options.slidesToShow + 2;
            } else {
                rangeStart = Math.max(0, _.currentSlide - (_.options.slidesToShow / 2 + 1));
                rangeEnd = 2 + (_.options.slidesToShow / 2 + 1) + _.currentSlide;
            }
        } else {
            rangeStart = _.options.infinite ? _.options.slidesToShow + _.currentSlide : _.currentSlide;
            rangeEnd = Math.ceil(rangeStart + _.options.slidesToShow);
            if (_.options.fade === true) {
                if (rangeStart > 0) rangeStart--;
                if (rangeEnd <= _.slideCount) rangeEnd++;
            }
        }

        loadRange = _.$slider.find('.slick-slide').slice(rangeStart, rangeEnd);

        if (_.options.lazyLoad === 'anticipated') {
            var prevSlide = rangeStart - 1,
                nextSlide = rangeEnd,
                $slides = _.$slider.find('.slick-slide');

            for (var i = 0; i < _.options.slidesToScroll; i++) {
                if (prevSlide < 0) prevSlide = _.slideCount - 1;
                loadRange = loadRange.add($slides.eq(prevSlide));
                loadRange = loadRange.add($slides.eq(nextSlide));
                prevSlide--;
                nextSlide++;
            }
        }

        loadImages(loadRange);

        if (_.slideCount <= _.options.slidesToShow) {
            cloneRange = _.$slider.find('.slick-slide');
            loadImages(cloneRange);
        } else
        if (_.currentSlide >= _.slideCount - _.options.slidesToShow) {
            cloneRange = _.$slider.find('.slick-cloned').slice(0, _.options.slidesToShow);
            loadImages(cloneRange);
        } else if (_.currentSlide === 0) {
            cloneRange = _.$slider.find('.slick-cloned').slice(_.options.slidesToShow * -1);
            loadImages(cloneRange);
        }

    };

    Slick.prototype.loadSlider = function() {

        var _ = this;

        _.setPosition();

        _.$slideTrack.css({
            opacity: 1
        });

        _.$slider.removeClass('slick-loading');

        _.initUI();

        if (_.options.lazyLoad === 'progressive') {
            _.progressiveLazyLoad();
        }

    };

    Slick.prototype.next = Slick.prototype.slickNext = function() {

        var _ = this;

        _.changeSlide({
            data: {
                message: 'next'
            }
        });

    };

    Slick.prototype.orientationChange = function() {

        var _ = this;

        _.checkResponsive();
        _.setPosition();

    };

    Slick.prototype.pause = Slick.prototype.slickPause = function() {

        var _ = this;

        _.autoPlayClear();
        _.paused = true;

    };

    Slick.prototype.play = Slick.prototype.slickPlay = function() {

        var _ = this;

        _.autoPlay();
        _.options.autoplay = true;
        _.paused = false;
        _.focussed = false;
        _.interrupted = false;

    };

    Slick.prototype.postSlide = function(index) {

        var _ = this;

        if( !_.unslicked ) {

            _.$slider.trigger('afterChange', [_, index]);

            _.animating = false;

            if (_.slideCount > _.options.slidesToShow) {
                _.setPosition();
            }

            _.swipeLeft = null;

            if ( _.options.autoplay ) {
                _.autoPlay();
            }

            if (_.options.accessibility === true) {
                _.initADA();

                if (_.options.focusOnChange) {
                    var $currentSlide = $(_.$slides.get(_.currentSlide));
                    $currentSlide.attr('tabindex', 0).focus();
                }
            }

        }

    };

    Slick.prototype.prev = Slick.prototype.slickPrev = function() {

        var _ = this;

        _.changeSlide({
            data: {
                message: 'previous'
            }
        });

    };

    Slick.prototype.preventDefault = function(event) {

        event.preventDefault();

    };

    Slick.prototype.progressiveLazyLoad = function( tryCount ) {

        tryCount = tryCount || 1;

        var _ = this,
            $imgsToLoad = $( 'img[data-lazy]', _.$slider ),
            image,
            imageSource,
            imageSrcSet,
            imageSizes,
            imageToLoad;

        if ( $imgsToLoad.length ) {

            image = $imgsToLoad.first();
            imageSource = image.attr('data-lazy');
            imageSrcSet = image.attr('data-srcset');
            imageSizes  = image.attr('data-sizes') || _.$slider.attr('data-sizes');
            imageToLoad = document.createElement('img');

            imageToLoad.onload = function() {

                if (imageSrcSet) {
                    image
                        .attr('srcset', imageSrcSet );

                    if (imageSizes) {
                        image
                            .attr('sizes', imageSizes );
                    }
                }

                image
                    .attr( 'src', imageSource )
                    .removeAttr('data-lazy data-srcset data-sizes')
                    .removeClass('slick-loading');

                if ( _.options.adaptiveHeight === true ) {
                    _.setPosition();
                }

                _.$slider.trigger('lazyLoaded', [ _, image, imageSource ]);
                _.progressiveLazyLoad();

            };

            imageToLoad.onerror = function() {

                if ( tryCount < 3 ) {

                    /**
                     * try to load the image 3 times,
                     * leave a slight delay so we don't get
                     * servers blocking the request.
                     */
                    setTimeout( function() {
                        _.progressiveLazyLoad( tryCount + 1 );
                    }, 500 );

                } else {

                    image
                        .removeAttr( 'data-lazy' )
                        .removeClass( 'slick-loading' )
                        .addClass( 'slick-lazyload-error' );

                    _.$slider.trigger('lazyLoadError', [ _, image, imageSource ]);

                    _.progressiveLazyLoad();

                }

            };

            imageToLoad.src = imageSource;

        } else {

            _.$slider.trigger('allImagesLoaded', [ _ ]);

        }

    };

    Slick.prototype.refresh = function( initializing ) {

        var _ = this, currentSlide, lastVisibleIndex;

        lastVisibleIndex = _.slideCount - _.options.slidesToShow;

        // in non-infinite sliders, we don't want to go past the
        // last visible index.
        if( !_.options.infinite && ( _.currentSlide > lastVisibleIndex )) {
            _.currentSlide = lastVisibleIndex;
        }

        // if less slides than to show, go to start.
        if ( _.slideCount <= _.options.slidesToShow ) {
            _.currentSlide = 0;

        }

        currentSlide = _.currentSlide;

        _.destroy(true);

        $.extend(_, _.initials, { currentSlide: currentSlide });

        _.init();

        if( !initializing ) {

            _.changeSlide({
                data: {
                    message: 'index',
                    index: currentSlide
                }
            }, false);

        }

    };

    Slick.prototype.registerBreakpoints = function() {

        var _ = this, breakpoint, currentBreakpoint, l,
            responsiveSettings = _.options.responsive || null;

        if ( $.type(responsiveSettings) === 'array' && responsiveSettings.length ) {

            _.respondTo = _.options.respondTo || 'window';

            for ( breakpoint in responsiveSettings ) {

                l = _.breakpoints.length-1;

                if (responsiveSettings.hasOwnProperty(breakpoint)) {
                    currentBreakpoint = responsiveSettings[breakpoint].breakpoint;

                    // loop through the breakpoints and cut out any existing
                    // ones with the same breakpoint number, we don't want dupes.
                    while( l >= 0 ) {
                        if( _.breakpoints[l] && _.breakpoints[l] === currentBreakpoint ) {
                            _.breakpoints.splice(l,1);
                        }
                        l--;
                    }

                    _.breakpoints.push(currentBreakpoint);
                    _.breakpointSettings[currentBreakpoint] = responsiveSettings[breakpoint].settings;

                }

            }

            _.breakpoints.sort(function(a, b) {
                return ( _.options.mobileFirst ) ? a-b : b-a;
            });

        }

    };

    Slick.prototype.reinit = function() {

        var _ = this;

        _.$slides =
            _.$slideTrack
                .children(_.options.slide)
                .addClass('slick-slide');

        _.slideCount = _.$slides.length;

        if (_.currentSlide >= _.slideCount && _.currentSlide !== 0) {
            _.currentSlide = _.currentSlide - _.options.slidesToScroll;
        }

        if (_.slideCount <= _.options.slidesToShow) {
            _.currentSlide = 0;
        }

        _.registerBreakpoints();

        _.setProps();
        _.setupInfinite();
        _.buildArrows();
        _.updateArrows();
        _.initArrowEvents();
        _.buildDots();
        _.updateDots();
        _.initDotEvents();
        _.cleanUpSlideEvents();
        _.initSlideEvents();

        _.checkResponsive(false, true);

        if (_.options.focusOnSelect === true) {
            $(_.$slideTrack).children().on('click.slick', _.selectHandler);
        }

        _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);

        _.setPosition();
        _.focusHandler();

        _.paused = !_.options.autoplay;
        _.autoPlay();

        _.$slider.trigger('reInit', [_]);

    };

    Slick.prototype.resize = function() {

        var _ = this;

        if ($(window).width() !== _.windowWidth) {
            clearTimeout(_.windowDelay);
            _.windowDelay = window.setTimeout(function() {
                _.windowWidth = $(window).width();
                _.checkResponsive();
                if( !_.unslicked ) { _.setPosition(); }
            }, 50);
        }
    };

    Slick.prototype.removeSlide = Slick.prototype.slickRemove = function(index, removeBefore, removeAll) {

        var _ = this;

        if (typeof(index) === 'boolean') {
            removeBefore = index;
            index = removeBefore === true ? 0 : _.slideCount - 1;
        } else {
            index = removeBefore === true ? --index : index;
        }

        if (_.slideCount < 1 || index < 0 || index > _.slideCount - 1) {
            return false;
        }

        _.unload();

        if (removeAll === true) {
            _.$slideTrack.children().remove();
        } else {
            _.$slideTrack.children(this.options.slide).eq(index).remove();
        }

        _.$slides = _.$slideTrack.children(this.options.slide);

        _.$slideTrack.children(this.options.slide).detach();

        _.$slideTrack.append(_.$slides);

        _.$slidesCache = _.$slides;

        _.reinit();

    };

    Slick.prototype.setCSS = function(position) {

        var _ = this,
            positionProps = {},
            x, y;

        if (_.options.rtl === true) {
            position = -position;
        }
        x = _.positionProp == 'left' ? Math.ceil(position) + 'px' : '0px';
        y = _.positionProp == 'top' ? Math.ceil(position) + 'px' : '0px';

        positionProps[_.positionProp] = position;

        if (_.transformsEnabled === false) {
            _.$slideTrack.css(positionProps);
        } else {
            positionProps = {};
            if (_.cssTransitions === false) {
                positionProps[_.animType] = 'translate(' + x + ', ' + y + ')';
                _.$slideTrack.css(positionProps);
            } else {
                positionProps[_.animType] = 'translate3d(' + x + ', ' + y + ', 0px)';
                _.$slideTrack.css(positionProps);
            }
        }

    };

    Slick.prototype.setDimensions = function() {

        var _ = this;

        if (_.options.vertical === false) {
            if (_.options.centerMode === true) {
                _.$list.css({
                    padding: ('0px ' + _.options.centerPadding)
                });
            }
        } else {
            _.$list.height(_.$slides.first().outerHeight(true) * _.options.slidesToShow);
            if (_.options.centerMode === true) {
                _.$list.css({
                    padding: (_.options.centerPadding + ' 0px')
                });
            }
        }

        _.listWidth = _.$list.width();
        _.listHeight = _.$list.height();


        if (_.options.vertical === false && _.options.variableWidth === false) {
            _.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);
            _.$slideTrack.width(Math.ceil((_.slideWidth * _.$slideTrack.children('.slick-slide').length)));

        } else if (_.options.variableWidth === true) {
            _.$slideTrack.width(5000 * _.slideCount);
        } else {
            _.slideWidth = Math.ceil(_.listWidth);
            _.$slideTrack.height(Math.ceil((_.$slides.first().outerHeight(true) * _.$slideTrack.children('.slick-slide').length)));
        }

        var offset = _.$slides.first().outerWidth(true) - _.$slides.first().width();
        if (_.options.variableWidth === false) _.$slideTrack.children('.slick-slide').width(_.slideWidth - offset);

    };

    Slick.prototype.setFade = function() {

        var _ = this,
            targetLeft;

        _.$slides.each(function(index, element) {
            targetLeft = (_.slideWidth * index) * -1;
            if (_.options.rtl === true) {
                $(element).css({
                    position: 'relative',
                    right: targetLeft,
                    top: 0,
                    zIndex: _.options.zIndex - 2,
                    opacity: 0
                });
            } else {
                $(element).css({
                    position: 'relative',
                    left: targetLeft,
                    top: 0,
                    zIndex: _.options.zIndex - 2,
                    opacity: 0
                });
            }
        });

        _.$slides.eq(_.currentSlide).css({
            zIndex: _.options.zIndex - 1,
            opacity: 1
        });

    };

    Slick.prototype.setHeight = function() {

        var _ = this;

        if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
            _.$list.css('height', targetHeight);
        }

    };

    Slick.prototype.setOption =
        Slick.prototype.slickSetOption = function() {

            /**
             * accepts arguments in format of:
             *
             *  - for changing a single option's value:
             *     .slick("setOption", option, value, refresh )
             *
             *  - for changing a set of responsive options:
             *     .slick("setOption", 'responsive', [{}, ...], refresh )
             *
             *  - for updating multiple values at once (not responsive)
             *     .slick("setOption", { 'option': value, ... }, refresh )
             */

            var _ = this, l, item, option, value, refresh = false, type;

            if( $.type( arguments[0] ) === 'object' ) {

                option =  arguments[0];
                refresh = arguments[1];
                type = 'multiple';

            } else if ( $.type( arguments[0] ) === 'string' ) {

                option =  arguments[0];
                value = arguments[1];
                refresh = arguments[2];

                if ( arguments[0] === 'responsive' && $.type( arguments[1] ) === 'array' ) {

                    type = 'responsive';

                } else if ( typeof arguments[1] !== 'undefined' ) {

                    type = 'single';

                }

            }

            if ( type === 'single' ) {

                _.options[option] = value;


            } else if ( type === 'multiple' ) {

                $.each( option , function( opt, val ) {

                    _.options[opt] = val;

                });


            } else if ( type === 'responsive' ) {

                for ( item in value ) {

                    if( $.type( _.options.responsive ) !== 'array' ) {

                        _.options.responsive = [ value[item] ];

                    } else {

                        l = _.options.responsive.length-1;

                        // loop through the responsive object and splice out duplicates.
                        while( l >= 0 ) {

                            if( _.options.responsive[l].breakpoint === value[item].breakpoint ) {

                                _.options.responsive.splice(l,1);

                            }

                            l--;

                        }

                        _.options.responsive.push( value[item] );

                    }

                }

            }

            if ( refresh ) {

                _.unload();
                _.reinit();

            }

        };

    Slick.prototype.setPosition = function() {

        var _ = this;

        _.setDimensions();

        _.setHeight();

        if (_.options.fade === false) {
            _.setCSS(_.getLeft(_.currentSlide));
        } else {
            _.setFade();
        }

        _.$slider.trigger('setPosition', [_]);

    };

    Slick.prototype.setProps = function() {

        var _ = this,
            bodyStyle = document.body.style;

        _.positionProp = _.options.vertical === true ? 'top' : 'left';

        if (_.positionProp === 'top') {
            _.$slider.addClass('slick-vertical');
        } else {
            _.$slider.removeClass('slick-vertical');
        }

        if (bodyStyle.WebkitTransition !== undefined ||
            bodyStyle.MozTransition !== undefined ||
            bodyStyle.msTransition !== undefined) {
            if (_.options.useCSS === true) {
                _.cssTransitions = true;
            }
        }

        if ( _.options.fade ) {
            if ( typeof _.options.zIndex === 'number' ) {
                if( _.options.zIndex < 3 ) {
                    _.options.zIndex = 3;
                }
            } else {
                _.options.zIndex = _.defaults.zIndex;
            }
        }

        if (bodyStyle.OTransform !== undefined) {
            _.animType = 'OTransform';
            _.transformType = '-o-transform';
            _.transitionType = 'OTransition';
            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
        }
        if (bodyStyle.MozTransform !== undefined) {
            _.animType = 'MozTransform';
            _.transformType = '-moz-transform';
            _.transitionType = 'MozTransition';
            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.MozPerspective === undefined) _.animType = false;
        }
        if (bodyStyle.webkitTransform !== undefined) {
            _.animType = 'webkitTransform';
            _.transformType = '-webkit-transform';
            _.transitionType = 'webkitTransition';
            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
        }
        if (bodyStyle.msTransform !== undefined) {
            _.animType = 'msTransform';
            _.transformType = '-ms-transform';
            _.transitionType = 'msTransition';
            if (bodyStyle.msTransform === undefined) _.animType = false;
        }
        if (bodyStyle.transform !== undefined && _.animType !== false) {
            _.animType = 'transform';
            _.transformType = 'transform';
            _.transitionType = 'transition';
        }
        _.transformsEnabled = _.options.useTransform && (_.animType !== null && _.animType !== false);
    };


    Slick.prototype.setSlideClasses = function(index) {

        var _ = this,
            centerOffset, allSlides, indexOffset, remainder;

        allSlides = _.$slider
            .find('.slick-slide')
            .removeClass('slick-active slick-center slick-current')
            .attr('aria-hidden', 'true');

        _.$slides
            .eq(index)
            .addClass('slick-current');

        if (_.options.centerMode === true) {

            var evenCoef = _.options.slidesToShow % 2 === 0 ? 1 : 0;

            centerOffset = Math.floor(_.options.slidesToShow / 2);

            if (_.options.infinite === true) {

                if (index >= centerOffset && index <= (_.slideCount - 1) - centerOffset) {
                    _.$slides
                        .slice(index - centerOffset + evenCoef, index + centerOffset + 1)
                        .addClass('slick-active')
                        .attr('aria-hidden', 'false');

                } else {

                    indexOffset = _.options.slidesToShow + index;
                    allSlides
                        .slice(indexOffset - centerOffset + 1 + evenCoef, indexOffset + centerOffset + 2)
                        .addClass('slick-active')
                        .attr('aria-hidden', 'false');

                }

                if (index === 0) {

                    allSlides
                        .eq(allSlides.length - 1 - _.options.slidesToShow)
                        .addClass('slick-center');

                } else if (index === _.slideCount - 1) {

                    allSlides
                        .eq(_.options.slidesToShow)
                        .addClass('slick-center');

                }

            }

            _.$slides
                .eq(index)
                .addClass('slick-center');

        } else {

            if (index >= 0 && index <= (_.slideCount - _.options.slidesToShow)) {

                _.$slides
                    .slice(index, index + _.options.slidesToShow)
                    .addClass('slick-active')
                    .attr('aria-hidden', 'false');

            } else if (allSlides.length <= _.options.slidesToShow) {

                allSlides
                    .addClass('slick-active')
                    .attr('aria-hidden', 'false');

            } else {

                remainder = _.slideCount % _.options.slidesToShow;
                indexOffset = _.options.infinite === true ? _.options.slidesToShow + index : index;

                if (_.options.slidesToShow == _.options.slidesToScroll && (_.slideCount - index) < _.options.slidesToShow) {

                    allSlides
                        .slice(indexOffset - (_.options.slidesToShow - remainder), indexOffset + remainder)
                        .addClass('slick-active')
                        .attr('aria-hidden', 'false');

                } else {

                    allSlides
                        .slice(indexOffset, indexOffset + _.options.slidesToShow)
                        .addClass('slick-active')
                        .attr('aria-hidden', 'false');

                }

            }

        }

        if (_.options.lazyLoad === 'ondemand' || _.options.lazyLoad === 'anticipated') {
            _.lazyLoad();
        }
    };

    Slick.prototype.setupInfinite = function() {

        var _ = this,
            i, slideIndex, infiniteCount;

        if (_.options.fade === true) {
            _.options.centerMode = false;
        }

        if (_.options.infinite === true && _.options.fade === false) {

            slideIndex = null;

            if (_.slideCount > _.options.slidesToShow) {

                if (_.options.centerMode === true) {
                    infiniteCount = _.options.slidesToShow + 1;
                } else {
                    infiniteCount = _.options.slidesToShow;
                }

                for (i = _.slideCount; i > (_.slideCount -
                infiniteCount); i -= 1) {
                    slideIndex = i - 1;
                    $(_.$slides[slideIndex]).clone(true).attr('id', '')
                        .attr('data-slick-index', slideIndex - _.slideCount)
                        .prependTo(_.$slideTrack).addClass('slick-cloned');
                }
                for (i = 0; i < infiniteCount  + _.slideCount; i += 1) {
                    slideIndex = i;
                    $(_.$slides[slideIndex]).clone(true).attr('id', '')
                        .attr('data-slick-index', slideIndex + _.slideCount)
                        .appendTo(_.$slideTrack).addClass('slick-cloned');
                }
                _.$slideTrack.find('.slick-cloned').find('[id]').each(function() {
                    $(this).attr('id', '');
                });

            }

        }

    };

    Slick.prototype.interrupt = function( toggle ) {

        var _ = this;

        if( !toggle ) {
            _.autoPlay();
        }
        _.interrupted = toggle;

    };

    Slick.prototype.selectHandler = function(event) {

        var _ = this;

        var targetElement =
            $(event.target).is('.slick-slide') ?
                $(event.target) :
                $(event.target).parents('.slick-slide');

        var index = parseInt(targetElement.attr('data-slick-index'));

        if (!index) index = 0;

        if (_.slideCount <= _.options.slidesToShow) {

            _.slideHandler(index, false, true);
            return;

        }

        _.slideHandler(index);

    };

    Slick.prototype.slideHandler = function(index, sync, dontAnimate) {

        var targetSlide, animSlide, oldSlide, slideLeft, targetLeft = null,
            _ = this, navTarget;

        sync = sync || false;

        if (_.animating === true && _.options.waitForAnimate === true) {
            return;
        }

        if (_.options.fade === true && _.currentSlide === index) {
            return;
        }

        if (sync === false) {
            _.asNavFor(index);
        }

        targetSlide = index;
        targetLeft = _.getLeft(targetSlide);
        slideLeft = _.getLeft(_.currentSlide);

        _.currentLeft = _.swipeLeft === null ? slideLeft : _.swipeLeft;

        if (_.options.infinite === false && _.options.centerMode === false && (index < 0 || index > _.getDotCount() * _.options.slidesToScroll)) {
            if (_.options.fade === false) {
                targetSlide = _.currentSlide;
                if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
                    _.animateSlide(slideLeft, function() {
                        _.postSlide(targetSlide);
                    });
                } else {
                    _.postSlide(targetSlide);
                }
            }
            return;
        } else if (_.options.infinite === false && _.options.centerMode === true && (index < 0 || index > (_.slideCount - _.options.slidesToScroll))) {
            if (_.options.fade === false) {
                targetSlide = _.currentSlide;
                if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
                    _.animateSlide(slideLeft, function() {
                        _.postSlide(targetSlide);
                    });
                } else {
                    _.postSlide(targetSlide);
                }
            }
            return;
        }

        if ( _.options.autoplay ) {
            clearInterval(_.autoPlayTimer);
        }

        if (targetSlide < 0) {
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                animSlide = _.slideCount - (_.slideCount % _.options.slidesToScroll);
            } else {
                animSlide = _.slideCount + targetSlide;
            }
        } else if (targetSlide >= _.slideCount) {
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                animSlide = 0;
            } else {
                animSlide = targetSlide - _.slideCount;
            }
        } else {
            animSlide = targetSlide;
        }

        _.animating = true;

        _.$slider.trigger('beforeChange', [_, _.currentSlide, animSlide]);

        oldSlide = _.currentSlide;
        _.currentSlide = animSlide;

        _.setSlideClasses(_.currentSlide);

        if ( _.options.asNavFor ) {

            navTarget = _.getNavTarget();
            navTarget = navTarget.slick('getSlick');

            if ( navTarget.slideCount <= navTarget.options.slidesToShow ) {
                navTarget.setSlideClasses(_.currentSlide);
            }

        }

        _.updateDots();
        _.updateArrows();

        if (_.options.fade === true) {
            if (dontAnimate !== true) {

                _.fadeSlideOut(oldSlide);

                _.fadeSlide(animSlide, function() {
                    _.postSlide(animSlide);
                });

            } else {
                _.postSlide(animSlide);
            }
            _.animateHeight();
            return;
        }

        if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
            _.animateSlide(targetLeft, function() {
                _.postSlide(animSlide);
            });
        } else {
            _.postSlide(animSlide);
        }

    };

    Slick.prototype.startLoad = function() {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

            _.$prevArrow.hide();
            _.$nextArrow.hide();

        }

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

            _.$dots.hide();

        }

        _.$slider.addClass('slick-loading');

    };

    Slick.prototype.swipeDirection = function() {

        var xDist, yDist, r, swipeAngle, _ = this;

        xDist = _.touchObject.startX - _.touchObject.curX;
        yDist = _.touchObject.startY - _.touchObject.curY;
        r = Math.atan2(yDist, xDist);

        swipeAngle = Math.round(r * 180 / Math.PI);
        if (swipeAngle < 0) {
            swipeAngle = 360 - Math.abs(swipeAngle);
        }

        if ((swipeAngle <= 45) && (swipeAngle >= 0)) {
            return (_.options.rtl === false ? 'left' : 'right');
        }
        if ((swipeAngle <= 360) && (swipeAngle >= 315)) {
            return (_.options.rtl === false ? 'left' : 'right');
        }
        if ((swipeAngle >= 135) && (swipeAngle <= 225)) {
            return (_.options.rtl === false ? 'right' : 'left');
        }
        if (_.options.verticalSwiping === true) {
            if ((swipeAngle >= 35) && (swipeAngle <= 135)) {
                return 'down';
            } else {
                return 'up';
            }
        }

        return 'vertical';

    };

    Slick.prototype.swipeEnd = function(event) {

        var _ = this,
            slideCount,
            direction;

        _.dragging = false;
        _.swiping = false;

        if (_.scrolling) {
            _.scrolling = false;
            return false;
        }

        _.interrupted = false;
        _.shouldClick = ( _.touchObject.swipeLength > 10 ) ? false : true;

        if ( _.touchObject.curX === undefined ) {
            return false;
        }

        if ( _.touchObject.edgeHit === true ) {
            _.$slider.trigger('edge', [_, _.swipeDirection() ]);
        }

        if ( _.touchObject.swipeLength >= _.touchObject.minSwipe ) {

            direction = _.swipeDirection();

            switch ( direction ) {

                case 'left':
                case 'down':

                    slideCount =
                        _.options.swipeToSlide ?
                            _.checkNavigable( _.currentSlide + _.getSlideCount() ) :
                            _.currentSlide + _.getSlideCount();

                    _.currentDirection = 0;

                    break;

                case 'right':
                case 'up':

                    slideCount =
                        _.options.swipeToSlide ?
                            _.checkNavigable( _.currentSlide - _.getSlideCount() ) :
                            _.currentSlide - _.getSlideCount();

                    _.currentDirection = 1;

                    break;

                default:


            }

            if( direction != 'vertical' ) {

                _.slideHandler( slideCount );
                _.touchObject = {};
                _.$slider.trigger('swipe', [_, direction ]);

            }

        } else {

            if ( _.touchObject.startX !== _.touchObject.curX ) {

                _.slideHandler( _.currentSlide );
                _.touchObject = {};

            }

        }

    };

    Slick.prototype.swipeHandler = function(event) {

        var _ = this;

        if ((_.options.swipe === false) || ('ontouchend' in document && _.options.swipe === false)) {
            return;
        } else if (_.options.draggable === false && event.type.indexOf('mouse') !== -1) {
            return;
        }

        _.touchObject.fingerCount = event.originalEvent && event.originalEvent.touches !== undefined ?
            event.originalEvent.touches.length : 1;

        _.touchObject.minSwipe = _.listWidth / _.options
                .touchThreshold;

        if (_.options.verticalSwiping === true) {
            _.touchObject.minSwipe = _.listHeight / _.options
                    .touchThreshold;
        }

        switch (event.data.action) {

            case 'start':
                _.swipeStart(event);
                break;

            case 'move':
                _.swipeMove(event);
                break;

            case 'end':
                _.swipeEnd(event);
                break;

        }

    };

    Slick.prototype.swipeMove = function(event) {

        var _ = this,
            edgeWasHit = false,
            curLeft, swipeDirection, swipeLength, positionOffset, touches, verticalSwipeLength;

        touches = event.originalEvent !== undefined ? event.originalEvent.touches : null;

        if (!_.dragging || _.scrolling || touches && touches.length !== 1) {
            return false;
        }

        curLeft = _.getLeft(_.currentSlide);

        _.touchObject.curX = touches !== undefined ? touches[0].pageX : event.clientX;
        _.touchObject.curY = touches !== undefined ? touches[0].pageY : event.clientY;

        _.touchObject.swipeLength = Math.round(Math.sqrt(
            Math.pow(_.touchObject.curX - _.touchObject.startX, 2)));

        verticalSwipeLength = Math.round(Math.sqrt(
            Math.pow(_.touchObject.curY - _.touchObject.startY, 2)));

        if (!_.options.verticalSwiping && !_.swiping && verticalSwipeLength > 4) {
            _.scrolling = true;
            return false;
        }

        if (_.options.verticalSwiping === true) {
            _.touchObject.swipeLength = verticalSwipeLength;
        }

        swipeDirection = _.swipeDirection();

        if (event.originalEvent !== undefined && _.touchObject.swipeLength > 4) {
            _.swiping = true;
            event.preventDefault();
        }

        positionOffset = (_.options.rtl === false ? 1 : -1) * (_.touchObject.curX > _.touchObject.startX ? 1 : -1);
        if (_.options.verticalSwiping === true) {
            positionOffset = _.touchObject.curY > _.touchObject.startY ? 1 : -1;
        }


        swipeLength = _.touchObject.swipeLength;

        _.touchObject.edgeHit = false;

        if (_.options.infinite === false) {
            if ((_.currentSlide === 0 && swipeDirection === 'right') || (_.currentSlide >= _.getDotCount() && swipeDirection === 'left')) {
                swipeLength = _.touchObject.swipeLength * _.options.edgeFriction;
                _.touchObject.edgeHit = true;
            }
        }

        if (_.options.vertical === false) {
            _.swipeLeft = curLeft + swipeLength * positionOffset;
        } else {
            _.swipeLeft = curLeft + (swipeLength * (_.$list.height() / _.listWidth)) * positionOffset;
        }
        if (_.options.verticalSwiping === true) {
            _.swipeLeft = curLeft + swipeLength * positionOffset;
        }

        if (_.options.fade === true || _.options.touchMove === false) {
            return false;
        }

        if (_.animating === true) {
            _.swipeLeft = null;
            return false;
        }

        _.setCSS(_.swipeLeft);

    };

    Slick.prototype.swipeStart = function(event) {

        var _ = this,
            touches;

        _.interrupted = true;

        if (_.touchObject.fingerCount !== 1 || _.slideCount <= _.options.slidesToShow) {
            _.touchObject = {};
            return false;
        }

        if (event.originalEvent !== undefined && event.originalEvent.touches !== undefined) {
            touches = event.originalEvent.touches[0];
        }

        _.touchObject.startX = _.touchObject.curX = touches !== undefined ? touches.pageX : event.clientX;
        _.touchObject.startY = _.touchObject.curY = touches !== undefined ? touches.pageY : event.clientY;

        _.dragging = true;

    };

    Slick.prototype.unfilterSlides = Slick.prototype.slickUnfilter = function() {

        var _ = this;

        if (_.$slidesCache !== null) {

            _.unload();

            _.$slideTrack.children(this.options.slide).detach();

            _.$slidesCache.appendTo(_.$slideTrack);

            _.reinit();

        }

    };

    Slick.prototype.unload = function() {

        var _ = this;

        $('.slick-cloned', _.$slider).remove();

        if (_.$dots) {
            _.$dots.remove();
        }

        if (_.$prevArrow && _.htmlExpr.test(_.options.prevArrow)) {
            _.$prevArrow.remove();
        }

        if (_.$nextArrow && _.htmlExpr.test(_.options.nextArrow)) {
            _.$nextArrow.remove();
        }

        _.$slides
            .removeClass('slick-slide slick-active slick-visible slick-current')
            .attr('aria-hidden', 'true')
            .css('width', '');

    };

    Slick.prototype.unslick = function(fromBreakpoint) {

        var _ = this;
        _.$slider.trigger('unslick', [_, fromBreakpoint]);
        _.destroy();

    };

    Slick.prototype.updateArrows = function() {

        var _ = this,
            centerOffset;

        centerOffset = Math.floor(_.options.slidesToShow / 2);

        if ( _.options.arrows === true &&
            _.slideCount > _.options.slidesToShow &&
            !_.options.infinite ) {

            _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
            _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            if (_.currentSlide === 0) {

                _.$prevArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow && _.options.centerMode === false) {

                _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            } else if (_.currentSlide >= _.slideCount - 1 && _.options.centerMode === true) {

                _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            }

        }

    };

    Slick.prototype.updateDots = function() {

        var _ = this;

        if (_.$dots !== null) {

            _.$dots
                .find('li')
                .removeClass('slick-active')
                .end();

            _.$dots
                .find('li')
                .eq(Math.floor(_.currentSlide / _.options.slidesToScroll))
                .addClass('slick-active');

        }

    };

    Slick.prototype.visibility = function() {

        var _ = this;

        if ( _.options.autoplay ) {

            if ( document[_.hidden] ) {

                _.interrupted = true;

            } else {

                _.interrupted = false;

            }

        }

    };

    $.fn.slick = function() {
        var _ = this,
            opt = arguments[0],
            args = Array.prototype.slice.call(arguments, 1),
            l = _.length,
            i,
            ret;
        for (i = 0; i < l; i++) {
            if (typeof opt == 'object' || typeof opt == 'undefined')
                _[i].slick = new Slick(_[i], opt);
            else
                ret = _[i].slick[opt].apply(_[i].slick, args);
            if (typeof ret != 'undefined') return ret;
        }
        return _;
    };

}));
/**
 * tooltipster http://iamceege.github.io/tooltipster/
 * A rockin' custom tooltip jQuery plugin
 * Developed by Caleb Jacob and Louis Ameline
 * MIT license
 */
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module unless amdModuleId is set
        define(["jquery"], function (a0) {
            return (factory(a0));
        });
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory(require("jquery"));
    } else {
        factory(jQuery);
    }
}(this, function ($) {

// This file will be UMDified by a build task.

    var defaults = {
            animation: 'fade',
            animationDuration: 350,
            content: null,
            contentAsHTML: false,
            contentCloning: false,
            debug: true,
            delay: 300,
            delayTouch: [300, 500],
            functionInit: null,
            functionBefore: null,
            functionReady: null,
            functionAfter: null,
            functionFormat: null,
            IEmin: 6,
            interactive: false,
            multiple: false,
            // will default to document.body, or must be an element positioned at (0, 0)
            // in the document, typically like the very top views of an app.
            parent: null,
            plugins: ['sideTip'],
            repositionOnScroll: false,
            restoration: 'none',
            selfDestruction: true,
            theme: [],
            timer: 0,
            trackerInterval: 500,
            trackOrigin: false,
            trackTooltip: false,
            trigger: 'hover',
            triggerClose: {
                click: false,
                mouseleave: false,
                originClick: false,
                scroll: false,
                tap: false,
                touchleave: false
            },
            triggerOpen: {
                click: false,
                mouseenter: false,
                tap: false,
                touchstart: false
            },
            updateAnimation: 'rotate',
            zIndex: 9999999
        },
        // we'll avoid using the 'window' global as a good practice but npm's
        // jquery@<2.1.0 package actually requires a 'window' global, so not sure
        // it's useful at all
        win = (typeof window != 'undefined') ? window : null,
        // env will be proxied by the core for plugins to have access its properties
        env = {
            // detect if this device can trigger touch events. Better have a false
            // positive (unused listeners, that's ok) than a false negative.
            // https://github.com/Modernizr/Modernizr/blob/master/feature-detects/touchevents.js
            // http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript
            hasTouchCapability: !!(
                win
                &&	(	'ontouchstart' in win
                    ||	(win.DocumentTouch && win.document instanceof win.DocumentTouch)
                    ||	win.navigator.maxTouchPoints
                )
            ),
            hasTransitions: transitionSupport(),
            IE: false,
            // don't set manually, it will be updated by a build task after the manifest
            semVer: '4.2.6',
            window: win
        },
        core = function() {

            // core variables

            // the core emitters
            this.__$emitterPrivate = $({});
            this.__$emitterPublic = $({});
            this.__instancesLatestArr = [];
            // collects plugin constructors
            this.__plugins = {};
            // proxy env variables for plugins who might use them
            this._env = env;
        };

// core methods
    core.prototype = {

        /**
         * A function to proxy the public methods of an object onto another
         *
         * @param {object} constructor The constructor to bridge
         * @param {object} obj The object that will get new methods (an instance or the core)
         * @param {string} pluginName A plugin name for the console log message
         * @return {core}
         * @private
         */
        __bridge: function(constructor, obj, pluginName) {

            // if it's not already bridged
            if (!obj[pluginName]) {

                var fn = function() {};
                fn.prototype = constructor;

                var pluginInstance = new fn();

                // the _init method has to exist in instance constructors but might be missing
                // in core constructors
                if (pluginInstance.__init) {
                    pluginInstance.__init(obj);
                }

                $.each(constructor, function(methodName, fn) {

                    // don't proxy "private" methods, only "protected" and public ones
                    if (methodName.indexOf('__') != 0) {

                        // if the method does not exist yet
                        if (!obj[methodName]) {

                            obj[methodName] = function() {
                                return pluginInstance[methodName].apply(pluginInstance, Array.prototype.slice.apply(arguments));
                            };

                            // remember to which plugin this method corresponds (several plugins may
                            // have methods of the same name, we need to be sure)
                            obj[methodName].bridged = pluginInstance;
                        }
                        else if (defaults.debug) {

                            console.log('The '+ methodName +' method of the '+ pluginName
                                +' plugin conflicts with another plugin or native methods');
                        }
                    }
                });

                obj[pluginName] = pluginInstance;
            }

            return this;
        },

        /**
         * For mockup in Node env if need be, for testing purposes
         *
         * @return {core}
         * @private
         */
        __setWindow: function(window) {
            env.window = window;
            return this;
        },

        /**
         * Returns a ruler, a tool to help measure the size of a tooltip under
         * various settings. Meant for plugins
         *
         * @see Ruler
         * @return {object} A Ruler instance
         * @protected
         */
        _getRuler: function($tooltip) {
            return new Ruler($tooltip);
        },

        /**
         * For internal use by plugins, if needed
         *
         * @return {core}
         * @protected
         */
        _off: function() {
            this.__$emitterPrivate.off.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments));
            return this;
        },

        /**
         * For internal use by plugins, if needed
         *
         * @return {core}
         * @protected
         */
        _on: function() {
            this.__$emitterPrivate.on.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments));
            return this;
        },

        /**
         * For internal use by plugins, if needed
         *
         * @return {core}
         * @protected
         */
        _one: function() {
            this.__$emitterPrivate.one.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments));
            return this;
        },

        /**
         * Returns (getter) or adds (setter) a plugin
         *
         * @param {string|object} plugin Provide a string (in the full form
         * "namespace.name") to use as as getter, an object to use as a setter
         * @return {object|core}
         * @protected
         */
        _plugin: function(plugin) {

            var self = this;

            // getter
            if (typeof plugin == 'string') {

                var pluginName = plugin,
                    p = null;

                // if the namespace is provided, it's easy to search
                if (pluginName.indexOf('.') > 0) {
                    p = self.__plugins[pluginName];
                }
                // otherwise, return the first name that matches
                else {
                    $.each(self.__plugins, function(i, plugin) {

                        if (plugin.name.substring(plugin.name.length - pluginName.length - 1) == '.'+ pluginName) {
                            p = plugin;
                            return false;
                        }
                    });
                }

                return p;
            }
            // setter
            else {

                // force namespaces
                if (plugin.name.indexOf('.') < 0) {
                    throw new Error('Plugins must be namespaced');
                }

                self.__plugins[plugin.name] = plugin;

                // if the plugin has core features
                if (plugin.core) {

                    // bridge non-private methods onto the core to allow new core methods
                    self.__bridge(plugin.core, self, plugin.name);
                }

                return this;
            }
        },

        /**
         * Trigger events on the core emitters
         *
         * @returns {core}
         * @protected
         */
        _trigger: function() {

            var args = Array.prototype.slice.apply(arguments);

            if (typeof args[0] == 'string') {
                args[0] = { type: args[0] };
            }

            // note: the order of emitters matters
            this.__$emitterPrivate.trigger.apply(this.__$emitterPrivate, args);
            this.__$emitterPublic.trigger.apply(this.__$emitterPublic, args);

            return this;
        },

        /**
         * Returns instances of all tooltips in the page or an a given element
         *
         * @param {string|HTML object collection} selector optional Use this
         * parameter to restrict the set of objects that will be inspected
         * for the retrieval of instances. By default, all instances in the
         * page are returned.
         * @return {array} An array of instance objects
         * @public
         */
        instances: function(selector) {

            var instances = [],
                sel = selector || '.tooltipstered';

            $(sel).each(function() {

                var $this = $(this),
                    ns = $this.data('tooltipster-ns');

                if (ns) {

                    $.each(ns, function(i, namespace) {
                        instances.push($this.data(namespace));
                    });
                }
            });

            return instances;
        },

        /**
         * Returns the Tooltipster objects generated by the last initializing call
         *
         * @return {array} An array of instance objects
         * @public
         */
        instancesLatest: function() {
            return this.__instancesLatestArr;
        },

        /**
         * For public use only, not to be used by plugins (use ::_off() instead)
         *
         * @return {core}
         * @public
         */
        off: function() {
            this.__$emitterPublic.off.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
            return this;
        },

        /**
         * For public use only, not to be used by plugins (use ::_on() instead)
         *
         * @return {core}
         * @public
         */
        on: function() {
            this.__$emitterPublic.on.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
            return this;
        },

        /**
         * For public use only, not to be used by plugins (use ::_one() instead)
         *
         * @return {core}
         * @public
         */
        one: function() {
            this.__$emitterPublic.one.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
            return this;
        },

        /**
         * Returns all HTML elements which have one or more tooltips
         *
         * @param {string} selector optional Use this to restrict the results
         * to the descendants of an element
         * @return {array} An array of HTML elements
         * @public
         */
        origins: function(selector) {

            var sel = selector ?
                selector +' ' :
                '';

            return $(sel +'.tooltipstered').toArray();
        },

        /**
         * Change default options for all future instances
         *
         * @param {object} d The options that should be made defaults
         * @return {core}
         * @public
         */
        setDefaults: function(d) {
            $.extend(defaults, d);
            return this;
        },

        /**
         * For users to trigger their handlers on the public emitter
         *
         * @returns {core}
         * @public
         */
        triggerHandler: function() {
            this.__$emitterPublic.triggerHandler.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
            return this;
        }
    };

// $.tooltipster will be used to call core methods
    $.tooltipster = new core();

// the Tooltipster instance class (mind the capital T)
    $.Tooltipster = function(element, options) {

        // list of instance variables

        // stack of custom callbacks provided as parameters to API methods
        this.__callbacks = {
            close: [],
            open: []
        };
        // the schedule time of DOM removal
        this.__closingTime;
        // this will be the user content shown in the tooltip. A capital "C" is used
        // because there is also a method called content()
        this.__Content;
        // for the size tracker
        this.__contentBcr;
        // to disable the tooltip after destruction
        this.__destroyed = false;
        // we can't emit directly on the instance because if a method with the same
        // name as the event exists, it will be called by jQuery. Se we use a plain
        // object as emitter. This emitter is for internal use by plugins,
        // if needed.
        this.__$emitterPrivate = $({});
        // this emitter is for the user to listen to events without risking to mess
        // with our internal listeners
        this.__$emitterPublic = $({});
        this.__enabled = true;
        // the reference to the gc interval
        this.__garbageCollector;
        // various position and size data recomputed before each repositioning
        this.__Geometry;
        // the tooltip position, saved after each repositioning by a plugin
        this.__lastPosition;
        // a unique namespace per instance
        this.__namespace = 'tooltipster-'+ Math.round(Math.random()*1000000);
        this.__options;
        // will be used to support origins in scrollable areas
        this.__$originParents;
        this.__pointerIsOverOrigin = false;
        // to remove themes if needed
        this.__previousThemes = [];
        // the state can be either: appearing, stable, disappearing, closed
        this.__state = 'closed';
        // timeout references
        this.__timeouts = {
            close: [],
            open: null
        };
        // store touch events to be able to detect emulated mouse events
        this.__touchEvents = [];
        // the reference to the tracker interval
        this.__tracker = null;
        // the element to which this tooltip is associated
        this._$origin;
        // this will be the tooltip element (jQuery wrapped HTML element).
        // It's the job of a plugin to create it and append it to the DOM
        this._$tooltip;

        // launch
        this.__init(element, options);
    };

    $.Tooltipster.prototype = {

        /**
         * @param origin
         * @param options
         * @private
         */
        __init: function(origin, options) {

            var self = this;

            self._$origin = $(origin);
            self.__options = $.extend(true, {}, defaults, options);

            // some options may need to be reformatted
            self.__optionsFormat();

            // don't run on old IE if asked no to
            if (	!env.IE
                ||	env.IE >= self.__options.IEmin
            ) {

                // note: the content is null (empty) by default and can stay that
                // way if the plugin remains initialized but not fed any content. The
                // tooltip will just not appear.

                // let's save the initial value of the title attribute for later
                // restoration if need be.
                var initialTitle = null;

                // it will already have been saved in case of multiple tooltips
                if (self._$origin.data('tooltipster-initialTitle') === undefined) {

                    initialTitle = self._$origin.attr('title');

                    // we do not want initialTitle to be "undefined" because
                    // of how jQuery's .data() method works
                    if (initialTitle === undefined) initialTitle = null;

                    self._$origin.data('tooltipster-initialTitle', initialTitle);
                }

                // If content is provided in the options, it has precedence over the
                // title attribute.
                // Note: an empty string is considered content, only 'null' represents
                // the absence of content.
                // Also, an existing title="" attribute will result in an empty string
                // content
                if (self.__options.content !== null) {
                    self.__contentSet(self.__options.content);
                }
                else {

                    var selector = self._$origin.attr('data-tooltip-content'),
                        $el;

                    if (selector){
                        $el = $(selector);
                    }

                    if ($el && $el[0]) {
                        self.__contentSet($el.first());
                    }
                    else {
                        self.__contentSet(initialTitle);
                    }
                }

                self._$origin
                // strip the title off of the element to prevent the default tooltips
                // from popping up
                    .removeAttr('title')
                    // to be able to find all instances on the page later (upon window
                    // events in particular)
                    .addClass('tooltipstered');

                // set listeners on the origin
                self.__prepareOrigin();

                // set the garbage collector
                self.__prepareGC();

                // init plugins
                $.each(self.__options.plugins, function(i, pluginName) {
                    self._plug(pluginName);
                });

                // to detect swiping
                if (env.hasTouchCapability) {
                    $(env.window.document.body).on('touchmove.'+ self.__namespace +'-triggerOpen', function(event) {
                        self._touchRecordEvent(event);
                    });
                }

                self
                // prepare the tooltip when it gets created. This event must
                // be fired by a plugin
                    ._on('created', function() {
                        self.__prepareTooltip();
                    })
                    // save position information when it's sent by a plugin
                    ._on('repositioned', function(e) {
                        self.__lastPosition = e.position;
                    });
            }
            else {
                self.__options.disabled = true;
            }
        },

        /**
         * Insert the content into the appropriate HTML element of the tooltip
         *
         * @returns {self}
         * @private
         */
        __contentInsert: function() {

            var self = this,
                $el = self._$tooltip.find('.tooltipster-content'),
                formattedContent = self.__Content,
                format = function(content) {
                    formattedContent = content;
                };

            self._trigger({
                type: 'format',
                content: self.__Content,
                format: format
            });

            if (self.__options.functionFormat) {

                formattedContent = self.__options.functionFormat.call(
                    self,
                    self,
                    { origin: self._$origin[0] },
                    self.__Content
                );
            }

            if (typeof formattedContent === 'string' && !self.__options.contentAsHTML) {
                $el.text(formattedContent);
            }
            else {
                $el
                    .empty()
                    .append(formattedContent);
            }

            return self;
        },

        /**
         * Save the content, cloning it beforehand if need be
         *
         * @param content
         * @returns {self}
         * @private
         */
        __contentSet: function(content) {

            // clone if asked. Cloning the object makes sure that each instance has its
            // own version of the content (in case a same object were provided for several
            // instances)
            // reminder: typeof null === object
            if (content instanceof $ && this.__options.contentCloning) {
                content = content.clone(true);
            }

            this.__Content = content;

            this._trigger({
                type: 'updated',
                content: content
            });

            return this;
        },

        /**
         * Error message about a method call made after destruction
         *
         * @private
         */
        __destroyError: function() {
            throw new Error('This tooltip has been destroyed and cannot execute your method call.');
        },

        /**
         * Gather all information about dimensions and available space,
         * called before every repositioning
         *
         * @private
         * @returns {object}
         */
        __geometry: function() {

            var	self = this,
                $target = self._$origin,
                originIsArea = self._$origin.is('area');

            // if this._$origin is a map area, the target we'll need
            // the dimensions of is actually the image using the map,
            // not the area itself
            if (originIsArea) {

                var mapName = self._$origin.parent().attr('name');

                $target = $('img[usemap="#'+ mapName +'"]');
            }

            var bcr = $target[0].getBoundingClientRect(),
                $document = $(env.window.document),
                $window = $(env.window),
                $parent = $target,
                // some useful properties of important elements
                geo = {
                    // available space for the tooltip, see down below
                    available: {
                        document: null,
                        window: null
                    },
                    document: {
                        size: {
                            height: $document.height(),
                            width: $document.width()
                        }
                    },
                    window: {
                        scroll: {
                            // the second ones are for IE compatibility
                            left: env.window.scrollX || env.window.document.documentElement.scrollLeft,
                            top: env.window.scrollY || env.window.document.documentElement.scrollTop
                        },
                        size: {
                            height: $window.height(),
                            width: $window.width()
                        }
                    },
                    origin: {
                        // the origin has a fixed lineage if itself or one of its
                        // ancestors has a fixed position
                        fixedLineage: false,
                        // relative to the document
                        offset: {},
                        size: {
                            height: bcr.bottom - bcr.top,
                            width: bcr.right - bcr.left
                        },
                        usemapImage: originIsArea ? $target[0] : null,
                        // relative to the window
                        windowOffset: {
                            bottom: bcr.bottom,
                            left: bcr.left,
                            right: bcr.right,
                            top: bcr.top
                        }
                    }
                },
                geoFixed = false;

            // if the element is a map area, some properties may need
            // to be recalculated
            if (originIsArea) {

                var shape = self._$origin.attr('shape'),
                    coords = self._$origin.attr('coords');

                if (coords) {

                    coords = coords.split(',');

                    $.map(coords, function(val, i) {
                        coords[i] = parseInt(val);
                    });
                }

                // if the image itself is the area, nothing more to do
                if (shape != 'default') {

                    switch(shape) {

                        case 'circle':

                            var circleCenterLeft = coords[0],
                                circleCenterTop = coords[1],
                                circleRadius = coords[2],
                                areaTopOffset = circleCenterTop - circleRadius,
                                areaLeftOffset = circleCenterLeft - circleRadius;

                            geo.origin.size.height = circleRadius * 2;
                            geo.origin.size.width = geo.origin.size.height;

                            geo.origin.windowOffset.left += areaLeftOffset;
                            geo.origin.windowOffset.top += areaTopOffset;

                            break;

                        case 'rect':

                            var areaLeft = coords[0],
                                areaTop = coords[1],
                                areaRight = coords[2],
                                areaBottom = coords[3];

                            geo.origin.size.height = areaBottom - areaTop;
                            geo.origin.size.width = areaRight - areaLeft;

                            geo.origin.windowOffset.left += areaLeft;
                            geo.origin.windowOffset.top += areaTop;

                            break;

                        case 'poly':

                            var areaSmallestX = 0,
                                areaSmallestY = 0,
                                areaGreatestX = 0,
                                areaGreatestY = 0,
                                arrayAlternate = 'even';

                            for (var i = 0; i < coords.length; i++) {

                                var areaNumber = coords[i];

                                if (arrayAlternate == 'even') {

                                    if (areaNumber > areaGreatestX) {

                                        areaGreatestX = areaNumber;

                                        if (i === 0) {
                                            areaSmallestX = areaGreatestX;
                                        }
                                    }

                                    if (areaNumber < areaSmallestX) {
                                        areaSmallestX = areaNumber;
                                    }

                                    arrayAlternate = 'odd';
                                }
                                else {
                                    if (areaNumber > areaGreatestY) {

                                        areaGreatestY = areaNumber;

                                        if (i == 1) {
                                            areaSmallestY = areaGreatestY;
                                        }
                                    }

                                    if (areaNumber < areaSmallestY) {
                                        areaSmallestY = areaNumber;
                                    }

                                    arrayAlternate = 'even';
                                }
                            }

                            geo.origin.size.height = areaGreatestY - areaSmallestY;
                            geo.origin.size.width = areaGreatestX - areaSmallestX;

                            geo.origin.windowOffset.left += areaSmallestX;
                            geo.origin.windowOffset.top += areaSmallestY;

                            break;
                    }
                }
            }

            // user callback through an event
            var edit = function(r) {
                geo.origin.size.height = r.height,
                    geo.origin.windowOffset.left = r.left,
                    geo.origin.windowOffset.top = r.top,
                    geo.origin.size.width = r.width
            };

            self._trigger({
                type: 'geometry',
                edit: edit,
                geometry: {
                    height: geo.origin.size.height,
                    left: geo.origin.windowOffset.left,
                    top: geo.origin.windowOffset.top,
                    width: geo.origin.size.width
                }
            });

            // calculate the remaining properties with what we got

            geo.origin.windowOffset.right = geo.origin.windowOffset.left + geo.origin.size.width;
            geo.origin.windowOffset.bottom = geo.origin.windowOffset.top + geo.origin.size.height;

            geo.origin.offset.left = geo.origin.windowOffset.left + geo.window.scroll.left;
            geo.origin.offset.top = geo.origin.windowOffset.top + geo.window.scroll.top;
            geo.origin.offset.bottom = geo.origin.offset.top + geo.origin.size.height;
            geo.origin.offset.right = geo.origin.offset.left + geo.origin.size.width;

            // the space that is available to display the tooltip relatively to the document
            geo.available.document = {
                bottom: {
                    height: geo.document.size.height - geo.origin.offset.bottom,
                    width: geo.document.size.width
                },
                left: {
                    height: geo.document.size.height,
                    width: geo.origin.offset.left
                },
                right: {
                    height: geo.document.size.height,
                    width: geo.document.size.width - geo.origin.offset.right
                },
                top: {
                    height: geo.origin.offset.top,
                    width: geo.document.size.width
                }
            };

            // the space that is available to display the tooltip relatively to the viewport
            // (the resulting values may be negative if the origin overflows the viewport)
            geo.available.window = {
                bottom: {
                    // the inner max is here to make sure the available height is no bigger
                    // than the viewport height (when the origin is off screen at the top).
                    // The outer max just makes sure that the height is not negative (when
                    // the origin overflows at the bottom).
                    height: Math.max(geo.window.size.height - Math.max(geo.origin.windowOffset.bottom, 0), 0),
                    width: geo.window.size.width
                },
                left: {
                    height: geo.window.size.height,
                    width: Math.max(geo.origin.windowOffset.left, 0)
                },
                right: {
                    height: geo.window.size.height,
                    width: Math.max(geo.window.size.width - Math.max(geo.origin.windowOffset.right, 0), 0)
                },
                top: {
                    height: Math.max(geo.origin.windowOffset.top, 0),
                    width: geo.window.size.width
                }
            };

            while ($parent[0].tagName.toLowerCase() != 'html') {

                if ($parent.css('position') == 'fixed') {
                    geo.origin.fixedLineage = true;
                    break;
                }

                $parent = $parent.parent();
            }

            return geo;
        },

        /**
         * Some options may need to be formated before being used
         *
         * @returns {self}
         * @private
         */
        __optionsFormat: function() {

            if (typeof this.__options.animationDuration == 'number') {
                this.__options.animationDuration = [this.__options.animationDuration, this.__options.animationDuration];
            }

            if (typeof this.__options.delay == 'number') {
                this.__options.delay = [this.__options.delay, this.__options.delay];
            }

            if (typeof this.__options.delayTouch == 'number') {
                this.__options.delayTouch = [this.__options.delayTouch, this.__options.delayTouch];
            }

            if (typeof this.__options.theme == 'string') {
                this.__options.theme = [this.__options.theme];
            }

            // determine the future parent
            if (this.__options.parent === null) {
                this.__options.parent = $(env.window.document.body);
            }
            else if (typeof this.__options.parent == 'string') {
                this.__options.parent = $(this.__options.parent);
            }

            if (this.__options.trigger == 'hover') {

                this.__options.triggerOpen = {
                    mouseenter: true,
                    touchstart: true
                };

                this.__options.triggerClose = {
                    mouseleave: true,
                    originClick: true,
                    touchleave: true
                };
            }
            else if (this.__options.trigger == 'click') {

                this.__options.triggerOpen = {
                    click: true,
                    tap: true
                };

                this.__options.triggerClose = {
                    click: true,
                    tap: true
                };
            }

            // for the plugins
            this._trigger('options');

            return this;
        },

        /**
         * Schedules or cancels the garbage collector task
         *
         * @returns {self}
         * @private
         */
        __prepareGC: function() {

            var self = this;

            // in case the selfDestruction option has been changed by a method call
            if (self.__options.selfDestruction) {

                // the GC task
                self.__garbageCollector = setInterval(function() {

                    var now = new Date().getTime();

                    // forget the old events
                    self.__touchEvents = $.grep(self.__touchEvents, function(event, i) {
                        // 1 minute
                        return now - event.time > 60000;
                    });

                    // auto-destruct if the origin is gone
                    if (!bodyContains(self._$origin)) {

                        self.close(function(){
                            self.destroy();
                        });
                    }
                }, 20000);
            }
            else {
                clearInterval(self.__garbageCollector);
            }

            return self;
        },

        /**
         * Sets listeners on the origin if the open triggers require them.
         * Unlike the listeners set at opening time, these ones
         * remain even when the tooltip is closed. It has been made a
         * separate method so it can be called when the triggers are
         * changed in the options. Closing is handled in _open()
         * because of the bindings that may be needed on the tooltip
         * itself
         *
         * @returns {self}
         * @private
         */
        __prepareOrigin: function() {

            var self = this;

            // in case we're resetting the triggers
            self._$origin.off('.'+ self.__namespace +'-triggerOpen');

            // if the device is touch capable, even if only mouse triggers
            // are asked, we need to listen to touch events to know if the mouse
            // events are actually emulated (so we can ignore them)
            if (env.hasTouchCapability) {

                self._$origin.on(
                    'touchstart.'+ self.__namespace +'-triggerOpen ' +
                    'touchend.'+ self.__namespace +'-triggerOpen ' +
                    'touchcancel.'+ self.__namespace +'-triggerOpen',
                    function(event){
                        self._touchRecordEvent(event);
                    }
                );
            }

            // mouse click and touch tap work the same way
            if (	self.__options.triggerOpen.click
                ||	(self.__options.triggerOpen.tap && env.hasTouchCapability)
            ) {

                var eventNames = '';
                if (self.__options.triggerOpen.click) {
                    eventNames += 'click.'+ self.__namespace +'-triggerOpen ';
                }
                if (self.__options.triggerOpen.tap && env.hasTouchCapability) {
                    eventNames += 'touchend.'+ self.__namespace +'-triggerOpen';
                }

                self._$origin.on(eventNames, function(event) {
                    if (self._touchIsMeaningfulEvent(event)) {
                        self._open(event);
                    }
                });
            }

            // mouseenter and touch start work the same way
            if (	self.__options.triggerOpen.mouseenter
                ||	(self.__options.triggerOpen.touchstart && env.hasTouchCapability)
            ) {

                var eventNames = '';
                if (self.__options.triggerOpen.mouseenter) {
                    eventNames += 'mouseenter.'+ self.__namespace +'-triggerOpen ';
                }
                if (self.__options.triggerOpen.touchstart && env.hasTouchCapability) {
                    eventNames += 'touchstart.'+ self.__namespace +'-triggerOpen';
                }

                self._$origin.on(eventNames, function(event) {
                    if (	self._touchIsTouchEvent(event)
                        ||	!self._touchIsEmulatedEvent(event)
                    ) {
                        self.__pointerIsOverOrigin = true;
                        self._openShortly(event);
                    }
                });
            }

            // info for the mouseleave/touchleave close triggers when they use a delay
            if (	self.__options.triggerClose.mouseleave
                ||	(self.__options.triggerClose.touchleave && env.hasTouchCapability)
            ) {

                var eventNames = '';
                if (self.__options.triggerClose.mouseleave) {
                    eventNames += 'mouseleave.'+ self.__namespace +'-triggerOpen ';
                }
                if (self.__options.triggerClose.touchleave && env.hasTouchCapability) {
                    eventNames += 'touchend.'+ self.__namespace +'-triggerOpen touchcancel.'+ self.__namespace +'-triggerOpen';
                }

                self._$origin.on(eventNames, function(event) {

                    if (self._touchIsMeaningfulEvent(event)) {
                        self.__pointerIsOverOrigin = false;
                    }
                });
            }

            return self;
        },

        /**
         * Do the things that need to be done only once after the tooltip
         * HTML element it has been created. It has been made a separate
         * method so it can be called when options are changed. Remember
         * that the tooltip may actually exist in the DOM before it is
         * opened, and present after it has been closed: it's the display
         * plugin that takes care of handling it.
         *
         * @returns {self}
         * @private
         */
        __prepareTooltip: function() {

            var self = this,
                p = self.__options.interactive ? 'auto' : '';

            // this will be useful to know quickly if the tooltip is in
            // the DOM or not
            self._$tooltip
                .attr('id', self.__namespace)
                .css({
                    // pointer events
                    'pointer-events': p,
                    zIndex: self.__options.zIndex
                });

            // themes
            // remove the old ones and add the new ones
            $.each(self.__previousThemes, function(i, theme) {
                self._$tooltip.removeClass(theme);
            });
            $.each(self.__options.theme, function(i, theme) {
                self._$tooltip.addClass(theme);
            });

            self.__previousThemes = $.merge([], self.__options.theme);

            return self;
        },

        /**
         * Handles the scroll on any of the parents of the origin (when the
         * tooltip is open)
         *
         * @param {object} event
         * @returns {self}
         * @private
         */
        __scrollHandler: function(event) {

            var self = this;

            if (self.__options.triggerClose.scroll) {
                self._close(event);
            }
            else {

                // if the origin or tooltip have been removed: do nothing, the tracker will
                // take care of it later
                if (bodyContains(self._$origin) && bodyContains(self._$tooltip)) {

                    var geo = null;

                    // if the scroll happened on the window
                    if (event.target === env.window.document) {

                        // if the origin has a fixed lineage, window scroll will have no
                        // effect on its position nor on the position of the tooltip
                        if (!self.__Geometry.origin.fixedLineage) {

                            // we don't need to do anything unless repositionOnScroll is true
                            // because the tooltip will already have moved with the window
                            // (and of course with the origin)
                            if (self.__options.repositionOnScroll) {
                                self.reposition(event);
                            }
                        }
                    }
                    // if the scroll happened on another parent of the tooltip, it means
                    // that it's in a scrollable area and now needs to have its position
                    // adjusted or recomputed, depending ont the repositionOnScroll
                    // option. Also, if the origin is partly hidden due to a parent that
                    // hides its overflow, we'll just hide (not close) the tooltip.
                    else {

                        geo = self.__geometry();

                        var overflows = false;

                        // a fixed position origin is not affected by the overflow hiding
                        // of a parent
                        if (self._$origin.css('position') != 'fixed') {

                            self.__$originParents.each(function(i, el) {

                                var $el = $(el),
                                    overflowX = $el.css('overflow-x'),
                                    overflowY = $el.css('overflow-y');

                                if (overflowX != 'visible' || overflowY != 'visible') {

                                    var bcr = el.getBoundingClientRect();

                                    if (overflowX != 'visible') {

                                        if (	geo.origin.windowOffset.left < bcr.left
                                            ||	geo.origin.windowOffset.right > bcr.right
                                        ) {
                                            overflows = true;
                                            return false;
                                        }
                                    }

                                    if (overflowY != 'visible') {

                                        if (	geo.origin.windowOffset.top < bcr.top
                                            ||	geo.origin.windowOffset.bottom > bcr.bottom
                                        ) {
                                            overflows = true;
                                            return false;
                                        }
                                    }
                                }

                                // no need to go further if fixed, for the same reason as above
                                if ($el.css('position') == 'fixed') {
                                    return false;
                                }
                            });
                        }

                        if (overflows) {
                            self._$tooltip.css('visibility', 'hidden');
                        }
                        else {

                            self._$tooltip.css('visibility', 'visible');

                            // reposition
                            if (self.__options.repositionOnScroll) {
                                self.reposition(event);
                            }
                            // or just adjust offset
                            else {

                                // we have to use offset and not windowOffset because this way,
                                // only the scroll distance of the scrollable areas are taken into
                                // account (the scrolltop value of the main window must be
                                // ignored since the tooltip already moves with it)
                                var offsetLeft = geo.origin.offset.left - self.__Geometry.origin.offset.left,
                                    offsetTop = geo.origin.offset.top - self.__Geometry.origin.offset.top;

                                // add the offset to the position initially computed by the display plugin
                                self._$tooltip.css({
                                    left: self.__lastPosition.coord.left + offsetLeft,
                                    top: self.__lastPosition.coord.top + offsetTop
                                });
                            }
                        }
                    }

                    self._trigger({
                        type: 'scroll',
                        event: event,
                        geo: geo
                    });
                }
            }

            return self;
        },

        /**
         * Changes the state of the tooltip
         *
         * @param {string} state
         * @returns {self}
         * @private
         */
        __stateSet: function(state) {

            this.__state = state;

            this._trigger({
                type: 'state',
                state: state
            });

            return this;
        },

        /**
         * Clear appearance timeouts
         *
         * @returns {self}
         * @private
         */
        __timeoutsClear: function() {

            // there is only one possible open timeout: the delayed opening
            // when the mouseenter/touchstart open triggers are used
            clearTimeout(this.__timeouts.open);
            this.__timeouts.open = null;

            // ... but several close timeouts: the delayed closing when the
            // mouseleave close trigger is used and the timer option
            $.each(this.__timeouts.close, function(i, timeout) {
                clearTimeout(timeout);
            });
            this.__timeouts.close = [];

            return this;
        },

        /**
         * Start the tracker that will make checks at regular intervals
         *
         * @returns {self}
         * @private
         */
        __trackerStart: function() {

            var self = this,
                $content = self._$tooltip.find('.tooltipster-content');

            // get the initial content size
            if (self.__options.trackTooltip) {
                self.__contentBcr = $content[0].getBoundingClientRect();
            }

            self.__tracker = setInterval(function() {

                // if the origin or tooltip elements have been removed.
                // Note: we could destroy the instance now if the origin has
                // been removed but we'll leave that task to our garbage collector
                if (!bodyContains(self._$origin) || !bodyContains(self._$tooltip)) {
                    self._close();
                }
                // if everything is alright
                else {

                    // compare the former and current positions of the origin to reposition
                    // the tooltip if need be
                    if (self.__options.trackOrigin) {

                        var g = self.__geometry(),
                            identical = false;

                        // compare size first (a change requires repositioning too)
                        if (areEqual(g.origin.size, self.__Geometry.origin.size)) {

                            // for elements that have a fixed lineage (see __geometry()), we track the
                            // top and left properties (relative to window)
                            if (self.__Geometry.origin.fixedLineage) {
                                if (areEqual(g.origin.windowOffset, self.__Geometry.origin.windowOffset)) {
                                    identical = true;
                                }
                            }
                            // otherwise, track total offset (relative to document)
                            else {
                                if (areEqual(g.origin.offset, self.__Geometry.origin.offset)) {
                                    identical = true;
                                }
                            }
                        }

                        if (!identical) {

                            // close the tooltip when using the mouseleave close trigger
                            // (see https://github.com/iamceege/tooltipster/pull/253)
                            if (self.__options.triggerClose.mouseleave) {
                                self._close();
                            }
                            else {
                                self.reposition();
                            }
                        }
                    }

                    if (self.__options.trackTooltip) {

                        var currentBcr = $content[0].getBoundingClientRect();

                        if (	currentBcr.height !== self.__contentBcr.height
                            ||	currentBcr.width !== self.__contentBcr.width
                        ) {
                            self.reposition();
                            self.__contentBcr = currentBcr;
                        }
                    }
                }
            }, self.__options.trackerInterval);

            return self;
        },

        /**
         * Closes the tooltip (after the closing delay)
         *
         * @param event
         * @param callback
         * @param force Set to true to override a potential refusal of the user's function
         * @returns {self}
         * @protected
         */
        _close: function(event, callback, force) {

            var self = this,
                ok = true;

            self._trigger({
                type: 'close',
                event: event,
                stop: function() {
                    ok = false;
                }
            });

            // a destroying tooltip (force == true) may not refuse to close
            if (ok || force) {

                // save the method custom callback and cancel any open method custom callbacks
                if (callback) self.__callbacks.close.push(callback);
                self.__callbacks.open = [];

                // clear open/close timeouts
                self.__timeoutsClear();

                var finishCallbacks = function() {

                    // trigger any close method custom callbacks and reset them
                    $.each(self.__callbacks.close, function(i,c) {
                        c.call(self, self, {
                            event: event,
                            origin: self._$origin[0]
                        });
                    });

                    self.__callbacks.close = [];
                };

                if (self.__state != 'closed') {

                    var necessary = true,
                        d = new Date(),
                        now = d.getTime(),
                        newClosingTime = now + self.__options.animationDuration[1];

                    // the tooltip may already already be disappearing, but if a new
                    // call to close() is made after the animationDuration was changed
                    // to 0 (for example), we ought to actually close it sooner than
                    // previously scheduled. In that case it should be noted that the
                    // browser will not adapt the animation duration to the new
                    // animationDuration that was set after the start of the closing
                    // animation.
                    // Note: the same thing could be considered at opening, but is not
                    // really useful since the tooltip is actually opened immediately
                    // upon a call to _open(). Since it would not make the opening
                    // animation finish sooner, its sole impact would be to trigger the
                    // state event and the open callbacks sooner than the actual end of
                    // the opening animation, which is not great.
                    if (self.__state == 'disappearing') {

                        if (	newClosingTime > self.__closingTime
                            // in case closing is actually overdue because the script
                            // execution was suspended. See #679
                            &&	self.__options.animationDuration[1] > 0
                        ) {
                            necessary = false;
                        }
                    }

                    if (necessary) {

                        self.__closingTime = newClosingTime;

                        if (self.__state != 'disappearing') {
                            self.__stateSet('disappearing');
                        }

                        var finish = function() {

                            // stop the tracker
                            clearInterval(self.__tracker);

                            // a "beforeClose" option has been asked several times but would
                            // probably useless since the content element is still accessible
                            // via ::content(), and because people can always use listeners
                            // inside their content to track what's going on. For the sake of
                            // simplicity, this has been denied. Bur for the rare people who
                            // really need the option (for old browsers or for the case where
                            // detaching the content is actually destructive, for file or
                            // password inputs for example), this event will do the work.
                            self._trigger({
                                type: 'closing',
                                event: event
                            });

                            // unbind listeners which are no longer needed

                            self._$tooltip
                                .off('.'+ self.__namespace +'-triggerClose')
                                .removeClass('tooltipster-dying');

                            // orientationchange, scroll and resize listeners
                            $(env.window).off('.'+ self.__namespace +'-triggerClose');

                            // scroll listeners
                            self.__$originParents.each(function(i, el) {
                                $(el).off('scroll.'+ self.__namespace +'-triggerClose');
                            });
                            // clear the array to prevent memory leaks
                            self.__$originParents = null;

                            $(env.window.document.body).off('.'+ self.__namespace +'-triggerClose');

                            self._$origin.off('.'+ self.__namespace +'-triggerClose');

                            self._off('dismissable');

                            // a plugin that would like to remove the tooltip from the
                            // DOM when closed should bind on this
                            self.__stateSet('closed');

                            // trigger event
                            self._trigger({
                                type: 'after',
                                event: event
                            });

                            // call our constructor custom callback function
                            if (self.__options.functionAfter) {
                                self.__options.functionAfter.call(self, self, {
                                    event: event,
                                    origin: self._$origin[0]
                                });
                            }

                            // call our method custom callbacks functions
                            finishCallbacks();
                        };

                        if (env.hasTransitions) {

                            self._$tooltip.css({
                                '-moz-animation-duration': self.__options.animationDuration[1] + 'ms',
                                '-ms-animation-duration': self.__options.animationDuration[1] + 'ms',
                                '-o-animation-duration': self.__options.animationDuration[1] + 'ms',
                                '-webkit-animation-duration': self.__options.animationDuration[1] + 'ms',
                                'animation-duration': self.__options.animationDuration[1] + 'ms',
                                'transition-duration': self.__options.animationDuration[1] + 'ms'
                            });

                            self._$tooltip
                            // clear both potential open and close tasks
                                .clearQueue()
                                .removeClass('tooltipster-show')
                                // for transitions only
                                .addClass('tooltipster-dying');

                            if (self.__options.animationDuration[1] > 0) {
                                self._$tooltip.delay(self.__options.animationDuration[1]);
                            }

                            self._$tooltip.queue(finish);
                        }
                        else {

                            self._$tooltip
                                .stop()
                                .fadeOut(self.__options.animationDuration[1], finish);
                        }
                    }
                }
                // if the tooltip is already closed, we still need to trigger
                // the method custom callbacks
                else {
                    finishCallbacks();
                }
            }

            return self;
        },

        /**
         * For internal use by plugins, if needed
         *
         * @returns {self}
         * @protected
         */
        _off: function() {
            this.__$emitterPrivate.off.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments));
            return this;
        },

        /**
         * For internal use by plugins, if needed
         *
         * @returns {self}
         * @protected
         */
        _on: function() {
            this.__$emitterPrivate.on.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments));
            return this;
        },

        /**
         * For internal use by plugins, if needed
         *
         * @returns {self}
         * @protected
         */
        _one: function() {
            this.__$emitterPrivate.one.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments));
            return this;
        },

        /**
         * Opens the tooltip right away.
         *
         * @param event
         * @param callback Will be called when the opening animation is over
         * @returns {self}
         * @protected
         */
        _open: function(event, callback) {

            var self = this;

            // if the destruction process has not begun and if this was not
            // triggered by an unwanted emulated click event
            if (!self.__destroying) {

                // check that the origin is still in the DOM
                if (	bodyContains(self._$origin)
                    // if the tooltip is enabled
                    &&	self.__enabled
                ) {

                    var ok = true;

                    // if the tooltip is not open yet, we need to call functionBefore.
                    // otherwise we can jst go on
                    if (self.__state == 'closed') {

                        // trigger an event. The event.stop function allows the callback
                        // to prevent the opening of the tooltip
                        self._trigger({
                            type: 'before',
                            event: event,
                            stop: function() {
                                ok = false;
                            }
                        });

                        if (ok && self.__options.functionBefore) {

                            // call our custom function before continuing
                            ok = self.__options.functionBefore.call(self, self, {
                                event: event,
                                origin: self._$origin[0]
                            });
                        }
                    }

                    if (ok !== false) {

                        // if there is some content
                        if (self.__Content !== null) {

                            // save the method callback and cancel close method callbacks
                            if (callback) {
                                self.__callbacks.open.push(callback);
                            }
                            self.__callbacks.close = [];

                            // get rid of any appearance timeouts
                            self.__timeoutsClear();

                            var extraTime,
                                finish = function() {

                                    if (self.__state != 'stable') {
                                        self.__stateSet('stable');
                                    }

                                    // trigger any open method custom callbacks and reset them
                                    $.each(self.__callbacks.open, function(i,c) {
                                        c.call(self, self, {
                                            origin: self._$origin[0],
                                            tooltip: self._$tooltip[0]
                                        });
                                    });

                                    self.__callbacks.open = [];
                                };

                            // if the tooltip is already open
                            if (self.__state !== 'closed') {

                                // the timer (if any) will start (or restart) right now
                                extraTime = 0;

                                // if it was disappearing, cancel that
                                if (self.__state === 'disappearing') {

                                    self.__stateSet('appearing');

                                    if (env.hasTransitions) {

                                        self._$tooltip
                                            .clearQueue()
                                            .removeClass('tooltipster-dying')
                                            .addClass('tooltipster-show');

                                        if (self.__options.animationDuration[0] > 0) {
                                            self._$tooltip.delay(self.__options.animationDuration[0]);
                                        }

                                        self._$tooltip.queue(finish);
                                    }
                                    else {
                                        // in case the tooltip was currently fading out, bring it back
                                        // to life
                                        self._$tooltip
                                            .stop()
                                            .fadeIn(finish);
                                    }
                                }
                                // if the tooltip is already open, we still need to trigger the method
                                // custom callback
                                else if (self.__state == 'stable') {
                                    finish();
                                }
                            }
                            // if the tooltip isn't already open, open it
                            else {

                                // a plugin must bind on this and store the tooltip in this._$tooltip
                                self.__stateSet('appearing');

                                // the timer (if any) will start when the tooltip has fully appeared
                                // after its transition
                                extraTime = self.__options.animationDuration[0];

                                // insert the content inside the tooltip
                                self.__contentInsert();

                                // reposition the tooltip and attach to the DOM
                                self.reposition(event, true);

                                // animate in the tooltip. If the display plugin wants no css
                                // animations, it may override the animation option with a
                                // dummy value that will produce no effect
                                if (env.hasTransitions) {

                                    // note: there seems to be an issue with start animations which
                                    // are randomly not played on fast devices in both Chrome and FF,
                                    // couldn't find a way to solve it yet. It seems that applying
                                    // the classes before appending to the DOM helps a little, but
                                    // it messes up some CSS transitions. The issue almost never
                                    // happens when delay[0]==0 though
                                    self._$tooltip
                                        .addClass('tooltipster-'+ self.__options.animation)
                                        .addClass('tooltipster-initial')
                                        .css({
                                            '-moz-animation-duration': self.__options.animationDuration[0] + 'ms',
                                            '-ms-animation-duration': self.__options.animationDuration[0] + 'ms',
                                            '-o-animation-duration': self.__options.animationDuration[0] + 'ms',
                                            '-webkit-animation-duration': self.__options.animationDuration[0] + 'ms',
                                            'animation-duration': self.__options.animationDuration[0] + 'ms',
                                            'transition-duration': self.__options.animationDuration[0] + 'ms'
                                        });

                                    setTimeout(
                                        function() {

                                            // a quick hover may have already triggered a mouseleave
                                            if (self.__state != 'closed') {

                                                self._$tooltip
                                                    .addClass('tooltipster-show')
                                                    .removeClass('tooltipster-initial');

                                                if (self.__options.animationDuration[0] > 0) {
                                                    self._$tooltip.delay(self.__options.animationDuration[0]);
                                                }

                                                self._$tooltip.queue(finish);
                                            }
                                        },
                                        0
                                    );
                                }
                                else {

                                    // old browsers will have to live with this
                                    self._$tooltip
                                        .css('display', 'none')
                                        .fadeIn(self.__options.animationDuration[0], finish);
                                }

                                // checks if the origin is removed while the tooltip is open
                                self.__trackerStart();

                                // NOTE: the listeners below have a '-triggerClose' namespace
                                // because we'll remove them when the tooltip closes (unlike
                                // the '-triggerOpen' listeners). So some of them are actually
                                // not about close triggers, rather about positioning.

                                $(env.window)
                                // reposition on resize
                                    .on('resize.'+ self.__namespace +'-triggerClose', function(e) {

                                        var $ae = $(document.activeElement);

                                        // reposition only if the resize event was not triggered upon the opening
                                        // of a virtual keyboard due to an input field being focused within the tooltip
                                        // (otherwise the repositioning would lose the focus)
                                        if (	(!$ae.is('input') && !$ae.is('textarea'))
                                            ||	!$.contains(self._$tooltip[0], $ae[0])
                                        ) {
                                            self.reposition(e);
                                        }
                                    })
                                    // same as below for parents
                                    .on('scroll.'+ self.__namespace +'-triggerClose', function(e) {
                                        self.__scrollHandler(e);
                                    });

                                self.__$originParents = self._$origin.parents();

                                // scrolling may require the tooltip to be moved or even
                                // repositioned in some cases
                                self.__$originParents.each(function(i, parent) {

                                    $(parent).on('scroll.'+ self.__namespace +'-triggerClose', function(e) {
                                        self.__scrollHandler(e);
                                    });
                                });

                                if (	self.__options.triggerClose.mouseleave
                                    ||	(self.__options.triggerClose.touchleave && env.hasTouchCapability)
                                ) {

                                    // we use an event to allow users/plugins to control when the mouseleave/touchleave
                                    // close triggers will come to action. It allows to have more triggering elements
                                    // than just the origin and the tooltip for example, or to cancel/delay the closing,
                                    // or to make the tooltip interactive even if it wasn't when it was open, etc.
                                    self._on('dismissable', function(event) {

                                        if (event.dismissable) {

                                            if (event.delay) {

                                                timeout = setTimeout(function() {
                                                    // event.event may be undefined
                                                    self._close(event.event);
                                                }, event.delay);

                                                self.__timeouts.close.push(timeout);
                                            }
                                            else {
                                                self._close(event);
                                            }
                                        }
                                        else {
                                            clearTimeout(timeout);
                                        }
                                    });

                                    // now set the listeners that will trigger 'dismissable' events
                                    var $elements = self._$origin,
                                        eventNamesIn = '',
                                        eventNamesOut = '',
                                        timeout = null;

                                    // if we have to allow interaction, bind on the tooltip too
                                    if (self.__options.interactive) {
                                        $elements = $elements.add(self._$tooltip);
                                    }

                                    if (self.__options.triggerClose.mouseleave) {
                                        eventNamesIn += 'mouseenter.'+ self.__namespace +'-triggerClose ';
                                        eventNamesOut += 'mouseleave.'+ self.__namespace +'-triggerClose ';
                                    }
                                    if (self.__options.triggerClose.touchleave && env.hasTouchCapability) {
                                        eventNamesIn += 'touchstart.'+ self.__namespace +'-triggerClose';
                                        eventNamesOut += 'touchend.'+ self.__namespace +'-triggerClose touchcancel.'+ self.__namespace +'-triggerClose';
                                    }

                                    $elements
                                    // close after some time spent outside of the elements
                                        .on(eventNamesOut, function(event) {

                                            // it's ok if the touch gesture ended up to be a swipe,
                                            // it's still a "touch leave" situation
                                            if (	self._touchIsTouchEvent(event)
                                                ||	!self._touchIsEmulatedEvent(event)
                                            ) {

                                                var delay = (event.type == 'mouseleave') ?
                                                    self.__options.delay :
                                                    self.__options.delayTouch;

                                                self._trigger({
                                                    delay: delay[1],
                                                    dismissable: true,
                                                    event: event,
                                                    type: 'dismissable'
                                                });
                                            }
                                        })
                                        // suspend the mouseleave timeout when the pointer comes back
                                        // over the elements
                                        .on(eventNamesIn, function(event) {

                                            // it's also ok if the touch event is a swipe gesture
                                            if (	self._touchIsTouchEvent(event)
                                                ||	!self._touchIsEmulatedEvent(event)
                                            ) {
                                                self._trigger({
                                                    dismissable: false,
                                                    event: event,
                                                    type: 'dismissable'
                                                });
                                            }
                                        });
                                }

                                // close the tooltip when the origin gets a mouse click (common behavior of
                                // native tooltips)
                                if (self.__options.triggerClose.originClick) {

                                    self._$origin.on('click.'+ self.__namespace + '-triggerClose', function(event) {

                                        // we could actually let a tap trigger this but this feature just
                                        // does not make sense on touch devices
                                        if (	!self._touchIsTouchEvent(event)
                                            &&	!self._touchIsEmulatedEvent(event)
                                        ) {
                                            self._close(event);
                                        }
                                    });
                                }

                                // set the same bindings for click and touch on the body to close the tooltip
                                if (	self.__options.triggerClose.click
                                    ||	(self.__options.triggerClose.tap && env.hasTouchCapability)
                                ) {

                                    // don't set right away since the click/tap event which triggered this method
                                    // (if it was a click/tap) is going to bubble up to the body, we don't want it
                                    // to close the tooltip immediately after it opened
                                    setTimeout(function() {

                                        if (self.__state != 'closed') {

                                            var eventNames = '',
                                                $body = $(env.window.document.body);

                                            if (self.__options.triggerClose.click) {
                                                eventNames += 'click.'+ self.__namespace +'-triggerClose ';
                                            }
                                            if (self.__options.triggerClose.tap && env.hasTouchCapability) {
                                                eventNames += 'touchend.'+ self.__namespace +'-triggerClose';
                                            }

                                            $body.on(eventNames, function(event) {

                                                if (self._touchIsMeaningfulEvent(event)) {

                                                    self._touchRecordEvent(event);

                                                    if (!self.__options.interactive || !$.contains(self._$tooltip[0], event.target)) {
                                                        self._close(event);
                                                    }
                                                }
                                            });

                                            // needed to detect and ignore swiping
                                            if (self.__options.triggerClose.tap && env.hasTouchCapability) {

                                                $body.on('touchstart.'+ self.__namespace +'-triggerClose', function(event) {
                                                    self._touchRecordEvent(event);
                                                });
                                            }
                                        }
                                    }, 0);
                                }

                                self._trigger('ready');

                                // call our custom callback
                                if (self.__options.functionReady) {
                                    self.__options.functionReady.call(self, self, {
                                        origin: self._$origin[0],
                                        tooltip: self._$tooltip[0]
                                    });
                                }
                            }

                            // if we have a timer set, let the countdown begin
                            if (self.__options.timer > 0) {

                                var timeout = setTimeout(function() {
                                    self._close();
                                }, self.__options.timer + extraTime);

                                self.__timeouts.close.push(timeout);
                            }
                        }
                    }
                }
            }

            return self;
        },

        /**
         * When using the mouseenter/touchstart open triggers, this function will
         * schedule the opening of the tooltip after the delay, if there is one
         *
         * @param event
         * @returns {self}
         * @protected
         */
        _openShortly: function(event) {

            var self = this,
                ok = true;

            if (self.__state != 'stable' && self.__state != 'appearing') {

                // if a timeout is not already running
                if (!self.__timeouts.open) {

                    self._trigger({
                        type: 'start',
                        event: event,
                        stop: function() {
                            ok = false;
                        }
                    });

                    if (ok) {

                        var delay = (event.type.indexOf('touch') == 0) ?
                            self.__options.delayTouch :
                            self.__options.delay;

                        if (delay[0]) {

                            self.__timeouts.open = setTimeout(function() {

                                self.__timeouts.open = null;

                                // open only if the pointer (mouse or touch) is still over the origin.
                                // The check on the "meaningful event" can only be made here, after some
                                // time has passed (to know if the touch was a swipe or not)
                                if (self.__pointerIsOverOrigin && self._touchIsMeaningfulEvent(event)) {

                                    // signal that we go on
                                    self._trigger('startend');

                                    self._open(event);
                                }
                                else {
                                    // signal that we cancel
                                    self._trigger('startcancel');
                                }
                            }, delay[0]);
                        }
                        else {
                            // signal that we go on
                            self._trigger('startend');

                            self._open(event);
                        }
                    }
                }
            }

            return self;
        },

        /**
         * Meant for plugins to get their options
         *
         * @param {string} pluginName The name of the plugin that asks for its options
         * @param {object} defaultOptions The default options of the plugin
         * @returns {object} The options
         * @protected
         */
        _optionsExtract: function(pluginName, defaultOptions) {

            var self = this,
                options = $.extend(true, {}, defaultOptions);

            // if the plugin options were isolated in a property named after the
            // plugin, use them (prevents conflicts with other plugins)
            var pluginOptions = self.__options[pluginName];

            // if not, try to get them as regular options
            if (!pluginOptions){

                pluginOptions = {};

                $.each(defaultOptions, function(optionName, value) {

                    var o = self.__options[optionName];

                    if (o !== undefined) {
                        pluginOptions[optionName] = o;
                    }
                });
            }

            // let's merge the default options and the ones that were provided. We'd want
            // to do a deep copy but not let jQuery merge arrays, so we'll do a shallow
            // extend on two levels, that will be enough if options are not more than 1
            // level deep
            $.each(options, function(optionName, value) {

                if (pluginOptions[optionName] !== undefined) {

                    if ((		typeof value == 'object'
                            &&	!(value instanceof Array)
                            &&	value != null
                        )
                        &&
                        (		typeof pluginOptions[optionName] == 'object'
                            &&	!(pluginOptions[optionName] instanceof Array)
                            &&	pluginOptions[optionName] != null
                        )
                    ) {
                        $.extend(options[optionName], pluginOptions[optionName]);
                    }
                    else {
                        options[optionName] = pluginOptions[optionName];
                    }
                }
            });

            return options;
        },

        /**
         * Used at instantiation of the plugin, or afterwards by plugins that activate themselves
         * on existing instances
         *
         * @param {object} pluginName
         * @returns {self}
         * @protected
         */
        _plug: function(pluginName) {

            var plugin = $.tooltipster._plugin(pluginName);

            if (plugin) {

                // if there is a constructor for instances
                if (plugin.instance) {

                    // proxy non-private methods on the instance to allow new instance methods
                    $.tooltipster.__bridge(plugin.instance, this, plugin.name);
                }
            }
            else {
                throw new Error('The "'+ pluginName +'" plugin is not defined');
            }

            return this;
        },

        /**
         * This will return true if the event is a mouse event which was
         * emulated by the browser after a touch event. This allows us to
         * really dissociate mouse and touch triggers.
         *
         * There is a margin of error if a real mouse event is fired right
         * after (within the delay shown below) a touch event on the same
         * element, but hopefully it should not happen often.
         *
         * @returns {boolean}
         * @protected
         */
        _touchIsEmulatedEvent: function(event) {

            var isEmulated = false,
                now = new Date().getTime();

            for (var i = this.__touchEvents.length - 1; i >= 0; i--) {

                var e = this.__touchEvents[i];

                // delay, in milliseconds. It's supposed to be 300ms in
                // most browsers (350ms on iOS) to allow a double tap but
                // can be less (check out FastClick for more info)
                if (now - e.time < 500) {

                    if (e.target === event.target) {
                        isEmulated = true;
                    }
                }
                else {
                    break;
                }
            }

            return isEmulated;
        },

        /**
         * Returns false if the event was an emulated mouse event or
         * a touch event involved in a swipe gesture.
         *
         * @param {object} event
         * @returns {boolean}
         * @protected
         */
        _touchIsMeaningfulEvent: function(event) {
            return (
                (this._touchIsTouchEvent(event) && !this._touchSwiped(event.target))
                ||	(!this._touchIsTouchEvent(event) && !this._touchIsEmulatedEvent(event))
            );
        },

        /**
         * Checks if an event is a touch event
         *
         * @param {object} event
         * @returns {boolean}
         * @protected
         */
        _touchIsTouchEvent: function(event){
            return event.type.indexOf('touch') == 0;
        },

        /**
         * Store touch events for a while to detect swiping and emulated mouse events
         *
         * @param {object} event
         * @returns {self}
         * @protected
         */
        _touchRecordEvent: function(event) {

            if (this._touchIsTouchEvent(event)) {
                event.time = new Date().getTime();
                this.__touchEvents.push(event);
            }

            return this;
        },

        /**
         * Returns true if a swipe happened after the last touchstart event fired on
         * event.target.
         *
         * We need to differentiate a swipe from a tap before we let the event open
         * or close the tooltip. A swipe is when a touchmove (scroll) event happens
         * on the body between the touchstart and the touchend events of an element.
         *
         * @param {object} target The HTML element that may have triggered the swipe
         * @returns {boolean}
         * @protected
         */
        _touchSwiped: function(target) {

            var swiped = false;

            for (var i = this.__touchEvents.length - 1; i >= 0; i--) {

                var e = this.__touchEvents[i];

                if (e.type == 'touchmove') {
                    swiped = true;
                    break;
                }
                else if (
                    e.type == 'touchstart'
                    &&	target === e.target
                ) {
                    break;
                }
            }

            return swiped;
        },

        /**
         * Triggers an event on the instance emitters
         *
         * @returns {self}
         * @protected
         */
        _trigger: function() {

            var args = Array.prototype.slice.apply(arguments);

            if (typeof args[0] == 'string') {
                args[0] = { type: args[0] };
            }

            // add properties to the event
            args[0].instance = this;
            args[0].origin = this._$origin ? this._$origin[0] : null;
            args[0].tooltip = this._$tooltip ? this._$tooltip[0] : null;

            // note: the order of emitters matters
            this.__$emitterPrivate.trigger.apply(this.__$emitterPrivate, args);
            $.tooltipster._trigger.apply($.tooltipster, args);
            this.__$emitterPublic.trigger.apply(this.__$emitterPublic, args);

            return this;
        },

        /**
         * Deactivate a plugin on this instance
         *
         * @returns {self}
         * @protected
         */
        _unplug: function(pluginName) {

            var self = this;

            // if the plugin has been activated on this instance
            if (self[pluginName]) {

                var plugin = $.tooltipster._plugin(pluginName);

                // if there is a constructor for instances
                if (plugin.instance) {

                    // unbridge
                    $.each(plugin.instance, function(methodName, fn) {

                        // if the method exists (privates methods do not) and comes indeed from
                        // this plugin (may be missing or come from a conflicting plugin).
                        if (	self[methodName]
                            &&	self[methodName].bridged === self[pluginName]
                        ) {
                            delete self[methodName];
                        }
                    });
                }

                // destroy the plugin
                if (self[pluginName].__destroy) {
                    self[pluginName].__destroy();
                }

                // remove the reference to the plugin instance
                delete self[pluginName];
            }

            return self;
        },

        /**
         * @see self::_close
         * @returns {self}
         * @public
         */
        close: function(callback) {

            if (!this.__destroyed) {
                this._close(null, callback);
            }
            else {
                this.__destroyError();
            }

            return this;
        },

        /**
         * Sets or gets the content of the tooltip
         *
         * @returns {mixed|self}
         * @public
         */
        content: function(content) {

            var self = this;

            // getter method
            if (content === undefined) {
                return self.__Content;
            }
            // setter method
            else {

                if (!self.__destroyed) {

                    // change the content
                    self.__contentSet(content);

                    if (self.__Content !== null) {

                        // update the tooltip if it is open
                        if (self.__state !== 'closed') {

                            // reset the content in the tooltip
                            self.__contentInsert();

                            // reposition and resize the tooltip
                            self.reposition();

                            // if we want to play a little animation showing the content changed
                            if (self.__options.updateAnimation) {

                                if (env.hasTransitions) {

                                    // keep the reference in the local scope
                                    var animation = self.__options.updateAnimation;

                                    self._$tooltip.addClass('tooltipster-update-'+ animation);

                                    // remove the class after a while. The actual duration of the
                                    // update animation may be shorter, it's set in the CSS rules
                                    setTimeout(function() {

                                        if (self.__state != 'closed') {

                                            self._$tooltip.removeClass('tooltipster-update-'+ animation);
                                        }
                                    }, 1000);
                                }
                                else {
                                    self._$tooltip.fadeTo(200, 0.5, function() {
                                        if (self.__state != 'closed') {
                                            self._$tooltip.fadeTo(200, 1);
                                        }
                                    });
                                }
                            }
                        }
                    }
                    else {
                        self._close();
                    }
                }
                else {
                    self.__destroyError();
                }

                return self;
            }
        },

        /**
         * Destroys the tooltip
         *
         * @returns {self}
         * @public
         */
        destroy: function() {

            var self = this;

            if (!self.__destroyed) {

                if(self.__state != 'closed'){

                    // no closing delay
                    self.option('animationDuration', 0)
                    // force closing
                        ._close(null, null, true);
                }
                else {
                    // there might be an open timeout still running
                    self.__timeoutsClear();
                }

                // send event
                self._trigger('destroy');

                self.__destroyed = true;

                self._$origin
                    .removeData(self.__namespace)
                    // remove the open trigger listeners
                    .off('.'+ self.__namespace +'-triggerOpen');

                // remove the touch listener
                $(env.window.document.body).off('.' + self.__namespace +'-triggerOpen');

                var ns = self._$origin.data('tooltipster-ns');

                // if the origin has been removed from DOM, its data may
                // well have been destroyed in the process and there would
                // be nothing to clean up or restore
                if (ns) {

                    // if there are no more tooltips on this element
                    if (ns.length === 1) {

                        // optional restoration of a title attribute
                        var title = null;
                        if (self.__options.restoration == 'previous') {
                            title = self._$origin.data('tooltipster-initialTitle');
                        }
                        else if (self.__options.restoration == 'current') {

                            // old school technique to stringify when outerHTML is not supported
                            title = (typeof self.__Content == 'string') ?
                                self.__Content :
                                $('<div></div>').append(self.__Content).html();
                        }

                        if (title) {
                            self._$origin.attr('title', title);
                        }

                        // final cleaning

                        self._$origin.removeClass('tooltipstered');

                        self._$origin
                            .removeData('tooltipster-ns')
                            .removeData('tooltipster-initialTitle');
                    }
                    else {
                        // remove the instance namespace from the list of namespaces of
                        // tooltips present on the element
                        ns = $.grep(ns, function(el, i) {
                            return el !== self.__namespace;
                        });
                        self._$origin.data('tooltipster-ns', ns);
                    }
                }

                // last event
                self._trigger('destroyed');

                // unbind private and public event listeners
                self._off();
                self.off();

                // remove external references, just in case
                self.__Content = null;
                self.__$emitterPrivate = null;
                self.__$emitterPublic = null;
                self.__options.parent = null;
                self._$origin = null;
                self._$tooltip = null;

                // make sure the object is no longer referenced in there to prevent
                // memory leaks
                $.tooltipster.__instancesLatestArr = $.grep($.tooltipster.__instancesLatestArr, function(el, i) {
                    return self !== el;
                });

                clearInterval(self.__garbageCollector);
            }
            else {
                self.__destroyError();
            }

            // we return the scope rather than true so that the call to
            // .tooltipster('destroy') actually returns the matched elements
            // and applies to all of them
            return self;
        },

        /**
         * Disables the tooltip
         *
         * @returns {self}
         * @public
         */
        disable: function() {

            if (!this.__destroyed) {

                // close first, in case the tooltip would not disappear on
                // its own (no close trigger)
                this._close();
                this.__enabled = false;

                return this;
            }
            else {
                this.__destroyError();
            }

            return this;
        },

        /**
         * Returns the HTML element of the origin
         *
         * @returns {self}
         * @public
         */
        elementOrigin: function() {

            if (!this.__destroyed) {
                return this._$origin[0];
            }
            else {
                this.__destroyError();
            }
        },

        /**
         * Returns the HTML element of the tooltip
         *
         * @returns {self}
         * @public
         */
        elementTooltip: function() {
            return this._$tooltip ? this._$tooltip[0] : null;
        },

        /**
         * Enables the tooltip
         *
         * @returns {self}
         * @public
         */
        enable: function() {
            this.__enabled = true;
            return this;
        },

        /**
         * Alias, deprecated in 4.0.0
         *
         * @param {function} callback
         * @returns {self}
         * @public
         */
        hide: function(callback) {
            return this.close(callback);
        },

        /**
         * Returns the instance
         *
         * @returns {self}
         * @public
         */
        instance: function() {
            return this;
        },

        /**
         * For public use only, not to be used by plugins (use ::_off() instead)
         *
         * @returns {self}
         * @public
         */
        off: function() {

            if (!this.__destroyed) {
                this.__$emitterPublic.off.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
            }

            return this;
        },

        /**
         * For public use only, not to be used by plugins (use ::_on() instead)
         *
         * @returns {self}
         * @public
         */
        on: function() {

            if (!this.__destroyed) {
                this.__$emitterPublic.on.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
            }
            else {
                this.__destroyError();
            }

            return this;
        },

        /**
         * For public use only, not to be used by plugins
         *
         * @returns {self}
         * @public
         */
        one: function() {

            if (!this.__destroyed) {
                this.__$emitterPublic.one.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
            }
            else {
                this.__destroyError();
            }

            return this;
        },

        /**
         * @see self::_open
         * @returns {self}
         * @public
         */
        open: function(callback) {

            if (!this.__destroyed) {
                this._open(null, callback);
            }
            else {
                this.__destroyError();
            }

            return this;
        },

        /**
         * Get or set options. For internal use and advanced users only.
         *
         * @param {string} o Option name
         * @param {mixed} val optional A new value for the option
         * @return {mixed|self} If val is omitted, the value of the option
         * is returned, otherwise the instance itself is returned
         * @public
         */
        option: function(o, val) {

            // getter
            if (val === undefined) {
                return this.__options[o];
            }
            // setter
            else {

                if (!this.__destroyed) {

                    // change value
                    this.__options[o] = val;

                    // format
                    this.__optionsFormat();

                    // re-prepare the triggers if needed
                    if ($.inArray(o, ['trigger', 'triggerClose', 'triggerOpen']) >= 0) {
                        this.__prepareOrigin();
                    }

                    if (o === 'selfDestruction') {
                        this.__prepareGC();
                    }
                }
                else {
                    this.__destroyError();
                }

                return this;
            }
        },

        /**
         * This method is in charge of setting the position and size properties of the tooltip.
         * All the hard work is delegated to the display plugin.
         * Note: The tooltip may be detached from the DOM at the moment the method is called
         * but must be attached by the end of the method call.
         *
         * @param {object} event For internal use only. Defined if an event such as
         * window resizing triggered the repositioning
         * @param {boolean} tooltipIsDetached For internal use only. Set this to true if you
         * know that the tooltip not being in the DOM is not an issue (typically when the
         * tooltip element has just been created but has not been added to the DOM yet).
         * @returns {self}
         * @public
         */
        reposition: function(event, tooltipIsDetached) {

            var self = this;

            if (!self.__destroyed) {

                // if the tooltip is still open and the origin is still in the DOM
                if (self.__state != 'closed' && bodyContains(self._$origin)) {

                    // if the tooltip has not been removed from DOM manually (or if it
                    // has been detached on purpose)
                    if (tooltipIsDetached || bodyContains(self._$tooltip)) {

                        if (!tooltipIsDetached) {
                            // detach in case the tooltip overflows the window and adds
                            // scrollbars to it, so __geometry can be accurate
                            self._$tooltip.detach();
                        }

                        // refresh the geometry object before passing it as a helper
                        self.__Geometry = self.__geometry();

                        // let a plugin fo the rest
                        self._trigger({
                            type: 'reposition',
                            event: event,
                            helper: {
                                geo: self.__Geometry
                            }
                        });
                    }
                }
            }
            else {
                self.__destroyError();
            }

            return self;
        },

        /**
         * Alias, deprecated in 4.0.0
         *
         * @param callback
         * @returns {self}
         * @public
         */
        show: function(callback) {
            return this.open(callback);
        },

        /**
         * Returns some properties about the instance
         *
         * @returns {object}
         * @public
         */
        status: function() {

            return {
                destroyed: this.__destroyed,
                enabled: this.__enabled,
                open: this.__state !== 'closed',
                state: this.__state
            };
        },

        /**
         * For public use only, not to be used by plugins
         *
         * @returns {self}
         * @public
         */
        triggerHandler: function() {

            if (!this.__destroyed) {
                this.__$emitterPublic.triggerHandler.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
            }
            else {
                this.__destroyError();
            }

            return this;
        }
    };

    $.fn.tooltipster = function() {

        // for using in closures
        var args = Array.prototype.slice.apply(arguments),
            // common mistake: an HTML element can't be in several tooltips at the same time
            contentCloningWarning = 'You are using a single HTML element as content for several tooltips. You probably want to set the contentCloning option to TRUE.';

        // this happens with $(sel).tooltipster(...) when $(sel) does not match anything
        if (this.length === 0) {

            // still chainable
            return this;
        }
        // this happens when calling $(sel).tooltipster('methodName or options')
        // where $(sel) matches one or more elements
        else {

            // method calls
            if (typeof args[0] === 'string') {

                var v = '#*$~&';

                this.each(function() {

                    // retrieve the namepaces of the tooltip(s) that exist on that element.
                    // We will interact with the first tooltip only.
                    var ns = $(this).data('tooltipster-ns'),
                        // self represents the instance of the first tooltipster plugin
                        // associated to the current HTML object of the loop
                        self = ns ? $(this).data(ns[0]) : null;

                    // if the current element holds a tooltipster instance
                    if (self) {

                        if (typeof self[args[0]] === 'function') {

                            if (	this.length > 1
                                &&	args[0] == 'content'
                                &&	(	args[1] instanceof $
                                    || (typeof args[1] == 'object' && args[1] != null && args[1].tagName)
                                )
                                &&	!self.__options.contentCloning
                                &&	self.__options.debug
                            ) {
                                console.log(contentCloningWarning);
                            }

                            // note : args[1] and args[2] may not be defined
                            var resp = self[args[0]](args[1], args[2]);
                        }
                        else {
                            throw new Error('Unknown method "'+ args[0] +'"');
                        }

                        // if the function returned anything other than the instance
                        // itself (which implies chaining, except for the `instance` method)
                        if (resp !== self || args[0] === 'instance') {

                            v = resp;

                            // return false to stop .each iteration on the first element
                            // matched by the selector
                            return false;
                        }
                    }
                    else {
                        throw new Error('You called Tooltipster\'s "'+ args[0] +'" method on an uninitialized element');
                    }
                });

                return (v !== '#*$~&') ? v : this;
            }
            // first argument is undefined or an object: the tooltip is initializing
            else {

                // reset the array of last initialized objects
                $.tooltipster.__instancesLatestArr = [];

                // is there a defined value for the multiple option in the options object ?
                var	multipleIsSet = args[0] && args[0].multiple !== undefined,
                    // if the multiple option is set to true, or if it's not defined but
                    // set to true in the defaults
                    multiple = (multipleIsSet && args[0].multiple) || (!multipleIsSet && defaults.multiple),
                    // same for content
                    contentIsSet = args[0] && args[0].content !== undefined,
                    content = (contentIsSet && args[0].content) || (!contentIsSet && defaults.content),
                    // same for contentCloning
                    contentCloningIsSet = args[0] && args[0].contentCloning !== undefined,
                    contentCloning =
                        (contentCloningIsSet && args[0].contentCloning)
                        ||	(!contentCloningIsSet && defaults.contentCloning),
                    // same for debug
                    debugIsSet = args[0] && args[0].debug !== undefined,
                    debug = (debugIsSet && args[0].debug) || (!debugIsSet && defaults.debug);

                if (	this.length > 1
                    &&	(	content instanceof $
                        || (typeof content == 'object' && content != null && content.tagName)
                    )
                    &&	!contentCloning
                    &&	debug
                ) {
                    console.log(contentCloningWarning);
                }

                // create a tooltipster instance for each element if it doesn't
                // already have one or if the multiple option is set, and attach the
                // object to it
                this.each(function() {

                    var go = false,
                        $this = $(this),
                        ns = $this.data('tooltipster-ns'),
                        obj = null;

                    if (!ns) {
                        go = true;
                    }
                    else if (multiple) {
                        go = true;
                    }
                    else if (debug) {
                        console.log('Tooltipster: one or more tooltips are already attached to the element below. Ignoring.');
                        console.log(this);
                    }

                    if (go) {
                        obj = new $.Tooltipster(this, args[0]);

                        // save the reference of the new instance
                        if (!ns) ns = [];
                        ns.push(obj.__namespace);
                        $this.data('tooltipster-ns', ns);

                        // save the instance itself
                        $this.data(obj.__namespace, obj);

                        // call our constructor custom function.
                        // we do this here and not in ::init() because we wanted
                        // the object to be saved in $this.data before triggering
                        // it
                        if (obj.__options.functionInit) {
                            obj.__options.functionInit.call(obj, obj, {
                                origin: this
                            });
                        }

                        // and now the event, for the plugins and core emitter
                        obj._trigger('init');
                    }

                    $.tooltipster.__instancesLatestArr.push(obj);
                });

                return this;
            }
        }
    };

// Utilities

    /**
     * A class to check if a tooltip can fit in given dimensions
     *
     * @param {object} $tooltip The jQuery wrapped tooltip element, or a clone of it
     */
    function Ruler($tooltip) {

        // list of instance variables

        this.$container;
        this.constraints = null;
        this.__$tooltip;

        this.__init($tooltip);
    }

    Ruler.prototype = {

        /**
         * Move the tooltip into an invisible div that does not allow overflow to make
         * size tests. Note: the tooltip may or may not be attached to the DOM at the
         * moment this method is called, it does not matter.
         *
         * @param {object} $tooltip The object to test. May be just a clone of the
         * actual tooltip.
         * @private
         */
        __init: function($tooltip) {

            this.__$tooltip = $tooltip;

            this.__$tooltip
                .css({
                    // for some reason we have to specify top and left 0
                    left: 0,
                    // any overflow will be ignored while measuring
                    overflow: 'hidden',
                    // positions at (0,0) without the div using 100% of the available width
                    position: 'absolute',
                    top: 0
                })
                // overflow must be auto during the test. We re-set this in case
                // it were modified by the user
                .find('.tooltipster-content')
                .css('overflow', 'auto');

            this.$container = $('<div class="tooltipster-ruler"></div>')
                .append(this.__$tooltip)
                .appendTo(env.window.document.body);
        },

        /**
         * Force the browser to redraw (re-render) the tooltip immediately. This is required
         * when you changed some CSS properties and need to make something with it
         * immediately, without waiting for the browser to redraw at the end of instructions.
         *
         * @see http://stackoverflow.com/questions/3485365/how-can-i-force-webkit-to-redraw-repaint-to-propagate-style-changes
         * @private
         */
        __forceRedraw: function() {

            // note: this would work but for Webkit only
            //this.__$tooltip.close();
            //this.__$tooltip[0].offsetHeight;
            //this.__$tooltip.open();

            // works in FF too
            var $p = this.__$tooltip.parent();
            this.__$tooltip.detach();
            this.__$tooltip.appendTo($p);
        },

        /**
         * Set maximum dimensions for the tooltip. A call to ::measure afterwards
         * will tell us if the content overflows or if it's ok
         *
         * @param {int} width
         * @param {int} height
         * @return {Ruler}
         * @public
         */
        constrain: function(width, height) {

            this.constraints = {
                width: width,
                height: height
            };

            this.__$tooltip.css({
                // we disable display:flex, otherwise the content would overflow without
                // creating horizontal scrolling (which we need to detect).
                display: 'block',
                // reset any previous height
                height: '',
                // we'll check if horizontal scrolling occurs
                overflow: 'auto',
                // we'll set the width and see what height is generated and if there
                // is horizontal overflow
                width: width
            });

            return this;
        },

        /**
         * Reset the tooltip content overflow and remove the test container
         *
         * @returns {Ruler}
         * @public
         */
        destroy: function() {

            // in case the element was not a clone
            this.__$tooltip
                .detach()
                .find('.tooltipster-content')
                .css({
                    // reset to CSS value
                    display: '',
                    overflow: ''
                });

            this.$container.remove();
        },

        /**
         * Removes any constraints
         *
         * @returns {Ruler}
         * @public
         */
        free: function() {

            this.constraints = null;

            // reset to natural size
            this.__$tooltip.css({
                display: '',
                height: '',
                overflow: 'visible',
                width: ''
            });

            return this;
        },

        /**
         * Returns the size of the tooltip. When constraints are applied, also returns
         * whether the tooltip fits in the provided dimensions.
         * The idea is to see if the new height is small enough and if the content does
         * not overflow horizontally.
         *
         * @param {int} width
         * @param {int} height
         * @returns {object} An object with a bool `fits` property and a `size` property
         * @public
         */
        measure: function() {

            this.__forceRedraw();

            var tooltipBcr = this.__$tooltip[0].getBoundingClientRect(),
                result = { size: {
                    // bcr.width/height are not defined in IE8- but in this
                    // case, bcr.right/bottom will have the same value
                    // except in iOS 8+ where tooltipBcr.bottom/right are wrong
                    // after scrolling for reasons yet to be determined.
                    // tooltipBcr.top/left might not be 0, see issue #514
                    height: tooltipBcr.height || (tooltipBcr.bottom - tooltipBcr.top),
                    width: tooltipBcr.width || (tooltipBcr.right - tooltipBcr.left)
                }};

            if (this.constraints) {

                // note: we used to use offsetWidth instead of boundingRectClient but
                // it returned rounded values, causing issues with sub-pixel layouts.

                // note2: noticed that the bcrWidth of text content of a div was once
                // greater than the bcrWidth of its container by 1px, causing the final
                // tooltip box to be too small for its content. However, evaluating
                // their widths one against the other (below) surprisingly returned
                // equality. Happened only once in Chrome 48, was not able to reproduce
                // => just having fun with float position values...

                var $content = this.__$tooltip.find('.tooltipster-content'),
                    height = this.__$tooltip.outerHeight(),
                    contentBcr = $content[0].getBoundingClientRect(),
                    fits = {
                        height: height <= this.constraints.height,
                        width: (
                            // this condition accounts for min-width property that
                            // may apply
                            tooltipBcr.width <= this.constraints.width
                            // the -1 is here because scrollWidth actually returns
                            // a rounded value, and may be greater than bcr.width if
                            // it was rounded up. This may cause an issue for contents
                            // which actually really overflow  by 1px or so, but that
                            // should be rare. Not sure how to solve this efficiently.
                            // See http://blogs.msdn.com/b/ie/archive/2012/02/17/sub-pixel-rendering-and-the-css-object-model.aspx
                            &&	contentBcr.width >= $content[0].scrollWidth - 1
                        )
                    };

                result.fits = fits.height && fits.width;
            }

            // old versions of IE get the width wrong for some reason and it causes
            // the text to be broken to a new line, so we round it up. If the width
            // is the width of the screen though, we can assume it is accurate.
            if (	env.IE
                &&	env.IE <= 11
                &&	result.size.width !== env.window.document.documentElement.clientWidth
            ) {
                result.size.width = Math.ceil(result.size.width) + 1;
            }

            return result;
        }
    };

// quick & dirty compare function, not bijective nor multidimensional
    function areEqual(a,b) {
        var same = true;
        $.each(a, function(i, _) {
            if (b[i] === undefined || a[i] !== b[i]) {
                same = false;
                return false;
            }
        });
        return same;
    }

    /**
     * A fast function to check if an element is still in the DOM. It
     * tries to use an id as ids are indexed by the browser, or falls
     * back to jQuery's `contains` method. May fail if two elements
     * have the same id, but so be it
     *
     * @param {object} $obj A jQuery-wrapped HTML element
     * @return {boolean}
     */
    function bodyContains($obj) {
        var id = $obj.attr('id'),
            el = id ? env.window.document.getElementById(id) : null;
        // must also check that the element with the id is the one we want
        return el ? el === $obj[0] : $.contains(env.window.document.body, $obj[0]);
    }

// detect IE versions for dirty fixes
    var uA = navigator.userAgent.toLowerCase();
    if (uA.indexOf('msie') != -1) env.IE = parseInt(uA.split('msie')[1]);
    else if (uA.toLowerCase().indexOf('trident') !== -1 && uA.indexOf(' rv:11') !== -1) env.IE = 11;
    else if (uA.toLowerCase().indexOf('edge/') != -1) env.IE = parseInt(uA.toLowerCase().split('edge/')[1]);

// detecting support for CSS transitions
    function transitionSupport() {

        // env.window is not defined yet when this is called
        if (!win) return false;

        var b = win.document.body || win.document.documentElement,
            s = b.style,
            p = 'transition',
            v = ['Moz', 'Webkit', 'Khtml', 'O', 'ms'];

        if (typeof s[p] == 'string') { return true; }

        p = p.charAt(0).toUpperCase() + p.substr(1);
        for (var i=0; i<v.length; i++) {
            if (typeof s[v[i] + p] == 'string') { return true; }
        }
        return false;
    }

// we'll return jQuery for plugins not to have to declare it as a dependency,
// but it's done by a build task since it should be included only once at the
// end when we concatenate the main file with a plugin
// sideTip is Tooltipster's default plugin.
// This file will be UMDified by a build task.

    var pluginName = 'tooltipster.sideTip';

    $.tooltipster._plugin({
        name: pluginName,
        instance: {
            /**
             * Defaults are provided as a function for an easy override by inheritance
             *
             * @return {object} An object with the defaults options
             * @private
             */
            __defaults: function() {

                return {
                    // if the tooltip should display an arrow that points to the origin
                    arrow: true,
                    // the distance in pixels between the tooltip and the origin
                    distance: 6,
                    // allows to easily change the position of the tooltip
                    functionPosition: null,
                    maxWidth: null,
                    // used to accomodate the arrow of tooltip if there is one.
                    // First to make sure that the arrow target is not too close
                    // to the edge of the tooltip, so the arrow does not overflow
                    // the tooltip. Secondly when we reposition the tooltip to
                    // make sure that it's positioned in such a way that the arrow is
                    // still pointing at the target (and not a few pixels beyond it).
                    // It should be equal to or greater than half the width of
                    // the arrow (by width we mean the size of the side which touches
                    // the side of the tooltip).
                    minIntersection: 16,
                    minWidth: 0,
                    // deprecated in 4.0.0. Listed for _optionsExtract to pick it up
                    position: null,
                    side: 'top',
                    // set to false to position the tooltip relatively to the document rather
                    // than the window when we open it
                    viewportAware: true
                };
            },

            /**
             * Run once: at instantiation of the plugin
             *
             * @param {object} instance The tooltipster object that instantiated this plugin
             * @private
             */
            __init: function(instance) {

                var self = this;

                // list of instance variables

                self.__instance = instance;
                self.__namespace = 'tooltipster-sideTip-'+ Math.round(Math.random()*1000000);
                self.__previousState = 'closed';
                self.__options;

                // initial formatting
                self.__optionsFormat();

                self.__instance._on('state.'+ self.__namespace, function(event) {

                    if (event.state == 'closed') {
                        self.__close();
                    }
                    else if (event.state == 'appearing' && self.__previousState == 'closed') {
                        self.__create();
                    }

                    self.__previousState = event.state;
                });

                // reformat every time the options are changed
                self.__instance._on('options.'+ self.__namespace, function() {
                    self.__optionsFormat();
                });

                self.__instance._on('reposition.'+ self.__namespace, function(e) {
                    self.__reposition(e.event, e.helper);
                });
            },

            /**
             * Called when the tooltip has closed
             *
             * @private
             */
            __close: function() {

                // detach our content object first, so the next jQuery's remove()
                // call does not unbind its event handlers
                if (this.__instance.content() instanceof $) {
                    this.__instance.content().detach();
                }

                // remove the tooltip from the DOM
                this.__instance._$tooltip.remove();
                this.__instance._$tooltip = null;
            },

            /**
             * Creates the HTML element of the tooltip.
             *
             * @private
             */
            __create: function() {

                // note: we wrap with a .tooltipster-box div to be able to set a margin on it
                // (.tooltipster-base must not have one)
                var $html = $(
                    '<div class="tooltipster-base tooltipster-sidetip">' +
                    '<div class="tooltipster-box">' +
                    '<div class="tooltipster-content"></div>' +
                    '</div>' +
                    '<div class="tooltipster-arrow">' +
                    '<div class="tooltipster-arrow-uncropped">' +
                    '<div class="tooltipster-arrow-border"></div>' +
                    '<div class="tooltipster-arrow-background"></div>' +
                    '</div>' +
                    '</div>' +
                    '</div>'
                );

                // hide arrow if asked
                if (!this.__options.arrow) {
                    $html
                        .find('.tooltipster-box')
                        .css('margin', 0)
                        .end()
                        .find('.tooltipster-arrow')
                        .hide();
                }

                // apply min/max width if asked
                if (this.__options.minWidth) {
                    $html.css('min-width', this.__options.minWidth + 'px');
                }
                if (this.__options.maxWidth) {
                    $html.css('max-width', this.__options.maxWidth + 'px');
                }

                this.__instance._$tooltip = $html;

                // tell the instance that the tooltip element has been created
                this.__instance._trigger('created');
            },

            /**
             * Used when the plugin is to be unplugged
             *
             * @private
             */
            __destroy: function() {
                this.__instance._off('.'+ self.__namespace);
            },

            /**
             * (Re)compute this.__options from the options declared to the instance
             *
             * @private
             */
            __optionsFormat: function() {

                var self = this;

                // get the options
                self.__options = self.__instance._optionsExtract(pluginName, self.__defaults());

                // for backward compatibility, deprecated in v4.0.0
                if (self.__options.position) {
                    self.__options.side = self.__options.position;
                }

                // options formatting

                // format distance as a four-cell array if it ain't one yet and then make
                // it an object with top/bottom/left/right properties
                if (typeof self.__options.distance != 'object') {
                    self.__options.distance = [self.__options.distance];
                }
                if (self.__options.distance.length < 4) {

                    if (self.__options.distance[1] === undefined) self.__options.distance[1] = self.__options.distance[0];
                    if (self.__options.distance[2] === undefined) self.__options.distance[2] = self.__options.distance[0];
                    if (self.__options.distance[3] === undefined) self.__options.distance[3] = self.__options.distance[1];

                    self.__options.distance = {
                        top: self.__options.distance[0],
                        right: self.__options.distance[1],
                        bottom: self.__options.distance[2],
                        left: self.__options.distance[3]
                    };
                }

                // let's transform:
                // 'top' into ['top', 'bottom', 'right', 'left']
                // 'right' into ['right', 'left', 'top', 'bottom']
                // 'bottom' into ['bottom', 'top', 'right', 'left']
                // 'left' into ['left', 'right', 'top', 'bottom']
                if (typeof self.__options.side == 'string') {

                    var opposites = {
                        'top': 'bottom',
                        'right': 'left',
                        'bottom': 'top',
                        'left': 'right'
                    };

                    self.__options.side = [self.__options.side, opposites[self.__options.side]];

                    if (self.__options.side[0] == 'left' || self.__options.side[0] == 'right') {
                        self.__options.side.push('top', 'bottom');
                    }
                    else {
                        self.__options.side.push('right', 'left');
                    }
                }

                // misc
                // disable the arrow in IE6 unless the arrow option was explicitly set to true
                if (	$.tooltipster._env.IE === 6
                    &&	self.__options.arrow !== true
                ) {
                    self.__options.arrow = false;
                }
            },

            /**
             * This method must compute and set the positioning properties of the
             * tooltip (left, top, width, height, etc.). It must also make sure the
             * tooltip is eventually appended to its parent (since the element may be
             * detached from the DOM at the moment the method is called).
             *
             * We'll evaluate positioning scenarios to find which side can contain the
             * tooltip in the best way. We'll consider things relatively to the window
             * (unless the user asks not to), then to the document (if need be, or if the
             * user explicitly requires the tests to run on the document). For each
             * scenario, measures are taken, allowing us to know how well the tooltip
             * is going to fit. After that, a sorting function will let us know what
             * the best scenario is (we also allow the user to choose his favorite
             * scenario by using an event).
             *
             * @param {object} helper An object that contains variables that plugin
             * creators may find useful (see below)
             * @param {object} helper.geo An object with many layout properties
             * about objects of interest (window, document, origin). This should help
             * plugin users compute the optimal position of the tooltip
             * @private
             */
            __reposition: function(event, helper) {

                var self = this,
                    finalResult,
                    // to know where to put the tooltip, we need to know on which point
                    // of the x or y axis we should center it. That coordinate is the target
                    targets = self.__targetFind(helper),
                    testResults = [];

                // make sure the tooltip is detached while we make tests on a clone
                self.__instance._$tooltip.detach();

                // we could actually provide the original element to the Ruler and
                // not a clone, but it just feels right to keep it out of the
                // machinery.
                var $clone = self.__instance._$tooltip.clone(),
                    // start position tests session
                    ruler = $.tooltipster._getRuler($clone),
                    satisfied = false,
                    animation = self.__instance.option('animation');

                // an animation class could contain properties that distort the size
                if (animation) {
                    $clone.removeClass('tooltipster-'+ animation);
                }

                // start evaluating scenarios
                $.each(['window', 'document'], function(i, container) {

                    var takeTest = null;

                    // let the user decide to keep on testing or not
                    self.__instance._trigger({
                        container: container,
                        helper: helper,
                        satisfied: satisfied,
                        takeTest: function(bool) {
                            takeTest = bool;
                        },
                        results: testResults,
                        type: 'positionTest'
                    });

                    if (	takeTest == true
                        ||	(	takeTest != false
                            &&	satisfied == false
                            // skip the window scenarios if asked. If they are reintegrated by
                            // the callback of the positionTest event, they will have to be
                            // excluded using the callback of positionTested
                            &&	(container != 'window' || self.__options.viewportAware)
                        )
                    ) {

                        // for each allowed side
                        for (var i=0; i < self.__options.side.length; i++) {

                            var distance = {
                                    horizontal: 0,
                                    vertical: 0
                                },
                                side = self.__options.side[i];

                            if (side == 'top' || side == 'bottom') {
                                distance.vertical = self.__options.distance[side];
                            }
                            else {
                                distance.horizontal = self.__options.distance[side];
                            }

                            // this may have an effect on the size of the tooltip if there are css
                            // rules for the arrow or something else
                            self.__sideChange($clone, side);

                            $.each(['natural', 'constrained'], function(i, mode) {

                                takeTest = null;

                                // emit an event on the instance
                                self.__instance._trigger({
                                    container: container,
                                    event: event,
                                    helper: helper,
                                    mode: mode,
                                    results: testResults,
                                    satisfied: satisfied,
                                    side: side,
                                    takeTest: function(bool) {
                                        takeTest = bool;
                                    },
                                    type: 'positionTest'
                                });

                                if (	takeTest == true
                                    ||	(	takeTest != false
                                        &&	satisfied == false
                                    )
                                ) {

                                    var testResult = {
                                        container: container,
                                        // we let the distance as an object here, it can make things a little easier
                                        // during the user's calculations at positionTest/positionTested
                                        distance: distance,
                                        // whether the tooltip can fit in the size of the viewport (does not mean
                                        // that we'll be able to make it initially entirely visible, see 'whole')
                                        fits: null,
                                        mode: mode,
                                        outerSize: null,
                                        side: side,
                                        size: null,
                                        target: targets[side],
                                        // check if the origin has enough surface on screen for the tooltip to
                                        // aim at it without overflowing the viewport (this is due to the thickness
                                        // of the arrow represented by the minIntersection length).
                                        // If not, the tooltip will have to be partly or entirely off screen in
                                        // order to stay docked to the origin. This value will stay null when the
                                        // container is the document, as it is not relevant
                                        whole: null
                                    };

                                    // get the size of the tooltip with or without size constraints
                                    var rulerConfigured = (mode == 'natural') ?
                                            ruler.free() :
                                            ruler.constrain(
                                                helper.geo.available[container][side].width - distance.horizontal,
                                                helper.geo.available[container][side].height - distance.vertical
                                            ),
                                        rulerResults = rulerConfigured.measure();

                                    testResult.size = rulerResults.size;
                                    testResult.outerSize = {
                                        height: rulerResults.size.height + distance.vertical,
                                        width: rulerResults.size.width + distance.horizontal
                                    };

                                    if (mode == 'natural') {

                                        if(		helper.geo.available[container][side].width >= testResult.outerSize.width
                                            &&	helper.geo.available[container][side].height >= testResult.outerSize.height
                                        ) {
                                            testResult.fits = true;
                                        }
                                        else {
                                            testResult.fits = false;
                                        }
                                    }
                                    else {
                                        testResult.fits = rulerResults.fits;
                                    }

                                    if (container == 'window') {

                                        if (!testResult.fits) {
                                            testResult.whole = false;
                                        }
                                        else {
                                            if (side == 'top' || side == 'bottom') {

                                                testResult.whole = (
                                                    helper.geo.origin.windowOffset.right >= self.__options.minIntersection
                                                    &&	helper.geo.window.size.width - helper.geo.origin.windowOffset.left >= self.__options.minIntersection
                                                );
                                            }
                                            else {
                                                testResult.whole = (
                                                    helper.geo.origin.windowOffset.bottom >= self.__options.minIntersection
                                                    &&	helper.geo.window.size.height - helper.geo.origin.windowOffset.top >= self.__options.minIntersection
                                                );
                                            }
                                        }
                                    }

                                    testResults.push(testResult);

                                    // we don't need to compute more positions if we have one fully on screen
                                    if (testResult.whole) {
                                        satisfied = true;
                                    }
                                    else {
                                        // don't run the constrained test unless the natural width was greater
                                        // than the available width, otherwise it's pointless as we know it
                                        // wouldn't fit either
                                        if (	testResult.mode == 'natural'
                                            &&	(	testResult.fits
                                                ||	testResult.size.width <= helper.geo.available[container][side].width
                                            )
                                        ) {
                                            return false;
                                        }
                                    }
                                }
                            });
                        }
                    }
                });

                // the user may eliminate the unwanted scenarios from testResults, but he's
                // not supposed to alter them at this point. functionPosition and the
                // position event serve that purpose.
                self.__instance._trigger({
                    edit: function(r) {
                        testResults = r;
                    },
                    event: event,
                    helper: helper,
                    results: testResults,
                    type: 'positionTested'
                });

                /**
                 * Sort the scenarios to find the favorite one.
                 *
                 * The favorite scenario is when we can fully display the tooltip on screen,
                 * even if it means that the middle of the tooltip is no longer centered on
                 * the middle of the origin (when the origin is near the edge of the screen
                 * or even partly off screen). We want the tooltip on the preferred side,
                 * even if it means that we have to use a constrained size rather than a
                 * natural one (as long as it fits). When the origin is off screen at the top
                 * the tooltip will be positioned at the bottom (if allowed), if the origin
                 * is off screen on the right, it will be positioned on the left, etc.
                 * If there are no scenarios where the tooltip can fit on screen, or if the
                 * user does not want the tooltip to fit on screen (viewportAware == false),
                 * we fall back to the scenarios relative to the document.
                 *
                 * When the tooltip is bigger than the viewport in either dimension, we stop
                 * looking at the window scenarios and consider the document scenarios only,
                 * with the same logic to find on which side it would fit best.
                 *
                 * If the tooltip cannot fit the document on any side, we force it at the
                 * bottom, so at least the user can scroll to see it.
                 */
                testResults.sort(function(a, b) {

                    // best if it's whole (the tooltip fits and adapts to the viewport)
                    if (a.whole && !b.whole) {
                        return -1;
                    }
                    else if (!a.whole && b.whole) {
                        return 1;
                    }
                    else if (a.whole && b.whole) {

                        var ai = self.__options.side.indexOf(a.side),
                            bi = self.__options.side.indexOf(b.side);

                        // use the user's sides fallback array
                        if (ai < bi) {
                            return -1;
                        }
                        else if (ai > bi) {
                            return 1;
                        }
                        else {
                            // will be used if the user forced the tests to continue
                            return a.mode == 'natural' ? -1 : 1;
                        }
                    }
                    else {

                        // better if it fits
                        if (a.fits && !b.fits) {
                            return -1;
                        }
                        else if (!a.fits && b.fits) {
                            return 1;
                        }
                        else if (a.fits && b.fits) {

                            var ai = self.__options.side.indexOf(a.side),
                                bi = self.__options.side.indexOf(b.side);

                            // use the user's sides fallback array
                            if (ai < bi) {
                                return -1;
                            }
                            else if (ai > bi) {
                                return 1;
                            }
                            else {
                                // will be used if the user forced the tests to continue
                                return a.mode == 'natural' ? -1 : 1;
                            }
                        }
                        else {

                            // if everything failed, this will give a preference to the case where
                            // the tooltip overflows the document at the bottom
                            if (	a.container == 'document'
                                &&	a.side == 'bottom'
                                &&	a.mode == 'natural'
                            ) {
                                return -1;
                            }
                            else {
                                return 1;
                            }
                        }
                    }
                });

                finalResult = testResults[0];


                // now let's find the coordinates of the tooltip relatively to the window
                finalResult.coord = {};

                switch (finalResult.side) {

                    case 'left':
                    case 'right':
                        finalResult.coord.top = Math.floor(finalResult.target - finalResult.size.height / 2);
                        break;

                    case 'bottom':
                    case 'top':
                        finalResult.coord.left = Math.floor(finalResult.target - finalResult.size.width / 2);
                        break;
                }

                switch (finalResult.side) {

                    case 'left':
                        finalResult.coord.left = helper.geo.origin.windowOffset.left - finalResult.outerSize.width;
                        break;

                    case 'right':
                        finalResult.coord.left = helper.geo.origin.windowOffset.right + finalResult.distance.horizontal;
                        break;

                    case 'top':
                        finalResult.coord.top = helper.geo.origin.windowOffset.top - finalResult.outerSize.height;
                        break;

                    case 'bottom':
                        finalResult.coord.top = helper.geo.origin.windowOffset.bottom + finalResult.distance.vertical;
                        break;
                }

                // if the tooltip can potentially be contained within the viewport dimensions
                // and that we are asked to make it fit on screen
                if (finalResult.container == 'window') {

                    // if the tooltip overflows the viewport, we'll move it accordingly (then it will
                    // not be centered on the middle of the origin anymore). We only move horizontally
                    // for top and bottom tooltips and vice versa.
                    if (finalResult.side == 'top' || finalResult.side == 'bottom') {

                        // if there is an overflow on the left
                        if (finalResult.coord.left < 0) {

                            // prevent the overflow unless the origin itself gets off screen (minus the
                            // margin needed to keep the arrow pointing at the target)
                            if (helper.geo.origin.windowOffset.right - this.__options.minIntersection >= 0) {
                                finalResult.coord.left = 0;
                            }
                            else {
                                finalResult.coord.left = helper.geo.origin.windowOffset.right - this.__options.minIntersection - 1;
                            }
                        }
                        // or an overflow on the right
                        else if (finalResult.coord.left > helper.geo.window.size.width - finalResult.size.width) {

                            if (helper.geo.origin.windowOffset.left + this.__options.minIntersection <= helper.geo.window.size.width) {
                                finalResult.coord.left = helper.geo.window.size.width - finalResult.size.width;
                            }
                            else {
                                finalResult.coord.left = helper.geo.origin.windowOffset.left + this.__options.minIntersection + 1 - finalResult.size.width;
                            }
                        }
                    }
                    else {

                        // overflow at the top
                        if (finalResult.coord.top < 0) {

                            if (helper.geo.origin.windowOffset.bottom - this.__options.minIntersection >= 0) {
                                finalResult.coord.top = 0;
                            }
                            else {
                                finalResult.coord.top = helper.geo.origin.windowOffset.bottom - this.__options.minIntersection - 1;
                            }
                        }
                        // or at the bottom
                        else if (finalResult.coord.top > helper.geo.window.size.height - finalResult.size.height) {

                            if (helper.geo.origin.windowOffset.top + this.__options.minIntersection <= helper.geo.window.size.height) {
                                finalResult.coord.top = helper.geo.window.size.height - finalResult.size.height;
                            }
                            else {
                                finalResult.coord.top = helper.geo.origin.windowOffset.top + this.__options.minIntersection + 1 - finalResult.size.height;
                            }
                        }
                    }
                }
                else {

                    // there might be overflow here too but it's easier to handle. If there has
                    // to be an overflow, we'll make sure it's on the right side of the screen
                    // (because the browser will extend the document size if there is an overflow
                    // on the right, but not on the left). The sort function above has already
                    // made sure that a bottom document overflow is preferred to a top overflow,
                    // so we don't have to care about it.

                    // if there is an overflow on the right
                    if (finalResult.coord.left > helper.geo.window.size.width - finalResult.size.width) {

                        // this may actually create on overflow on the left but we'll fix it in a sec
                        finalResult.coord.left = helper.geo.window.size.width - finalResult.size.width;
                    }

                    // if there is an overflow on the left
                    if (finalResult.coord.left < 0) {

                        // don't care if it overflows the right after that, we made our best
                        finalResult.coord.left = 0;
                    }
                }


                // submit the positioning proposal to the user function which may choose to change
                // the side, size and/or the coordinates

                // first, set the rules that corresponds to the proposed side: it may change
                // the size of the tooltip, and the custom functionPosition may want to detect the
                // size of something before making a decision. So let's make things easier for the
                // implementor
                self.__sideChange($clone, finalResult.side);

                // add some variables to the helper
                helper.tooltipClone = $clone[0];
                helper.tooltipParent = self.__instance.option('parent').parent[0];
                // move informative values to the helper
                helper.mode = finalResult.mode;
                helper.whole = finalResult.whole;
                // add some variables to the helper for the functionPosition callback (these
                // will also be added to the event fired by self.__instance._trigger but that's
                // ok, we're just being consistent)
                helper.origin = self.__instance._$origin[0];
                helper.tooltip = self.__instance._$tooltip[0];

                // leave only the actionable values in there for functionPosition
                delete finalResult.container;
                delete finalResult.fits;
                delete finalResult.mode;
                delete finalResult.outerSize;
                delete finalResult.whole;

                // keep only the distance on the relevant side, for clarity
                finalResult.distance = finalResult.distance.horizontal || finalResult.distance.vertical;

                // beginners may not be comfortable with the concept of editing the object
                //  passed by reference, so we provide an edit function and pass a clone
                var finalResultClone = $.extend(true, {}, finalResult);

                // emit an event on the instance
                self.__instance._trigger({
                    edit: function(result) {
                        finalResult = result;
                    },
                    event: event,
                    helper: helper,
                    position: finalResultClone,
                    type: 'position'
                });

                if (self.__options.functionPosition) {

                    var result = self.__options.functionPosition.call(self, self.__instance, helper, finalResultClone);

                    if (result) finalResult = result;
                }

                // end the positioning tests session (the user might have had a
                // use for it during the position event, now it's over)
                ruler.destroy();

                // compute the position of the target relatively to the tooltip root
                // element so we can place the arrow and make the needed adjustments
                var arrowCoord,
                    maxVal;

                if (finalResult.side == 'top' || finalResult.side == 'bottom') {

                    arrowCoord = {
                        prop: 'left',
                        val: finalResult.target - finalResult.coord.left
                    };
                    maxVal = finalResult.size.width - this.__options.minIntersection;
                }
                else {

                    arrowCoord = {
                        prop: 'top',
                        val: finalResult.target - finalResult.coord.top
                    };
                    maxVal = finalResult.size.height - this.__options.minIntersection;
                }

                // cannot lie beyond the boundaries of the tooltip, minus the
                // arrow margin
                if (arrowCoord.val < this.__options.minIntersection) {
                    arrowCoord.val = this.__options.minIntersection;
                }
                else if (arrowCoord.val > maxVal) {
                    arrowCoord.val = maxVal;
                }

                var originParentOffset;

                // let's convert the window-relative coordinates into coordinates relative to the
                // future positioned parent that the tooltip will be appended to
                if (helper.geo.origin.fixedLineage) {

                    // same as windowOffset when the position is fixed
                    originParentOffset = helper.geo.origin.windowOffset;
                }
                else {

                    // this assumes that the parent of the tooltip is located at
                    // (0, 0) in the document, typically like when the parent is
                    // <body>.
                    // If we ever allow other types of parent, .tooltipster-ruler
                    // will have to be appended to the parent to inherit css style
                    // values that affect the display of the text and such.
                    originParentOffset = {
                        left: helper.geo.origin.windowOffset.left + helper.geo.window.scroll.left,
                        top: helper.geo.origin.windowOffset.top + helper.geo.window.scroll.top
                    };
                }

                finalResult.coord = {
                    left: originParentOffset.left + (finalResult.coord.left - helper.geo.origin.windowOffset.left),
                    top: originParentOffset.top + (finalResult.coord.top - helper.geo.origin.windowOffset.top)
                };

                // set position values on the original tooltip element

                self.__sideChange(self.__instance._$tooltip, finalResult.side);

                if (helper.geo.origin.fixedLineage) {
                    self.__instance._$tooltip
                        .css('position', 'fixed');
                }
                else {
                    // CSS default
                    self.__instance._$tooltip
                        .css('position', '');
                }

                self.__instance._$tooltip
                    .css({
                        left: finalResult.coord.left,
                        top: finalResult.coord.top,
                        // we need to set a size even if the tooltip is in its natural size
                        // because when the tooltip is positioned beyond the width of the body
                        // (which is by default the width of the window; it will happen when
                        // you scroll the window horizontally to get to the origin), its text
                        // content will otherwise break lines at each word to keep up with the
                        // body overflow strategy.
                        height: finalResult.size.height,
                        width: finalResult.size.width
                    })
                    .find('.tooltipster-arrow')
                    .css({
                        'left': '',
                        'top': ''
                    })
                    .css(arrowCoord.prop, arrowCoord.val);

                // append the tooltip HTML element to its parent
                self.__instance._$tooltip.appendTo(self.__instance.option('parent'));

                self.__instance._trigger({
                    type: 'repositioned',
                    event: event,
                    position: finalResult
                });
            },

            /**
             * Make whatever modifications are needed when the side is changed. This has
             * been made an independant method for easy inheritance in custom plugins based
             * on this default plugin.
             *
             * @param {object} $obj
             * @param {string} side
             * @private
             */
            __sideChange: function($obj, side) {

                $obj
                    .removeClass('tooltipster-bottom')
                    .removeClass('tooltipster-left')
                    .removeClass('tooltipster-right')
                    .removeClass('tooltipster-top')
                    .addClass('tooltipster-'+ side);
            },

            /**
             * Returns the target that the tooltip should aim at for a given side.
             * The calculated value is a distance from the edge of the window
             * (left edge for top/bottom sides, top edge for left/right side). The
             * tooltip will be centered on that position and the arrow will be
             * positioned there (as much as possible).
             *
             * @param {object} helper
             * @return {integer}
             * @private
             */
            __targetFind: function(helper) {

                var target = {},
                    rects = this.__instance._$origin[0].getClientRects();

                // these lines fix a Chrome bug (issue #491)
                if (rects.length > 1) {
                    var opacity = this.__instance._$origin.css('opacity');
                    if(opacity == 1) {
                        this.__instance._$origin.css('opacity', 0.99);
                        rects = this.__instance._$origin[0].getClientRects();
                        this.__instance._$origin.css('opacity', 1);
                    }
                }

                // by default, the target will be the middle of the origin
                if (rects.length < 2) {

                    target.top = Math.floor(helper.geo.origin.windowOffset.left + (helper.geo.origin.size.width / 2));
                    target.bottom = target.top;

                    target.left = Math.floor(helper.geo.origin.windowOffset.top + (helper.geo.origin.size.height / 2));
                    target.right = target.left;
                }
                // if multiple client rects exist, the element may be text split
                // up into multiple lines and the middle of the origin may not be
                // best option anymore. We need to choose the best target client rect
                else {

                    // top: the first
                    var targetRect = rects[0];
                    target.top = Math.floor(targetRect.left + (targetRect.right - targetRect.left) / 2);

                    // right: the middle line, rounded down in case there is an even
                    // number of lines (looks more centered => check out the
                    // demo with 4 split lines)
                    if (rects.length > 2) {
                        targetRect = rects[Math.ceil(rects.length / 2) - 1];
                    }
                    else {
                        targetRect = rects[0];
                    }
                    target.right = Math.floor(targetRect.top + (targetRect.bottom - targetRect.top) / 2);

                    // bottom: the last
                    targetRect = rects[rects.length - 1];
                    target.bottom = Math.floor(targetRect.left + (targetRect.right - targetRect.left) / 2);

                    // left: the middle line, rounded up
                    if (rects.length > 2) {
                        targetRect = rects[Math.ceil((rects.length + 1) / 2) - 1];
                    }
                    else {
                        targetRect = rects[rects.length - 1];
                    }

                    target.left = Math.floor(targetRect.top + (targetRect.bottom - targetRect.top) / 2);
                }

                return target;
            }
        }
    });

    /* a build task will add "return $;" here */
    return $;

}));

/*! @vimeo/player v2.7.0 | (c) 2019 Vimeo | MIT License | https://github.com/vimeo/player.js */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e.Vimeo=e.Vimeo||{},e.Vimeo.Player=t())}(this,function(){"use strict";function r(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var e="undefined"!=typeof global&&"[object global]"==={}.toString.call(global);function i(e,t){return 0===e.indexOf(t.toLowerCase())?e:"".concat(t.toLowerCase()).concat(e.substr(0,1).toUpperCase()).concat(e.substr(1))}function s(e){return/^(https?:)?\/\/((player|www)\.)?vimeo\.com(?=$|\/)/.test(e)}function l(){var e,t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},n=t.id,r=t.url,o=n||r;if(!o)throw new Error("An id or url must be passed, either in an options object or as a data-vimeo-id or data-vimeo-url attribute.");if(e=o,!isNaN(parseFloat(e))&&isFinite(e)&&Math.floor(e)==e)return"https://vimeo.com/".concat(o);if(s(o))return o.replace("http:","https:");if(n)throw new TypeError("“".concat(n,"” is not a valid video id."));throw new TypeError("“".concat(o,"” is not a vimeo.com url."))}var t=void 0!==Array.prototype.indexOf,n="undefined"!=typeof window&&void 0!==window.postMessage;if(!(e||t&&n))throw new Error("Sorry, the Vimeo Player API is not available in this browser.");var o="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};!function(e){if(!e.WeakMap){var n=Object.prototype.hasOwnProperty,o=function(e,t,n){Object.defineProperty?Object.defineProperty(e,t,{configurable:!0,writable:!0,value:n}):e[t]=n};e.WeakMap=function(){function e(){if(void 0===this)throw new TypeError("Constructor WeakMap requires 'new'");if(o(this,"_id","_WeakMap"+"_"+t()+"."+t()),0<arguments.length)throw new TypeError("WeakMap iterable is not supported")}function r(e,t){if(!i(e)||!n.call(e,"_id"))throw new TypeError(t+" method called on incompatible receiver "+typeof e)}function t(){return Math.random().toString().substring(2)}return o(e.prototype,"delete",function(e){if(r(this,"delete"),!i(e))return!1;var t=e[this._id];return!(!t||t[0]!==e)&&(delete e[this._id],!0)}),o(e.prototype,"get",function(e){if(r(this,"get"),i(e)){var t=e[this._id];return t&&t[0]===e?t[1]:void 0}}),o(e.prototype,"has",function(e){if(r(this,"has"),!i(e))return!1;var t=e[this._id];return!(!t||t[0]!==e)}),o(e.prototype,"set",function(e,t){if(r(this,"set"),!i(e))throw new TypeError("Invalid value used as weak map key");var n=e[this._id];return n&&n[0]===e?n[1]=t:o(e,this._id,[e,t]),this}),o(e,"_polyfill",!0),e}()}function i(e){return Object(e)===e}}("undefined"!=typeof self?self:"undefined"!=typeof window?window:o);var a,f=(function(e){var t,n,r;r=function(){var t,a,n,e=Object.prototype.toString,r="undefined"!=typeof setImmediate?function(e){return setImmediate(e)}:setTimeout;try{Object.defineProperty({},"x",{}),t=function(e,t,n,r){return Object.defineProperty(e,t,{value:n,writable:!0,configurable:!1!==r})}}catch(e){t=function(e,t,n){return e[t]=n,e}}function i(e,t){n.add(e,t),a||(a=r(n.drain))}function u(e){var t,n=typeof e;return null==e||"object"!=n&&"function"!=n||(t=e.then),"function"==typeof t&&t}function c(){for(var e=0;e<this.chain.length;e++)o(this,1===this.state?this.chain[e].success:this.chain[e].failure,this.chain[e]);this.chain.length=0}function o(e,t,n){var r,o;try{!1===t?n.reject(e.msg):(r=!0===t?e.msg:t.call(void 0,e.msg))===n.promise?n.reject(TypeError("Promise-chain cycle")):(o=u(r))?o.call(r,n.resolve,n.reject):n.resolve(r)}catch(e){n.reject(e)}}function s(e){var t=this;t.triggered||(t.triggered=!0,t.def&&(t=t.def),t.msg=e,t.state=2,0<t.chain.length&&i(c,t))}function l(e,n,r,o){for(var t=0;t<n.length;t++)!function(t){e.resolve(n[t]).then(function(e){r(t,e)},o)}(t)}function f(e){this.def=e,this.triggered=!1}function d(e){this.promise=e,this.state=0,this.triggered=!1,this.chain=[],this.msg=void 0}function h(e){if("function"!=typeof e)throw TypeError("Not a function");if(0!==this.__NPO__)throw TypeError("Not a promise");this.__NPO__=1;var r=new d(this);this.then=function(e,t){var n={success:"function"!=typeof e||e,failure:"function"==typeof t&&t};return n.promise=new this.constructor(function(e,t){if("function"!=typeof e||"function"!=typeof t)throw TypeError("Not a function");n.resolve=e,n.reject=t}),r.chain.push(n),0!==r.state&&i(c,r),n.promise},this.catch=function(e){return this.then(void 0,e)};try{e.call(void 0,function(e){(function e(n){var r,o=this;if(!o.triggered){o.triggered=!0,o.def&&(o=o.def);try{(r=u(n))?i(function(){var t=new f(o);try{r.call(n,function(){e.apply(t,arguments)},function(){s.apply(t,arguments)})}catch(e){s.call(t,e)}}):(o.msg=n,o.state=1,0<o.chain.length&&i(c,o))}catch(e){s.call(new f(o),e)}}}).call(r,e)},function(e){s.call(r,e)})}catch(e){s.call(r,e)}}n=function(){var n,r,o;function i(e,t){this.fn=e,this.self=t,this.next=void 0}return{add:function(e,t){o=new i(e,t),r?r.next=o:n=o,r=o,o=void 0},drain:function(){var e=n;for(n=r=a=void 0;e;)e.fn.call(e.self),e=e.next}}}();var v=t({},"constructor",h,!1);return t(h.prototype=v,"__NPO__",0,!1),t(h,"resolve",function(n){return n&&"object"==typeof n&&1===n.__NPO__?n:new this(function(e,t){if("function"!=typeof e||"function"!=typeof t)throw TypeError("Not a function");e(n)})}),t(h,"reject",function(n){return new this(function(e,t){if("function"!=typeof e||"function"!=typeof t)throw TypeError("Not a function");t(n)})}),t(h,"all",function(t){var a=this;return"[object Array]"!=e.call(t)?a.reject(TypeError("Not an array")):0===t.length?a.resolve([]):new a(function(n,e){if("function"!=typeof n||"function"!=typeof e)throw TypeError("Not a function");var r=t.length,o=Array(r),i=0;l(a,t,function(e,t){o[e]=t,++i===r&&n(o)},e)})}),t(h,"race",function(t){var r=this;return"[object Array]"!=e.call(t)?r.reject(TypeError("Not an array")):new r(function(n,e){if("function"!=typeof n||"function"!=typeof e)throw TypeError("Not a function");l(r,t,function(e,t){n(t)},e)})}),h},(n=o)[t="Promise"]=n[t]||r(),e.exports&&(e.exports=n[t])}(a={exports:{}},a.exports),a.exports),d=new WeakMap;function u(e,t,n){var r=d.get(e.element)||{};t in r||(r[t]=[]),r[t].push(n),d.set(e.element,r)}function c(e,t){return(d.get(e.element)||{})[t]||[]}function h(e,t,n){var r=d.get(e.element)||{};if(!r[t])return!0;if(!n)return r[t]=[],d.set(e.element,r),!0;var o=r[t].indexOf(n);return-1!==o&&r[t].splice(o,1),d.set(e.element,r),r[t]&&0===r[t].length}var v=["autopause","autoplay","background","byline","color","height","id","loop","maxheight","maxwidth","muted","playsinline","portrait","responsive","speed","title","transparent","url","width"];function p(r){var e=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};return v.reduce(function(e,t){var n=r.getAttribute("data-vimeo-".concat(t));return(n||""===n)&&(e[t]=""===n?1:n),e},e)}function y(e,t){var n=e.html;if(!t)throw new TypeError("An element must be provided");if(null!==t.getAttribute("data-vimeo-initialized"))return t.querySelector("iframe");var r=document.createElement("div");return r.innerHTML=n,t.appendChild(r.firstChild),t.setAttribute("data-vimeo-initialized","true"),t.querySelector("iframe")}function m(i){var a=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},u=2<arguments.length?arguments[2]:void 0;return new Promise(function(t,n){if(!s(i))throw new TypeError("“".concat(i,"” is not a vimeo.com url."));var e="https://vimeo.com/api/oembed.json?url=".concat(encodeURIComponent(i),"&domain=").concat(window.location.hostname);for(var r in a)a.hasOwnProperty(r)&&(e+="&".concat(r,"=").concat(encodeURIComponent(a[r])));var o="XDomainRequest"in window?new XDomainRequest:new XMLHttpRequest;o.open("GET",e,!0),o.onload=function(){if(404!==o.status)if(403!==o.status)try{var e=JSON.parse(o.responseText);if(403===e.domain_status_code)return y(e,u),void n(new Error("“".concat(i,"” is not embeddable.")));t(e)}catch(e){n(e)}else n(new Error("“".concat(i,"” is not embeddable.")));else n(new Error("“".concat(i,"” was not found.")))},o.onerror=function(){var e=o.status?" (".concat(o.status,")"):"";n(new Error("There was an error fetching the embed code from Vimeo".concat(e,".")))},o.send()})}function g(e){return"string"==typeof e&&(e=JSON.parse(e)),e}function w(e,t,n){if(e.element.contentWindow&&e.element.contentWindow.postMessage){var r={method:t};void 0!==n&&(r.value=n);var o=parseFloat(navigator.userAgent.toLowerCase().replace(/^.*msie (\d+).*$/,"$1"));8<=o&&o<10&&(r=JSON.stringify(r)),e.element.contentWindow.postMessage(r,e.origin)}}function b(n,r){var t,e=[];if((r=g(r)).event){if("error"===r.event)c(n,r.data.method).forEach(function(e){var t=new Error(r.data.message);t.name=r.data.name,e.reject(t),h(n,r.data.method,e)});e=c(n,"event:".concat(r.event)),t=r.data}else if(r.method){var o=function(e,t){var n=c(e,t);if(n.length<1)return!1;var r=n.shift();return h(e,t,r),r}(n,r.method);o&&(e.push(o),t=r.value)}e.forEach(function(e){try{if("function"==typeof e)return void e.call(n,t);e.resolve(t)}catch(e){}})}var k=new WeakMap,E=new WeakMap,Player=function(){function Player(u){var e,c=this,n=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};if(function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,Player),window.jQuery&&u instanceof jQuery&&(1<u.length&&window.console&&console.warn&&console.warn("A jQuery object with multiple elements was passed, using the first element."),u=u[0]),"undefined"!=typeof document&&"string"==typeof u&&(u=document.getElementById(u)),e=u,!Boolean(e&&1===e.nodeType&&"nodeName"in e&&e.ownerDocument&&e.ownerDocument.defaultView))throw new TypeError("You must pass either a valid element or a valid id.");var r=u.ownerDocument.defaultView;if("IFRAME"!==u.nodeName){var t=u.querySelector("iframe");t&&(u=t)}if("IFRAME"===u.nodeName&&!s(u.getAttribute("src")||""))throw new Error("The player element passed isn’t a Vimeo embed.");if(k.has(u))return k.get(u);this.element=u,this.origin="*";var o=new f(function(i,a){var e=function(e){if(s(e.origin)&&c.element.contentWindow===e.source){"*"===c.origin&&(c.origin=e.origin);var t=g(e.data);if(t&&"error"===t.event&&t.data&&"ready"===t.data.method){var n=new Error(t.data.message);return n.name=t.data.name,void a(n)}var r=t&&"ready"===t.event,o=t&&"ping"===t.method;if(r||o)return c.element.setAttribute("data-ready","true"),void i();b(c,t)}};if(r.addEventListener?r.addEventListener("message",e,!1):r.attachEvent&&r.attachEvent("onmessage",e),"IFRAME"!==c.element.nodeName){var t=p(u,n);m(l(t),t,u).then(function(e){var t,n,r,o=y(e,u);return c.element=o,c._originalElement=u,t=u,n=o,r=d.get(t),d.set(n,r),d.delete(t),k.set(c.element,c),e}).catch(a)}});return E.set(this,o),k.set(this.element,this),"IFRAME"===this.element.nodeName&&w(this,"ping"),this}var e,t,n;return e=Player,(t=[{key:"callMethod",value:function(n){var r=this,o=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};return new f(function(e,t){return r.ready().then(function(){u(r,n,{resolve:e,reject:t}),w(r,n,o)}).catch(t)})}},{key:"get",value:function(n){var r=this;return new f(function(e,t){return n=i(n,"get"),r.ready().then(function(){u(r,n,{resolve:e,reject:t}),w(r,n)}).catch(t)})}},{key:"set",value:function(n,r){var o=this;return new f(function(e,t){if(n=i(n,"set"),null==r)throw new TypeError("There must be a value to set.");return o.ready().then(function(){u(o,n,{resolve:e,reject:t}),w(o,n,r)}).catch(t)})}},{key:"on",value:function(e,t){if(!e)throw new TypeError("You must pass an event name.");if(!t)throw new TypeError("You must pass a callback function.");if("function"!=typeof t)throw new TypeError("The callback must be a function.");0===c(this,"event:".concat(e)).length&&this.callMethod("addEventListener",e).catch(function(){}),u(this,"event:".concat(e),t)}},{key:"off",value:function(e,t){if(!e)throw new TypeError("You must pass an event name.");if(t&&"function"!=typeof t)throw new TypeError("The callback must be a function.");h(this,"event:".concat(e),t)&&this.callMethod("removeEventListener",e).catch(function(e){})}},{key:"loadVideo",value:function(e){return this.callMethod("loadVideo",e)}},{key:"ready",value:function(){var e=E.get(this)||new f(function(e,t){t(new Error("Unknown player. Probably unloaded."))});return f.resolve(e)}},{key:"addCuePoint",value:function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};return this.callMethod("addCuePoint",{time:e,data:t})}},{key:"removeCuePoint",value:function(e){return this.callMethod("removeCuePoint",e)}},{key:"enableTextTrack",value:function(e,t){if(!e)throw new TypeError("You must pass a language.");return this.callMethod("enableTextTrack",{language:e,kind:t})}},{key:"disableTextTrack",value:function(){return this.callMethod("disableTextTrack")}},{key:"pause",value:function(){return this.callMethod("pause")}},{key:"play",value:function(){return this.callMethod("play")}},{key:"unload",value:function(){return this.callMethod("unload")}},{key:"destroy",value:function(){var t=this;return new f(function(e){E.delete(t),k.delete(t.element),t._originalElement&&(k.delete(t._originalElement),t._originalElement.removeAttribute("data-vimeo-initialized")),t.element&&"IFRAME"===t.element.nodeName&&t.element.parentNode&&t.element.parentNode.removeChild(t.element),e()})}},{key:"getAutopause",value:function(){return this.get("autopause")}},{key:"setAutopause",value:function(e){return this.set("autopause",e)}},{key:"getBuffered",value:function(){return this.get("buffered")}},{key:"getColor",value:function(){return this.get("color")}},{key:"setColor",value:function(e){return this.set("color",e)}},{key:"getCuePoints",value:function(){return this.get("cuePoints")}},{key:"getCurrentTime",value:function(){return this.get("currentTime")}},{key:"setCurrentTime",value:function(e){return this.set("currentTime",e)}},{key:"getDuration",value:function(){return this.get("duration")}},{key:"getEnded",value:function(){return this.get("ended")}},{key:"getLoop",value:function(){return this.get("loop")}},{key:"setLoop",value:function(e){return this.set("loop",e)}},{key:"getPaused",value:function(){return this.get("paused")}},{key:"getPlaybackRate",value:function(){return this.get("playbackRate")}},{key:"setPlaybackRate",value:function(e){return this.set("playbackRate",e)}},{key:"getPlayed",value:function(){return this.get("played")}},{key:"getSeekable",value:function(){return this.get("seekable")}},{key:"getTextTracks",value:function(){return this.get("textTracks")}},{key:"getVideoEmbedCode",value:function(){return this.get("videoEmbedCode")}},{key:"getVideoId",value:function(){return this.get("videoId")}},{key:"getVideoTitle",value:function(){return this.get("videoTitle")}},{key:"getVideoWidth",value:function(){return this.get("videoWidth")}},{key:"getVideoHeight",value:function(){return this.get("videoHeight")}},{key:"getVideoUrl",value:function(){return this.get("videoUrl")}},{key:"getVolume",value:function(){return this.get("volume")}},{key:"setVolume",value:function(e){return this.set("volume",e)}}])&&r(e.prototype,t),n&&r(e,n),Player}();return e||(function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:document,t=[].slice.call(e.querySelectorAll("[data-vimeo-id], [data-vimeo-url]")),n=function(e){"console"in window&&console.error&&console.error("There was an error creating an embed: ".concat(e))};t.forEach(function(t){try{if(null!==t.getAttribute("data-vimeo-defer"))return;var e=p(t);m(l(e),e,t).then(function(e){return y(e,t)}).catch(n)}catch(e){n(e)}})}(),function(){var r=0<arguments.length&&void 0!==arguments[0]?arguments[0]:document;if(!window.VimeoPlayerResizeEmbeds_){window.VimeoPlayerResizeEmbeds_=!0;var e=function(e){if(s(e.origin)&&e.data&&"spacechange"===e.data.event)for(var t=r.querySelectorAll("iframe"),n=0;n<t.length;n++)if(t[n].contentWindow===e.source){t[n].parentElement.style.paddingBottom="".concat(e.data.data[0].bottom,"px");break}};window.addEventListener?window.addEventListener("message",e,!1):window.attachEvent&&window.attachEvent("onmessage",e)}}()),Player});
/*!
 * headroom.js v0.9.4 - Give your page some headroom. Hide your header until you need it
 * Copyright (c) 2017 Nick Williams - http://wicky.nillia.ms/headroom.js
 * License: MIT
 */

!function(a,b){"use strict";"function"==typeof define&&define.amd?define([],b):"object"==typeof exports?module.exports=b():a.Headroom=b()}(this,function(){"use strict";function a(a){this.callback=a,this.ticking=!1}function b(a){return a&&"undefined"!=typeof window&&(a===window||a.nodeType)}function c(a){if(arguments.length<=0)throw new Error("Missing arguments in extend function");var d,e,f=a||{};for(e=1;e<arguments.length;e++){var g=arguments[e]||{};for(d in g)"object"!=typeof f[d]||b(f[d])?f[d]=f[d]||g[d]:f[d]=c(f[d],g[d])}return f}function d(a){return a===Object(a)?a:{down:a,up:a}}function e(a,b){b=c(b,e.options),this.lastKnownScrollY=0,this.elem=a,this.tolerance=d(b.tolerance),this.classes=b.classes,this.offset=b.offset,this.scroller=b.scroller,this.initialised=!1,this.onPin=b.onPin,this.onUnpin=b.onUnpin,this.onTop=b.onTop,this.onNotTop=b.onNotTop,this.onBottom=b.onBottom,this.onNotBottom=b.onNotBottom}var f={bind:!!function(){}.bind,classList:"classList"in document.documentElement,rAF:!!(window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame)};return window.requestAnimationFrame=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame,a.prototype={constructor:a,update:function(){this.callback&&this.callback(),this.ticking=!1},requestTick:function(){this.ticking||(requestAnimationFrame(this.rafCallback||(this.rafCallback=this.update.bind(this))),this.ticking=!0)},handleEvent:function(){this.requestTick()}},e.prototype={constructor:e,init:function(){if(e.cutsTheMustard)return this.debouncer=new a(this.update.bind(this)),this.elem.classList.add(this.classes.initial),setTimeout(this.attachEvent.bind(this),100),this},destroy:function(){var a=this.classes;this.initialised=!1;for(var b in a)a.hasOwnProperty(b)&&this.elem.classList.remove(a[b]);this.scroller.removeEventListener("scroll",this.debouncer,!1)},attachEvent:function(){this.initialised||(this.lastKnownScrollY=this.getScrollY(),this.initialised=!0,this.scroller.addEventListener("scroll",this.debouncer,!1),this.debouncer.handleEvent())},unpin:function(){var a=this.elem.classList,b=this.classes;!a.contains(b.pinned)&&a.contains(b.unpinned)||(a.add(b.unpinned),a.remove(b.pinned),this.onUnpin&&this.onUnpin.call(this))},pin:function(){var a=this.elem.classList,b=this.classes;a.contains(b.unpinned)&&(a.remove(b.unpinned),a.add(b.pinned),this.onPin&&this.onPin.call(this))},top:function(){var a=this.elem.classList,b=this.classes;a.contains(b.top)||(a.add(b.top),a.remove(b.notTop),this.onTop&&this.onTop.call(this))},notTop:function(){var a=this.elem.classList,b=this.classes;a.contains(b.notTop)||(a.add(b.notTop),a.remove(b.top),this.onNotTop&&this.onNotTop.call(this))},bottom:function(){var a=this.elem.classList,b=this.classes;a.contains(b.bottom)||(a.add(b.bottom),a.remove(b.notBottom),this.onBottom&&this.onBottom.call(this))},notBottom:function(){var a=this.elem.classList,b=this.classes;a.contains(b.notBottom)||(a.add(b.notBottom),a.remove(b.bottom),this.onNotBottom&&this.onNotBottom.call(this))},getScrollY:function(){return void 0!==this.scroller.pageYOffset?this.scroller.pageYOffset:void 0!==this.scroller.scrollTop?this.scroller.scrollTop:(document.documentElement||document.body.parentNode||document.body).scrollTop},getViewportHeight:function(){return window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight},getElementPhysicalHeight:function(a){return Math.max(a.offsetHeight,a.clientHeight)},getScrollerPhysicalHeight:function(){return this.scroller===window||this.scroller===document.body?this.getViewportHeight():this.getElementPhysicalHeight(this.scroller)},getDocumentHeight:function(){var a=document.body,b=document.documentElement;return Math.max(a.scrollHeight,b.scrollHeight,a.offsetHeight,b.offsetHeight,a.clientHeight,b.clientHeight)},getElementHeight:function(a){return Math.max(a.scrollHeight,a.offsetHeight,a.clientHeight)},getScrollerHeight:function(){return this.scroller===window||this.scroller===document.body?this.getDocumentHeight():this.getElementHeight(this.scroller)},isOutOfBounds:function(a){var b=a<0,c=a+this.getScrollerPhysicalHeight()>this.getScrollerHeight();return b||c},toleranceExceeded:function(a,b){return Math.abs(a-this.lastKnownScrollY)>=this.tolerance[b]},shouldUnpin:function(a,b){var c=a>this.lastKnownScrollY,d=a>=this.offset;return c&&d&&b},shouldPin:function(a,b){var c=a<this.lastKnownScrollY,d=a<=this.offset;return c&&b||d},update:function(){var a=this.getScrollY(),b=a>this.lastKnownScrollY?"down":"up",c=this.toleranceExceeded(a,b);this.isOutOfBounds(a)||(a<=this.offset?this.top():this.notTop(),a+this.getViewportHeight()>=this.getScrollerHeight()?this.bottom():this.notBottom(),this.shouldUnpin(a,c)?this.unpin():this.shouldPin(a,c)&&this.pin(),this.lastKnownScrollY=a)}},e.options={tolerance:{up:0,down:0},offset:0,scroller:window,classes:{pinned:"headroom--pinned",unpinned:"headroom--unpinned",top:"headroom--top",notTop:"headroom--not-top",bottom:"headroom--bottom",notBottom:"headroom--not-bottom",initial:"headroom"}},e.cutsTheMustard="undefined"!=typeof f&&f.rAF&&f.bind&&f.classList,e});

(function($) {

    if(!$) {
        return;
    }

    ////////////
    // Plugin //
    ////////////

    $.fn.headroom = function(option) {
        return this.each(function() {
            var $this   = $(this),
                data      = $this.data('headroom'),
                options   = typeof option === 'object' && option;

            options = $.extend(true, {}, Headroom.options, options);

            if (!data) {
                data = new Headroom(this, options);
                data.init();
                $this.data('headroom', data);
            }
            if (typeof option === 'string') {
                data[option]();

                if(option === 'destroy'){
                    $this.removeData('headroom');
                }
            }
        });
    };

    //////////////
    // Data API //
    //////////////

    $('[data-headroom]').each(function() {
        var $this = $(this);
        $this.headroom($this.data());
    });

}(window.Zepto || window.jQuery));
/*! npm.im/iphone-inline-video 2.2.2 */
var enableInlineVideo = (function () {
    'use strict';

    /*! npm.im/intervalometer */
    function intervalometer(cb, request, cancel, requestParameter) {
        var requestId;
        var previousLoopTime;
        function loop(now) {
            // must be requested before cb() because that might call .stop()
            requestId = request(loop, requestParameter);

            // called with "ms since last call". 0 on start()
            cb(now - (previousLoopTime || now));

            previousLoopTime = now;
        }
        return {
            start: function start() {
                if (!requestId) { // prevent double starts
                    loop(0);
                }
            },
            stop: function stop() {
                cancel(requestId);
                requestId = null;
                previousLoopTime = 0;
            }
        };
    }

    function frameIntervalometer(cb) {
        return intervalometer(cb, requestAnimationFrame, cancelAnimationFrame);
    }

    function preventEvent(element, eventName, test) {
        function handler(e) {
            if (!test || test(element, eventName)) {
                e.stopImmediatePropagation();
                // // console.log(eventName, 'prevented on', element);
            }
        }
        element.addEventListener(eventName, handler);

        // Return handler to allow to disable the prevention. Usage:
        // const preventionHandler = preventEvent(el, 'click');
        // el.removeEventHandler('click', preventionHandler);
        return handler;
    }

    function proxyProperty(object, propertyName, sourceObject, copyFirst) {
        function get() {
            return sourceObject[propertyName];
        }
        function set(value) {
            sourceObject[propertyName] = value;
        }

        if (copyFirst) {
            set(object[propertyName]);
        }

        Object.defineProperty(object, propertyName, {get: get, set: set});
    }

    function proxyEvent(object, eventName, sourceObject) {
        sourceObject.addEventListener(eventName, function () { return object.dispatchEvent(new Event(eventName)); });
    }

    function dispatchEventAsync(element, type) {
        Promise.resolve().then(function () {
            element.dispatchEvent(new Event(type));
        });
    }

    var iOS8or9 = typeof document === 'object' && 'object-fit' in document.head.style && !matchMedia('(-webkit-video-playable-inline)').matches;

    var IIV = 'bfred-it:iphone-inline-video';
    var IIVEvent = 'bfred-it:iphone-inline-video:event';
    var IIVPlay = 'bfred-it:iphone-inline-video:nativeplay';
    var IIVPause = 'bfred-it:iphone-inline-video:nativepause';

    /**
     * UTILS
     */

    function getAudioFromVideo(video) {
        var audio = new Audio();
        proxyEvent(video, 'play', audio);
        proxyEvent(video, 'playing', audio);
        proxyEvent(video, 'pause', audio);
        audio.crossOrigin = video.crossOrigin;

        // 'data:' causes audio.networkState > 0
        // which then allows to keep <audio> in a resumable playing state
        // i.e. once you set a real src it will keep playing if it was if .play() was called
        audio.src = video.src || video.currentSrc || 'data:';

        // // if (audio.src === 'data:') {
        //   TODO: wait for video to be selected
        // // }
        return audio;
    }

    var lastRequests = [];
    var requestIndex = 0;
    var lastTimeupdateEvent;

    function setTime(video, time, rememberOnly) {
        // Allow one timeupdate event every 200+ ms
        if ((lastTimeupdateEvent || 0) + 200 < Date.now()) {
            video[IIVEvent] = true;
            lastTimeupdateEvent = Date.now();
        }
        if (!rememberOnly) {
            video.currentTime = time;
        }
        lastRequests[++requestIndex % 3] = time * 100 | 0 / 100;
    }

    function isPlayerEnded(player) {
        return player.driver.currentTime >= player.video.duration;
    }

    function update(timeDiff) {
        var player = this;
        // // console.log('update', player.video.readyState, player.video.networkState, player.driver.readyState, player.driver.networkState, player.driver.paused);
        if (player.video.readyState >= player.video.HAVE_FUTURE_DATA) {
            if (!player.hasAudio) {
                player.driver.currentTime = player.video.currentTime + ((timeDiff * player.video.playbackRate) / 1000);
                if (player.video.loop && isPlayerEnded(player)) {
                    player.driver.currentTime = 0;
                }
            }
            setTime(player.video, player.driver.currentTime);
        } else if (player.video.networkState === player.video.NETWORK_IDLE && player.video.buffered.length === 0) {
            // This should happen when the source is available but:
            // - it's potentially playing (.paused === false)
            // - it's not ready to play
            // - it's not loading
            // If it hasAudio, that will be loaded in the 'emptied' handler below
            player.video.load();
            // // console.log('Will load');
        }

        // // console.assert(player.video.currentTime === player.driver.currentTime, 'Video not updating!');

        if (player.video.ended) {
            delete player.video[IIVEvent]; // Allow timeupdate event
            player.video.pause(true);
        }
    }

    /**
     * METHODS
     */

    function play() {
        // // console.log('play');
        var video = this;
        var player = video[IIV];

        // If it's fullscreen, use the native player
        if (video.webkitDisplayingFullscreen) {
            video[IIVPlay]();
            return;
        }

        if (player.driver.src !== 'data:' && player.driver.src !== video.src) {
            // // console.log('src changed on play', video.src);
            setTime(video, 0, true);
            player.driver.src = video.src;
        }

        if (!video.paused) {
            return;
        }
        player.paused = false;

        if (video.buffered.length === 0) {
            // .load() causes the emptied event
            // the alternative is .play()+.pause() but that triggers play/pause events, even worse
            // possibly the alternative is preventing this event only once
            video.load();
        }

        player.driver.play();
        player.updater.start();

        if (!player.hasAudio) {
            dispatchEventAsync(video, 'play');
            if (player.video.readyState >= player.video.HAVE_ENOUGH_DATA) {
                // // console.log('onplay');
                dispatchEventAsync(video, 'playing');
            }
        }
    }
    function pause(forceEvents) {
        // // console.log('pause');
        var video = this;
        var player = video[IIV];

        player.driver.pause();
        player.updater.stop();

        // If it's fullscreen, the developer the native player.pause()
        // This is at the end of pause() because it also
        // needs to make sure that the simulation is paused
        if (video.webkitDisplayingFullscreen) {
            video[IIVPause]();
        }

        if (player.paused && !forceEvents) {
            return;
        }

        player.paused = true;
        if (!player.hasAudio) {
            dispatchEventAsync(video, 'pause');
        }

        // Handle the 'ended' event only if it's not fullscreen
        if (video.ended && !video.webkitDisplayingFullscreen) {
            video[IIVEvent] = true;
            dispatchEventAsync(video, 'ended');
        }
    }

    /**
     * SETUP
     */

    function addPlayer(video, hasAudio) {
        var player = {};
        video[IIV] = player;
        player.paused = true; // Track whether 'pause' events have been fired
        player.hasAudio = hasAudio;
        player.video = video;
        player.updater = frameIntervalometer(update.bind(player));

        if (hasAudio) {
            player.driver = getAudioFromVideo(video);
        } else {
            video.addEventListener('canplay', function () {
                if (!video.paused) {
                    // // console.log('oncanplay');
                    dispatchEventAsync(video, 'playing');
                }
            });
            player.driver = {
                src: video.src || video.currentSrc || 'data:',
                muted: true,
                paused: true,
                pause: function () {
                    player.driver.paused = true;
                },
                play: function () {
                    player.driver.paused = false;
                    // Media automatically goes to 0 if .play() is called when it's done
                    if (isPlayerEnded(player)) {
                        setTime(video, 0);
                    }
                },
                get ended() {
                    return isPlayerEnded(player);
                }
            };
        }

        // .load() causes the emptied event
        video.addEventListener('emptied', function () {
            // // console.log('driver src is', player.driver.src);
            var wasEmpty = !player.driver.src || player.driver.src === 'data:';
            if (player.driver.src && player.driver.src !== video.src) {
                // // console.log('src changed to', video.src);
                setTime(video, 0, true);
                player.driver.src = video.src;
                // Playing videos will only keep playing if no src was present when .play()’ed
                if (wasEmpty || (!hasAudio && video.autoplay)) {
                    player.driver.play();
                } else {
                    player.updater.stop();
                }
            }
        }, false);

        // Stop programmatic player when OS takes over
        video.addEventListener('webkitbeginfullscreen', function () {
            if (!video.paused) {
                // Make sure that the <audio> and the syncer/updater are stopped
                video.pause();

                // Play video natively
                video[IIVPlay]();
            } else if (hasAudio && player.driver.buffered.length === 0) {
                // If the first play is native,
                // the <audio> needs to be buffered manually
                // so when the fullscreen ends, it can be set to the same current time
                player.driver.load();
            }
        });
        if (hasAudio) {
            video.addEventListener('webkitendfullscreen', function () {
                // Sync audio to new video position
                player.driver.currentTime = video.currentTime;
                // // console.assert(player.driver.currentTime === video.currentTime, 'Audio not synced');
            });

            // Allow seeking
            video.addEventListener('seeking', function () {
                if (lastRequests.indexOf(video.currentTime * 100 | 0 / 100) < 0) {
                    // // console.log('User-requested seeking');
                    player.driver.currentTime = video.currentTime;
                }
            });
        }
    }

    function preventWithPropOrFullscreen(el) {
        var isAllowed = el[IIVEvent];
        delete el[IIVEvent];
        return !el.webkitDisplayingFullscreen && !isAllowed;
    }

    function overloadAPI(video) {
        var player = video[IIV];
        video[IIVPlay] = video.play;
        video[IIVPause] = video.pause;
        video.play = play;
        video.pause = pause;
        proxyProperty(video, 'paused', player.driver);
        proxyProperty(video, 'muted', player.driver, true);
        proxyProperty(video, 'playbackRate', player.driver, true);
        proxyProperty(video, 'ended', player.driver);
        proxyProperty(video, 'loop', player.driver, true);

        // IIV works by seeking 60 times per second.
        // These events are now useless.
        preventEvent(video, 'seeking', function (el) { return !el.webkitDisplayingFullscreen; });
        preventEvent(video, 'seeked', function (el) { return !el.webkitDisplayingFullscreen; });

        // Limit timeupdate events
        preventEvent(video, 'timeupdate', preventWithPropOrFullscreen);

        // Prevent occasional native ended events
        preventEvent(video, 'ended', preventWithPropOrFullscreen);
    }

    function enableInlineVideo(video, opts) {
        if ( opts === void 0 ) opts = {};

        // Stop if already enabled
        if (video[IIV]) {
            return;
        }

        // Allow the user to skip detection
        if (!opts.everywhere) {
            // Only iOS8 and 9 are supported
            if (!iOS8or9) {
                return;
            }

            // Stop if it's not an allowed device
            if (!(opts.iPad || opts.ipad ? /iPhone|iPod|iPad/ : /iPhone|iPod/).test(navigator.userAgent)) {
                return;
            }
        }

        // Try to pause
        video.pause();

        // Prevent autoplay.
        // An non-started autoplaying video can't be .pause()'d
        var willAutoplay = video.autoplay;
        video.autoplay = false;

        addPlayer(video, !video.muted);
        overloadAPI(video);
        video.classList.add('IIV');

        // Autoplay
        if (video.muted && willAutoplay) {
            video.play();
            video.addEventListener('playing', function restoreAutoplay() {
                video.autoplay = true;
                video.removeEventListener('playing', restoreAutoplay);
            });
        }

        if (!/iPhone|iPod|iPad/.test(navigator.platform)) {
            console.warn('iphone-inline-video is not guaranteed to work in emulated environments');
        }
    }

    return enableInlineVideo;

}());
/*jshint browser:true */
/*!
 * FitVids 1.1
 *
 * Copyright 2013, Chris Coyier - http://css-tricks.com + Dave Rupert - http://daverupert.com
 * Credit to Thierry Koblentz - http://www.alistapart.com/articles/creating-intrinsic-ratios-for-video/
 * Released under the WTFPL license - http://sam.zoy.org/wtfpl/
 *
 */

;(function( $ ){

    'use strict';

    $.fn.fitVids = function( options ) {
        var settings = {
            customSelector: null,
            ignore: null
        };

        if(!document.getElementById('fit-vids-style')) {
            // appendStyles: https://github.com/toddmotto/fluidvids/blob/master/dist/fluidvids.js
            var head = document.head || document.getElementsByTagName('head')[0];
            var css = '.fluid-width-video-wrapper{width:100%;position:relative;padding:0;}.fluid-width-video-wrapper iframe,.fluid-width-video-wrapper object,.fluid-width-video-wrapper embed {position:absolute;top:0;left:0;width:100%;height:100%;}';
            var div = document.createElement("div");
            div.innerHTML = '<p>x</p><style id="fit-vids-style">' + css + '</style>';
            head.appendChild(div.childNodes[1]);
        }

        if ( options ) {
            $.extend( settings, options );
        }

        return this.each(function(){
            var selectors = [
                'iframe[src*="player.vimeo.com"]',
                'iframe[src*="youtube.com"]',
                'iframe[src*="youtube-nocookie.com"]',
                'iframe[src*="kickstarter.com"][src*="video.html"]',
                'object',
                'embed'
            ];

            if (settings.customSelector) {
                selectors.push(settings.customSelector);
            }

            var ignoreList = '.fitvidsignore';

            if(settings.ignore) {
                ignoreList = ignoreList + ', ' + settings.ignore;
            }

            var $allVideos = $(this).find(selectors.join(','));
            $allVideos = $allVideos.not('object object'); // SwfObj conflict patch
            $allVideos = $allVideos.not(ignoreList); // Disable FitVids on this video.

            $allVideos.each(function(){
                var $this = $(this);
                if($this.parents(ignoreList).length > 0) {
                    return; // Disable FitVids on this video.
                }
                if (this.tagName.toLowerCase() === 'embed' && $this.parent('object').length || $this.parent('.fluid-width-video-wrapper').length) { return; }
                if ((!$this.css('height') && !$this.css('width')) && (isNaN($this.attr('height')) || isNaN($this.attr('width'))))
                {
                    $this.attr('height', 9);
                    $this.attr('width', 16);
                }
                var height = ( this.tagName.toLowerCase() === 'object' || ($this.attr('height') && !isNaN(parseInt($this.attr('height'), 10))) ) ? parseInt($this.attr('height'), 10) : $this.height(),
                    width = !isNaN(parseInt($this.attr('width'), 10)) ? parseInt($this.attr('width'), 10) : $this.width(),
                    aspectRatio = height / width;
                if(!$this.attr('name')){
                    var videoName = 'fitvid' + $.fn.fitVids._count;
                    $this.attr('name', videoName);
                    $.fn.fitVids._count++;
                }
                $this.wrap('<div class="fluid-width-video-wrapper"></div>').parent('.fluid-width-video-wrapper').css('padding-top', (aspectRatio * 100)+'%');
                $this.removeAttr('height').removeAttr('width');
            });
        });
    };

    // Internal counter for unique video names.
    $.fn.fitVids._count = 0;

// Works with either jQuery or Zepto
})( window.jQuery || window.Zepto );
/*!
 * ScrollMagic v2.0.7 (2019-05-07)
 * The javascript library for magical scroll interactions.
 * (c) 2019 Jan Paepke (@janpaepke)
 * Project Website: http://scrollmagic.io
 * 
 * @version 2.0.7
 * @license Dual licensed under MIT license and GPL.
 * @author Jan Paepke - e-mail@janpaepke.de
 *
 * @file ScrollMagic jQuery plugin.
 *
 * requires: jQuery >=1.11
 */
/**
 * This plugin is meant to be used in conjunction with jQuery.  
 * It enables ScrollMagic to make use of jQuery's advanced selector engine (sizzle) for all elements supplied to ScrollMagic objects, like scroll containers or trigger elements.  
 * ScrollMagic also accepts jQuery elements for all methods that expect references to DOM elements. Please note, that in most cases the first element of the matched set will be used.
 * 
 * Additionally it provides the ScrollMagic object within the jQuery namespace, so it can be accessed using `$.ScrollMagic`.
 *
 * In contrast to most other plugins it does not offer new API additions for ScrollMagic.
 *
 * To have access to this extension, please include `plugins/jquery.ScrollMagic.js`.
 * @example
 * // create a new scene making use of jQuery's advanced selector engine
 * var scene = new $.ScrollMagic.Scene({
 *   triggerElement: "#parent div.trigger[attr='thisone']:not(.notthisone)"
 * });
 * @requires {@link http://jquery.com/|jQuery >=1.11}
 * @mixin framework.jQuery
 */
(function (root, factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['ScrollMagic', 'jquery'], factory);
	} else if (typeof exports === 'object') {
		// CommonJS
		factory(require('scrollmagic'), require('jquery'));
	} else {
		// Browser global
		factory(root.ScrollMagic, root.jQuery);
	}
}(this, function (ScrollMagic, $) {
	"use strict";
	var NAMESPACE = "jquery.ScrollMagic";

	var
		console = window.console || {},
		err = Function.prototype.bind.call(console.error || console.log || function () {}, console);
	if (!ScrollMagic) {
		err("(" + NAMESPACE + ") -> ERROR: The ScrollMagic main module could not be found. Please make sure it's loaded before this plugin or use an asynchronous loader like requirejs.");
	}
	if (!$) {
		err("(" + NAMESPACE + ") -> ERROR: jQuery could not be found. Please make sure it's loaded before ScrollMagic or use an asynchronous loader like requirejs.");
	}

	ScrollMagic._util.get.elements = function (selector) {
		return $(selector).toArray();
	};
	ScrollMagic._util.addClass = function (elem, classname) {
		$(elem).addClass(classname);
	};
	ScrollMagic._util.removeClass = function (elem, classname) {
		$(elem).removeClass(classname);
	};
	$.ScrollMagic = ScrollMagic;
}));
// video variable
var hasVideo = jQuery('.vid').length;

// Pace
//Pace.once("done", loadedForVideo);
loadedForVideo();
function loadedForVideo() {
    if( hasVideo != 0 ) {
        var mobileBreakpoint = 767;
        var screenSizeState = ( jQuery(window).width() > mobileBreakpoint ) ? 'desktop' : 'mobile';

        jQuery('.vid').each(function(index) {
            // Video variables
            var currentVideo = this;
            jQuery(currentVideo).attr( 'id', 'vid' + index );
            var vidToPlay = document.getElementById( jQuery(currentVideo).attr('id') );
            // decide video urls for mp4
            var desktopVideo = jQuery(currentVideo).data( 'mp4' );
            var mobileVideo = jQuery(currentVideo).data( 'mp4-mobile' );
            var desktopCover = jQuery(currentVideo).data( 'cover-desktop' );
            var mobileCover = jQuery(currentVideo).data( 'cover-mobile' );
            var videoUrl = getVidUrl( desktopVideo, mobileVideo );
            var videoCover = getVidCover( desktopVideo, mobileVideo, desktopCover, mobileCover );
            // decide video urls for webm (available only in hero video)
            var webmVideo = jQuery(currentVideo).data( 'webm' );

            // Set video and load
            jQuery(currentVideo).attr( 'poster', videoCover );
            jQuery(currentVideo).parent().addClass( 'animate-in' );
            jQuery(currentVideo).parent().removeClass( 'loading' );

            addSource( currentVideo, videoUrl, webmVideo );
            vidToPlay.load();
            enableInlineVideo( currentVideo );
            vidToPlay.addEventListener( 'canplaythrough', canPlay(vidToPlay, currentVideo, videoCover) );

            $(window).resize(function() {
                var newScreenState = ( jQuery(window).width() > mobileBreakpoint ) ? 'desktop' : 'mobile';
                if( newScreenState != screenSizeState ) {
                    screenSizeState = newScreenState;
                    jQuery(currentVideo).parent().removeClass( 'animate-in' );
                    jQuery(currentVideo).parent().addClass( 'loading' );
                    var videoUrl = getVidUrl( desktopVideo, mobileVideo );
                    var videoCover = getVidCover( desktopVideo, mobileVideo, desktopCover, mobileCover );
                    addSource( currentVideo, videoUrl, webmVideo );
                    vidToPlay.load();
                    enableInlineVideo( currentVideo );
                    vidToPlay.addEventListener( 'canplaythrough', canPlay(vidToPlay, currentVideo, videoCover) );
                }
            });
        });

        function addSource( currentVideo, videoUrl, webmVideo ) {
            jQuery(currentVideo).html( '' );
            if ( webmVideo ) {
                jQuery(currentVideo).append( '<source src="' + webmVideo + '" type="video/webm">' );
            }
            jQuery(currentVideo).append( '<source src="' + videoUrl + '" type="video/mp4">' );
        }

        function canPlay( vidToPlay, currentVideo, videoCover ) {
            jQuery(currentVideo).parent().removeClass( 'animate-in' );
            if( ! $(vidToPlay).hasClass( 'disable-autoplay' ) ) {
                vidToPlay.play();
            }
            vidToPlay.removeEventListener("oncanplaythrough", canPlay);
            setTimeout(function() {
                jQuery(currentVideo).parent().addClass( 'animate-in' );
                jQuery(currentVideo).parent().removeClass( 'loading' );
            }, 1000);
        }
        function getVidUrl(desktopVideo, mobileVideo) {
            var ww = jQuery(window).width();
            return ( ( ww > mobileBreakpoint && desktopVideo != '' && desktopVideo != null ) || ( ww <= mobileBreakpoint && (mobileVideo == '' || mobileVideo == null) ) ) ? desktopVideo : mobileVideo;
        }
        function getVidCover( desktopVideo, mobileVideo, desktopCover, mobileCover ) {
            var ww = jQuery(window).width();
            return ( ( ww > mobileBreakpoint && desktopVideo != '' && desktopVideo != null ) || ( ww <= mobileBreakpoint && (mobileVideo == '' || mobileVideo == null) ) ) ? desktopCover : mobileCover;
        }
    }
}
(function($) {
    $(function() {

        if( $('.big-quote-slider').length > 0 ) {
            $( '.big-quote-slider' ).each(function(index) {
                var quoteSlider = $(this);
                var sliderId = 'quote-slider-' + index;
                var quoteInitSlide = 0;
                quoteSlider.attr( 'id', sliderId );
                quoteSlider.on('init', function(){
                    setSliderHeight(sliderId);
                });
                if ( quoteSlider.hasClass( 'big-quote-slider--random' ) ) {
                    var slideCount = quoteSlider.find( '.mogule' ).length;
                    quoteInitSlide = Math.floor(Math.random() * slideCount);
                }
                quoteSlider.slick({
                    arrows: true,
                    dots: false,
                    fade: true,
                    adaptiveHeight: false,
                    swipe: true,
                    initialSlide: quoteInitSlide,
                    prevArrow: $('#' + sliderId).find('.quote-prev-arrow'),
                    nextArrow: $('#' + sliderId).find('.quote-next-arrow'),
                    responsive: [
                        {
                            breakpoint: 767,
                            settings: {
                                adaptiveHeight: true,
                                dots: true,
                                arrows: false,
                            }
                        }
                    ]
                });

                $(window).on( 'load', function() {
                    setSliderHeight( sliderId );
                });
            });
        }

        function setSliderHeight( sliderId ) {
            var sliderHeight = $('#' + sliderId).height();
            $('#' + sliderId).find( '.mogule-row' ).css('minHeight', sliderHeight);
        }

    });
})(jQuery);

(function($) {
    $(function() {

        if( $('.feature-slider').length > 0 ) {
            $('.feature-slider-slides').each(function(index) {
                var featureSlider = $(this);
                var sliderId = 'feature-slider-' + index;
                featureSlider.parents( '.feature-slider' ).attr( 'id', sliderId );
                featureSlider.on('init', function(slick) {
                    $( '#' + sliderId + ' .slick-dots' ).appendTo( '#' + sliderId + ' .feature-slider-navigation' );
                });

                featureSlider.slick({
                    arrows: true,
                    dots: true,
                    fade: true,
                    adaptiveHeight: true,
                    swipe: false,
                    customPaging: function(slider, i) {
                        var slideTitle = $(slider.$slides[i]).find('.feature-slide').data('title');
                        return $( '<button type="button" class="btn-nolink" />' ).html( slideTitle );
                    },
                });

                // Add content fade to sidebar if needed.
                if ( featureSlider.parents( '.feature-slider' ).hasClass( 'feature-slider--with-sidebar-content' ) ) {
                    var height = 0;
                    var sidebarTexts = featureSlider.parents('.feature-slider').find( '.feature-slider-sidebar-content' );
                    sidebarTexts.children().each(function() {
                        var currentHeight = $(this).height();
                        if ( height < currentHeight ) {
                            height = currentHeight;
                        }
                    });
                    sidebarTexts.css( 'minHeight', height );
                    featureSlider.on( 'beforeChange', function( event, slick, currentSlide, nextSlide ) {
                        var currentSlide = $( '#' + sliderId + ' .feature-slider-sidebar-content div[data-id="' + currentSlide + '"]');
                        currentSlide.addClass( 'out' ).removeClass( 'active' );
                        $( '#' + sliderId + ' .feature-slider-sidebar-content div[data-id="' + nextSlide + '"]').addClass( 'active' );
                        setTimeout(function() {
                            currentSlide.removeClass('out');
                        }, 500);
                    });
                }

            });
        }

    });
})(jQuery);
(function($) {
    $(function() {
        //call the function when ready
        if( $( '.logo-wall' ).length > 0 ) {
            var wallTimeout = setTimeout(logoWallTimeout, 2000);
            $('.logo-wall-item').hover(
                function() {
                    clearTimeout(wallTimeout);
                    $(this).siblings().removeClass( 'active' );
                    $(this).addClass( 'active' );
                }, function() {
                  wallTimeout = setTimeout(logoWallTimeout, 2000);
                }
              );
        }

        //Actually define the logoWallTimeout()
        function logoWallTimeout(){
            //*** Conditional & Variables ***//
            //Define the current img
            var current = $('.logo-wall .active');
            var numElements = $('.logo-wall-item').length;
            var randomNum = Math.floor(Math.random()*numElements);
            //Select your random element
            var next = $('.logo-wall-item:nth-child(' + randomNum + ')');
            //*** Swap out the imgs and class ***//
            current.removeClass('active');
            next.addClass('active');
            //*** Repeat function every 7 seconds ***//
            wallTimeout = setTimeout(logoWallTimeout, 2000);
        };
    });
})(jQuery);
(function($) {
    $(function() {

        if( $('.mogule-slides').length > 0 ) {
            $('.mogule-slides').each(function(index) {
                var moguleSlider = $(this);
                var sliderId = 'mogule-slider-' + index;
                moguleSlider.parents( '.mogule-image--slides' ).attr( 'id', sliderId );
                var sliderButtons = $('#' + sliderId ).find( '.mogule-slider-navigation .temp-button' );
                moguleSlider.on('init', function(slick) {
                    $( '#' + sliderId + ' .slick-dots' ).appendTo( '#' + sliderId + ' .mogule-slider-navigation' );
                    $('#' + sliderId ).find( '.mogule-slider-navigation .temp-button' ).remove();
                });

                moguleSlider.slick({
                    arrows: false,
                    dots: true,
                    fade: true,
                    adaptiveHeight: false,
                    swipe: false,
                    customPaging: function(slider, i) {
                        return $( '<button type="button" class="btn-nolink" />' ).html( sliderButtons[ i ].innerHTML );
                    },
                });

                moguleSlider.on( 'afterChange', function( event, slick, currentSlide) {
                    var parent = $( '#' + sliderId );
                    // Pause other videos.
                    parent.find('video').trigger('pause');
                    // Play current video.
                    var currentSlideVideo = parent.find('div[data-slick-index="' + currentSlide + '"] video');
                    if ( currentSlideVideo.length > 0) {
                        currentSlideVideo[0].play();
                    }
                });
            });
        }

    });
})(jQuery);
(function($) {
    $(function() {
        //call the function when ready
        if( $( '.quote-slider' ).length > 0 ) {
            setTimeout(quoteSlideShow, 4000);
            $( '.quote-slider' ).each(function() {
                var height = 0;
                var slider = $(this);
                slider.children().each(function() {
                   var currentHeight = $(this).height();
                   if ( height < currentHeight ) {
                       height = currentHeight;
                   }
                });
                slider.css( 'minHeight', height );
            });
        }

        //Actually define the quoteSlideShow()
        function quoteSlideShow(){

            //*** Conditional & Variables ***//

            //Define the current img
            var current = $('.quote-slider .active');
            //If index != 0/false then show next img
            var next = current.next().length ?
                current.next() :
                // if index == false then show first img
                current.siblings().first();

            //*** Swap out the imgs and class ***//
            current.addClass('out').removeClass('active');
            next.addClass('active');
            setTimeout(function() {
               current.removeClass('out');
            }, 500);

            //*** Repeat function every 7 seconds ***//
            setTimeout(quoteSlideShow, 7000);

        };
    });
})(jQuery);
(function($) {
    $(function() {
          // run the script only it there is blog sidebar
          if ( $( '.mogule--parallax' ).length > 0 ) {
              setTimeout(function() {
                  // init parallax controller
                  var parallaxController = new ScrollMagic.Controller();
                  // iterate parallaxes
                  $( '.mogule--parallax' ).each(function( index ) {
                    var parallaxId = 'parallax-' + index;
                    var currentParallax = $(this);
                    currentParallax.attr( 'id', parallaxId );
                    var duration = getDuration(currentParallax);
                    var parallaxOffset = getOffset(currentParallax, duration);
                    var tween = TweenMax.to('#' + parallaxId + ' .mogule-parallax-wrapper', 0.5, {css: {top: parallaxOffset}, ease: Power2.easeInOut});
                    // create a scene
                    var scene = new ScrollMagic.Scene({
                        triggerElement: "#" + parallaxId,
                        duration: "100%",
                        triggerHook: 0.5,
                    })
                    .setTween(tween) // trigger a TweenMax.to tween
                    .addTo(parallaxController); // assign the scene to the controller

                    $(window).on( 'resize, load', function() {
                        var duration = getDuration(currentParallax);
                        var parallaxOffset = getOffset(currentParallax, duration);
                        // reset progress to start so changes do not occur from current position but from start
                        tween.progress(0);
                        // set set new tween parameters
                        tween.updateTo({css: {top: parallaxOffset}}, true);
                        // re-add tween to reset position and to update
                        scene.setTween(tween);
                    });
                  });
              }, 200);
          }

          function getDuration( currentParallax ) {
              return currentParallax.height();
          }

          function getOffset( currentParallax, duration ) {
            var parallaxDuration = currentParallax.find( '.mogule-parallax-wrapper' ).height();
            return duration - parallaxDuration;
          }
    });
  })(jQuery);

(function($) {
  $(function() {
        // run the script only it there is blog sidebar
        if ( $( '.discover-sidebar-pin' ).length > 0 ) {
            setTimeout(function() {
                var navigationHeight = 56;
                var contentHeight = $('.single-post-content--main').height();
                var sidebarHeight = $('.single-post-sidebar').height();
                // blog content height - sidebar height - navigation height - blog content bottom padding
                var pinDuration = contentHeight - sidebarHeight - navigationHeight - 40;
                if ( pinDuration > 0 && sidebarHeight < $(window).height() ) {
                    // init controller
                    var controller = new ScrollMagic.Controller();
                    // create a scene
                    new ScrollMagic.Scene({
                        triggerElement: "#pin-trigger",
                        duration: pinDuration, // the scene should last for a scroll distance of 100px
                        triggerHook: 0,
                        offset: (navigationHeight * -1) // start this scene after scrolling for 50px
                    })
                    .setPin('.discover-sidebar-pin') // pins the element for the the scene's duration
                    .on("progress", function (e) {
                        var progress = e.progress.toFixed(3);
                        if ( progress > 0 ) {
                            $( '.single-post-sidebar' ).removeClass( 'single-post-sidebar--static-pin' );
                        } else {
                            $( '.single-post-sidebar' ).addClass( 'single-post-sidebar--static-pin' );
                        }
					})
                    .addTo(controller); // assign the scene to the controller
                }
            }, 200);
            
        }
  });
})(jQuery);

(function($) {
    $(function() {

        var successCompany = $( '.success-story-company-info' );
        if ( successCompany.length > 0 ) {
            successCompany.clone().appendTo( '.success-story-content--main' );
        }

    });
})(jQuery);
var meomYtTag = document.createElement('script');
meomYtTag.src = "https://www.youtube.com/iframe_api";
var firstScriptTag = document.getElementsByTagName('script')[0];
firstScriptTag.parentNode.insertBefore(meomYtTag, firstScriptTag);

(function($) {
    $(function() {

       $( '.open-video-modal' ).on( 'click', function (event) {
           event.preventDefault();
           var videoType,
               videoUrl;
           var vimeoVideoUrl =  $(this).data( 'video-content' );
           var ytVideoUrl = $(this).data('yt-video-content');
           if ( ytVideoUrl ) {
               videoType = 'yt';
               videoUrl = ytVideoUrl;
           } else {
               videoType = 'vimeo';
               videoUrl = vimeoVideoUrl;
           }
           if ( $(window).width() > 600 ) generateVideoModal( videoUrl, videoType, 'videomodal-' + Date.now() );
           else window.open( videoUrl );
       })

    });
})(jQuery);


function generateVideoModal(videoUrl, videoType, id ) {
    var playerId = 'video-player-' + id;
    var content = '<div id="' + playerId + '" class="modal-video-player-holder" style="opacity:0;"></div>';
    if ( jQuery( '#' + id ).length == 0 ) {
        jQuery( 'body' ).append( '<div class="modal modal--video micromodal-slide" id="' + id + '" aria-hidden="true">' +
            '<div class="modal__overlay" tabindex="-1" data-micromodal-close>' +
            '<div class="modal__container" role="dialog" aria-modal="true" aria-labelledby="modal-1-title">' +
            '<header class="modal__header">' +
            '<button class="modal__close" aria-label="Close modal" data-micromodal-close></button>' +
            '</header>' +
            '<main class="modal__content" id="' + id + '-content">' +
                content +
                '<div class="video-loader"><div></div><div></div><div></div><div></div></div>' +
            '<div class="video-loader"></div></main>' +
            '</div>' +
            '</div>' +
            '</div>');

        if ( videoType == 'vimeo' ) {
            var playerOptions = { url: videoUrl, autoplay: true};
            var player = new Vimeo.Player( playerId, playerOptions );
            player.ready().then(videoLoaded);
        } else {
            var ytId = getYtId( videoUrl );
            var video = new YT.Player(playerId, {
                height: '380',
                width: '640',
                videoId: ytId,
                events: {
                    'onReady': onPlayerReady,
                }
            });
        }
    }

    MicroModal.show( id, {
        awaitCloseAnimation: true,
        onClose: function() {
            setTimeout(function() {
                jQuery( '#' + id ).remove();
            },300);
        }
    } );
}

function getYtId( url ) {
    var newval = '',
        id = '';
    if (newval = url.match(/(\?|&)v=([^&#]+)/)) {
        id = newval.pop();
    } else if (newval = url.match(/(\.be\/)+([^\/]+)/)) {
        id = newval.pop();
    } else if (newval = url.match(/(\embed\/)+([^\/]+)/)) {
        id = newval.pop().replace('?rel=0','');
    }
    return id;
}

function onPlayerReady(event) {
    event.target.playVideo();
    videoLoaded();
}

function videoLoaded() {
    jQuery('.modal').fitVids();
    jQuery('.modal .video-loader').remove();
    jQuery('.modal-video-player-holder').css('opacity', 1);
}
(function($) {
    $(function() {

        objectFitImages();

        if ( $( '.disable-headroom' ).length == 0 ) {
            $('.header-container-wrapper').headroom({
                offset: 80
            });
        }

        $( '.toggle-menu' ).on('click', function (event) {
            event.preventDefault();
            $('body').toggleClass( 'main-menu-open' ).removeClass( 'animate-menu-in' );
            if( $('body').hasClass( 'main-menu-open' ) ) {
                setTimeout(function() {
                   $('body').addClass( 'animate-menu-in' );
                }, 100);
            }
        });

        $( '.site-main-menu ul' ).on( 'focus mouseenter', '.hs-item-has-children', function (e) {
            $( e.currentTarget ).find('.hs-menu-children-wrapper').addClass( 'focused' );
            $( e.currentTarget ).addClass( 'focused-parent' );
        }).on( 'blur mouseleave', '.hs-item-has-children', function (e) {
            $( e.currentTarget ).find('.hs-menu-children-wrapper').removeClass( 'focused' );
            $( e.currentTarget ).removeClass( 'focused-parent' );
        });

        $( '.site-main-menu ul' ).on( 'click', '.hs-item-has-children', function(e) {
            $( e.currentTarget ).toggleClass( 'clicked-menu-item' );
            var subMenu = $( e.currentTarget ).find('.hs-menu-children-wrapper').first();
            subMenu.toggleClass( 'focus-toggle' );
        }).on( 'click', '.hs-menu-children-wrapper, a', function(e) {
            e.stopPropagation();
        });

        $('.site-nav-contact-form + .site-secondary-menu .hs-menu-item:first-child a').on('click', function(e) {
            if ( $( '.main-menu-open' ).length == 0 ) {
                e.preventDefault();
                $(this).parents('.site-secondary-menu').toggleClass( 'toggle-nav-contact-form-hide' );
                $('.site-nav-contact-form').toggleClass( 'show-nav-form' );
            }
        });

        $('.tooltipster').tooltipster({
            animation: 'fade',
            delay: 200,
            maxWidth: 280,
            theme: 'tooltipster-shadow',
            trigger: 'custom',
            triggerOpen: {
                mouseenter: true,
                touchstart: true,
                click: true
            },
            triggerClose: {
                click: false,
                scroll: true,
                mouseleave: true,
                touchleave: false
            }
        });

        $('.tooltipster')
            .focus(function(){
                $(this).tooltipster('open');
            });

        $('.body-container-wrapper').fitVids();

        $('body').on('click', '.anchor-link', function (event) {
            event.preventDefault();
            $(this).blur();
            var target = $(this).attr('href');
            $('html, body').animate({
                scrollTop: $(target).offset().top - 50
            }, 500);
        });

    });
})(jQuery);